{"version":3,"sources":["src/worker/z80.ts","intel-hex.js","src/worker/worker.ts"],"names":["const","let","this","i","l","blockAddr","blocks","block"],"mappings":"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","file":"worker.f0688aad.map","sourceRoot":"..","sourcesContent":["///////////////////////////////////////////////////////////////////////////////\n/// @file Z80.js\n///\n/// @brief Emulator for the Zilog Z80 microprocessor\n///\n/// @author Matthew Howell\n///\n/// @remarks\n///  This module is a simple, straightforward instruction interpreter.\n///   There is no fancy dynamic recompilation or cycle-accurate emulation.\n///   The author believes that this should be sufficient for any emulator that\n///   would be feasible to write in JavaScript anyway.\n///  The code and the comments in this file assume that the reader is familiar\n///   with the Z80 architecture. If you're not, here are some references I use:\n///  http://clrhome.org/table/ - Z80 instruction set tables\n///  http://www.zilog.com/docs/z80/um0080.pdf - The official manual\n///  http://www.myquest.nl/z80undocumented/z80-documented-v0.91.pdf\n///   - The Undocumented Z80, Documented\n///\n/// @copyright (c) 2013 Matthew Howell\n///  This code is released under the MIT license,\n///  a copy of which is available in the associated README.md file,\n///  or at http://opensource.org/licenses/MIT\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n/// We'll begin with the object constructor and the public API functions.\n///////////////////////////////////////////////////////////////////////////////\n\ninterface CoreParameter {\n    mem_read: (addr: number) => any;\n    mem_write: (addr: number, value: number) => number;\n    io_read: (port: number) => any;\n    io_write: (port: number, value: number) => void;\n}\n\ninterface Z80State {\n    b:number;\n    a:number;\n    c:number;\n    d:number;\n    e:number;\n    h:number;\n    l:number;\n    a_prime:number;\n    b_prime:number;\n    c_prime:number;\n    d_prime:number;\n    e_prime:number;\n    h_prime:number;\n    l_prime:number;\n    ix:number;\n    iy:number;\n    i:number;\n    r:number;\n    sp:number;\n    pc:number;\n    flags: {\n        S:number;\n        Z:number;\n        Y:number;\n        H:number;\n        X:number;\n        P:number;\n        N:number;\n        C:number;\n    }\n    flags_prime: {\n        S:number;\n        Z:number;\n        Y:number;\n        H:number;\n        X:number;\n        P:number;\n        N:number;\n        C:number;\n    }\n    imode: number;\n    iff1: number;\n    iff2: number;\n    halted: boolean;\n    do_delayed_di: boolean;\n    do_delayed_ei: boolean;\n    cycle_counter: number;\n}\n\nexport function Z80(coreParameter: CoreParameter) {\n    // Obviously we'll be needing the core object's functions again.\n    let core = coreParameter;\n\n    // The argument to this constructor should be an object containing 4 functions:\n    // mem_read(address) should return the byte at the given memory address,\n    // mem_write(address, value) should write the given value to the given memory address,\n    // io_read(port) should read a return a byte read from the given I/O port,\n    // io_write(port, value) should write the given byte to the given I/O port.\n    // If any of those functions is missing, this module cannot run.\n    if (!core || (typeof core.mem_read !== \"function\") || (typeof core.mem_write !== \"function\") ||\n        (typeof core.io_read !== \"function\") || (typeof core.io_write !== \"function\"))\n        throw (\"Z80: Core object is missing required functions.\");\n\n    // All right, let's initialize the registers.\n    // First, the standard 8080 registers.\n    let a = 0x00;\n    let b = 0x00;\n    let c = 0x00;\n    let d = 0x00;\n    let e = 0x00;\n    let h = 0x00;\n    let l = 0x00;\n    // Now the special Z80 copies of the 8080 registers\n    //  (the ones used for the SWAP instruction and such).\n    let a_prime = 0x00;\n    let b_prime = 0x00;\n    let c_prime = 0x00;\n    let d_prime = 0x00;\n    let e_prime = 0x00;\n    let h_prime = 0x00;\n    let l_prime = 0x00;\n    // And now the Z80 index registers.\n    let ix = 0x0000;\n    let iy = 0x0000;\n    // Then the \"utility\" registers: the interrupt vector,\n    //  the memory refresh, the stack pointer, and the program counter.\n    let i = 0x00;\n    let r = 0x00;\n    let sp = 0xdff0;\n    let pc = 0x0000;\n    // We don't keep an F register for the flags,\n    //  because most of the time we're only accessing a single flag,\n    //  so we optimize for that case and use utility functions\n    //  for the rarer occasions when we need to access the whole register.\n    let flags = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };\n    let flags_prime = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };\n    // And finally we have the interrupt mode and flip-flop registers.\n    let imode = 0;\n    let iff1 = 0;\n    let iff2 = 0;\n\n    // These are all specific to this implementation, not Z80 features.\n    // Keep track of whether we've had a HALT instruction called.\n    let halted = false;\n    // EI and DI wait one instruction before they take effect;\n    //  these flags tell us when we're in that wait state.\n    let do_delayed_di = false;\n    let do_delayed_ei = false;\n    // This tracks the number of cycles spent in a single instruction run,\n    //  including processing any prefixes and handling interrupts.\n    let cycle_counter = 0;\n\n    function getState():Z80State {\n        return {\n            b: b,\n            a: a,\n            c: c,\n            d: d,\n            e: e,\n            h: h,\n            l: l,\n            a_prime: a_prime,\n            b_prime: b_prime,\n            c_prime: c_prime,\n            d_prime: d_prime,\n            e_prime: e_prime,\n            h_prime: h_prime,\n            l_prime: l_prime,\n            ix: ix,\n            iy: iy,\n            i: i,\n            r: r,\n            sp: sp,\n            pc: pc,\n            flags: {\n                S: flags.S,\n                Z: flags.Z,\n                Y: flags.Y,\n                H: flags.H,\n                X: flags.X,\n                P: flags.P,\n                N: flags.N,\n                C: flags.C\n            },\n            flags_prime: {\n                S: flags_prime.S,\n                Z: flags_prime.Z,\n                Y: flags_prime.Y,\n                H: flags_prime.H,\n                X: flags_prime.X,\n                P: flags_prime.P,\n                N: flags_prime.N,\n                C: flags_prime.C\n            },\n            imode: imode,\n            iff1: iff1,\n            iff2: iff2,\n            halted: halted,\n            do_delayed_di: do_delayed_di,\n            do_delayed_ei: do_delayed_ei,\n            cycle_counter: cycle_counter\n        };\n    }\n\n    function setState(state:Z80State) {\n        b = state.b;\n        a = state.a;\n        c = state.c;\n        d = state.d;\n        e = state.e;\n        h = state.h;\n        l = state.l;\n        a_prime = state.a_prime;\n        b_prime = state.b_prime;\n        c_prime = state.c_prime;\n        d_prime = state.d_prime;\n        e_prime = state.e_prime;\n        h_prime = state.h_prime;\n        l_prime = state.l_prime;\n        ix = state.ix;\n        iy = state.iy;\n        i = state.i;\n        r = state.r;\n        sp = state.sp;\n        pc = state.pc;\n        flags.S = state.flags.S;\n        flags.Z = state.flags.Z;\n        flags.Y = state.flags.Y;\n        flags.H = state.flags.H;\n        flags.X = state.flags.X;\n        flags.P = state.flags.P;\n        flags.N = state.flags.N;\n        flags.C = state.flags.C;\n        flags_prime.S = state.flags_prime.S;\n        flags_prime.Z = state.flags_prime.Z;\n        flags_prime.Y = state.flags_prime.Y;\n        flags_prime.H = state.flags_prime.H;\n        flags_prime.X = state.flags_prime.X;\n        flags_prime.P = state.flags_prime.P;\n        flags_prime.N = state.flags_prime.N;\n        flags_prime.C = state.flags_prime.C;\n        imode = state.imode;\n        iff1 = state.iff1;\n        iff2 = state.iff2;\n        halted = state.halted;\n        do_delayed_di = state.do_delayed_di;\n        do_delayed_ei = state.do_delayed_ei;\n        cycle_counter = state.cycle_counter;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public reset\n    ///\n    /// @brief Re-initialize the processor as if a reset or power on had occured\n    ///////////////////////////////////////////////////////////////////////////////\n    let reset = function () {\n        // These registers are the ones that have predictable states\n        //  immediately following a power-on or a reset.\n        // The others are left alone, because their states are unpredictable.\n        sp = 0xdff0;\n        pc = 0x0000;\n        a = 0x00;\n        r = 0x00;\n        set_flags_register(0);\n        // Start up with interrupts disabled.\n        imode = 0;\n        iff1 = 0;\n        iff2 = 0;\n        // Don't start halted or in a delayed DI or EI.\n        halted = false;\n        do_delayed_di = false;\n        do_delayed_ei = false;\n        // Obviously we've not used any cycles yet.\n        cycle_counter = 0;\n    };\n\n    let reset1 = function () {\n        sp = 0xdff0;\n        pc = 0x0000;\n        halted = false;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public run_instruction\n    ///\n    /// @brief Runs a single instruction\n    ///\n    /// @return The number of T cycles the instruction took to run,\n    ///          plus any time that went into handling interrupts that fired\n    ///          while this instruction was executing\n    ///////////////////////////////////////////////////////////////////////////////\n    let run_instruction = function () {\n        if (!halted) {\n            // If the previous instruction was a DI or an EI,\n            //  we'll need to disable or enable interrupts\n            //  after whatever instruction we're about to run is finished.\n            var doing_delayed_di = false, doing_delayed_ei = false;\n            if (do_delayed_di) {\n                do_delayed_di = false;\n                doing_delayed_di = true;\n            }\n            else if (do_delayed_ei) {\n                do_delayed_ei = false;\n                doing_delayed_ei = true;\n            }\n\n            // R is incremented at the start of every instruction cycle,\n            //  before the instruction actually runs.\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n            // Read the byte at the PC and run the instruction it encodes.\n            var opcode = core.mem_read(pc);\n            try {\n                decode_instruction(opcode);\n            }\n            catch (e) {\n                console.log(`Illegal opcode ${opcode} at ${pc}`, e);\n                halted = true;\n            }\n            pc = (pc + 1) & 0xffff;\n\n            // Actually do the delayed interrupt disable/enable if we have one.\n            if (doing_delayed_di) {\n                iff1 = 0;\n                iff2 = 0;\n            }\n            else if (doing_delayed_ei) {\n                iff1 = 1;\n                iff2 = 1;\n            }\n\n            // And finally clear out the cycle counter for the next instruction\n            //  before returning it to the emulator core.\n            var retval = cycle_counter;\n            cycle_counter = 0;\n            return retval;\n        }\n        else {\n            // While we're halted, claim that we spent a cycle doing nothing,\n            //  so that the rest of the emulator can still proceed.\n            return 1;\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public interrupt\n    ///\n    /// @brief Simulates pulsing the processor's INT (or NMI) pin\n    ///\n    /// @param non_maskable - true if this is a non-maskable interrupt\n    /// @param data - the value to be placed on the data bus, if needed\n    ///////////////////////////////////////////////////////////////////////////////\n    let interrupt = function (non_maskable:boolean, data:number) {\n        if (non_maskable) {\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n            // Non-maskable interrupts are always handled the same way;\n            //  clear IFF1 and then do a CALL 0x0066.\n            // Also, all interrupts reset the HALT state.\n            halted = false;\n            iff2 = iff1;\n            iff1 = 0;\n            push_word(pc);\n            pc = 0x66;\n            cycle_counter += 11;\n        }\n        else if (iff1) {\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n            halted = false;\n            iff1 = 0;\n            iff2 = 0;\n\n            if (imode === 0) {\n                // In the 8080-compatible interrupt mode,\n                //  decode the content of the data bus as an instruction and run it.\n                decode_instruction(data);\n                cycle_counter += 2;\n            }\n            else if (imode === 1) {\n                // Mode 1 is always just RST 0x38.\n                push_word(pc);\n                pc = 0x38;\n                cycle_counter += 13;\n            }\n            else if (imode === 2) {\n                // Mode 2 uses the value on the data bus as in index\n                //  into the vector table pointer to by the I register.\n                push_word(pc);\n                // The Z80 manual says that this address must be 2-byte aligned,\n                //  but it doesn't appear that this is actually the case on the hardware,\n                //  so we don't attempt to enforce that here.\n                var vector_address = ((i << 8) | data);\n                pc = core.mem_read(vector_address) |\n                    (core.mem_read((vector_address + 1) & 0xffff) << 8);\n\n                cycle_counter += 19;\n            }\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// The public API functions end here.\n    ///\n    /// What begins here are just general utility functions, used variously.\n    ///////////////////////////////////////////////////////////////////////////////\n    let decode_instruction = function (opcode:number) {\n        // The register-to-register loads and ALU instructions\n        //  are all so uniform that we can decode them directly\n        //  instead of going into the instruction array for them.\n        // This function gets the operand for all of these instructions.\n        var get_operand = function (opcode:number) {\n            return ((opcode & 0x07) === 0) ? b :\n                ((opcode & 0x07) === 1) ? c :\n                    ((opcode & 0x07) === 2) ? d :\n                        ((opcode & 0x07) === 3) ? e :\n                            ((opcode & 0x07) === 4) ? h :\n                                ((opcode & 0x07) === 5) ? l :\n                                    ((opcode & 0x07) === 6) ? core.mem_read(l | (h << 8)) : a;\n        };\n\n        // Handle HALT right up front, because it fouls up our LD decoding\n        //  by falling where LD (HL), (HL) ought to be.\n        if (opcode === 0x76) {\n            halted = true;\n        }\n        else if ((opcode >= 0x40) && (opcode < 0x80)) {\n            // This entire range is all 8-bit register loads.\n            // Get the operand and assign it to the correct destination.\n            var operand = get_operand(opcode);\n\n            if (((opcode & 0x38) >>> 3) === 0)\n                b = operand;\n            else if (((opcode & 0x38) >>> 3) === 1)\n                c = operand;\n            else if (((opcode & 0x38) >>> 3) === 2)\n                d = operand;\n            else if (((opcode & 0x38) >>> 3) === 3)\n                e = operand;\n            else if (((opcode & 0x38) >>> 3) === 4)\n                h = operand;\n            else if (((opcode & 0x38) >>> 3) === 5)\n                l = operand;\n            else if (((opcode & 0x38) >>> 3) === 6)\n                core.mem_write(l | (h << 8), operand);\n            else if (((opcode & 0x38) >>> 3) === 7)\n                a = operand;\n        }\n        else if ((opcode >= 0x80) && (opcode < 0xc0)) {\n            // These are the 8-bit register ALU instructions.\n            // We'll get the operand and then use this \"jump table\"\n            //  to call the correct utility function for the instruction.\n            var operand = get_operand(opcode),\n                op_array = [do_add, do_adc, do_sub, do_sbc,\n                    do_and, do_xor, do_or, do_cp];\n\n            op_array[(opcode & 0x38) >>> 3](operand);\n        }\n        else {\n            // This is one of the less formulaic instructions;\n            //  we'll get the specific function for it from our array.\n            var func = instructions[opcode];\n            func();\n        }\n\n        // Update the cycle counter with however many cycles\n        //  the base instruction took.\n        // If this was a prefixed instruction, then\n        //  the prefix handler has added its extra cycles already.\n        cycle_counter += cycle_counts[opcode];\n    };\n\n    let get_signed_offset_byte = function (value:number) {\n        // This function requires some explanation.\n        // We just use JavaScript Number variables for our registers,\n        //  not like a typed array or anything.\n        // That means that, when we have a byte value that's supposed\n        //  to represent a signed offset, the value we actually see\n        //  isn't signed at all, it's just a small integer.\n        // So, this function converts that byte into something JavaScript\n        //  will recognize as signed, so we can easily do arithmetic with it.\n        // First, we clamp the value to a single byte, just in case.\n        value &= 0xff;\n        // We don't have to do anything if the value is positive.\n        if (value & 0x80) {\n            // But if the value is negative, we need to manually un-two's-compliment it.\n            // I'm going to assume you can figure out what I meant by that,\n            //  because I don't know how else to explain it.\n            // We could also just do value |= 0xffffff00, but I prefer\n            //  not caring how many bits are in the integer representation\n            //  of a JavaScript number in the currently running browser.\n            value = -((0xff & ~value) + 1);\n        }\n        return value;\n    };\n\n    let get_flags_register = function () {\n        // We need the whole F register for some reason.\n        //  probably a PUSH AF instruction,\n        //  so make the F register out of our separate flags.\n        return (flags.S << 7) |\n            (flags.Z << 6) |\n            (flags.Y << 5) |\n            (flags.H << 4) |\n            (flags.X << 3) |\n            (flags.P << 2) |\n            (flags.N << 1) |\n            (flags.C);\n    };\n\n    let get_flags_prime = function () {\n        // This is the same as the above for the F' register.\n        return (flags_prime.S << 7) |\n            (flags_prime.Z << 6) |\n            (flags_prime.Y << 5) |\n            (flags_prime.H << 4) |\n            (flags_prime.X << 3) |\n            (flags_prime.P << 2) |\n            (flags_prime.N << 1) |\n            (flags_prime.C);\n    };\n\n    let set_flags_register = function (operand:number) {\n        // We need to set the F register, probably for a POP AF,\n        //  so break out the given value into our separate flags.\n        flags.S = (operand & 0x80) >>> 7;\n        flags.Z = (operand & 0x40) >>> 6;\n        flags.Y = (operand & 0x20) >>> 5;\n        flags.H = (operand & 0x10) >>> 4;\n        flags.X = (operand & 0x08) >>> 3;\n        flags.P = (operand & 0x04) >>> 2;\n        flags.N = (operand & 0x02) >>> 1;\n        flags.C = (operand & 0x01);\n    };\n\n    let set_flags_prime = function (operand:number) {\n        // Again, this is the same as the above for F'.\n        flags_prime.S = (operand & 0x80) >>> 7;\n        flags_prime.Z = (operand & 0x40) >>> 6;\n        flags_prime.Y = (operand & 0x20) >>> 5;\n        flags_prime.H = (operand & 0x10) >>> 4;\n        flags_prime.X = (operand & 0x08) >>> 3;\n        flags_prime.P = (operand & 0x04) >>> 2;\n        flags_prime.N = (operand & 0x02) >>> 1;\n        flags_prime.C = (operand & 0x01);\n    };\n\n    let update_xy_flags = function (result:number) {\n        // Most of the time, the undocumented flags\n        //  (sometimes called X and Y, or 3 and 5),\n        //  take their values from the corresponding bits\n        //  of the result of the instruction,\n        //  or from some other related value.\n        // This is a utility function to set those flags based on those bits.\n        flags.Y = (result & 0x20) >>> 5;\n        flags.X = (result & 0x08) >>> 3;\n    };\n\n    let get_parity = function (value:number) {\n        // We could try to actually calculate the parity every time,\n        //  but why calculate what you can pre-calculate?\n        var parity_bits = [\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1\n        ];\n        return parity_bits[value];\n    };\n\n    let push_word = function (operand:number) {\n        // Pretty obvious what this function does; given a 16-bit value,\n        //  decrement the stack pointer, write the high byte to the new\n        //  stack pointer location, then repeat for the low byte.\n        sp = (sp - 1) & 0xffff;\n        core.mem_write(sp, (operand & 0xff00) >>> 8);\n        sp = (sp - 1) & 0xffff;\n        core.mem_write(sp, operand & 0x00ff);\n    };\n\n    let pop_word = function () {\n        // Again, not complicated; read a byte off the top of the stack,\n        //  increment the stack pointer, rinse and repeat.\n        var retval = core.mem_read(sp) & 0xff;\n        sp = (sp + 1) & 0xffff;\n        retval |= core.mem_read(sp) << 8;\n        sp = (sp + 1) & 0xffff;\n        return retval;\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// Now, the way most instructions work in this emulator is that they set up\n    ///  their operands according to their addressing mode, and then they call a\n    ///  utility function that handles all variations of that instruction.\n    /// Those utility functions begin here.\n    ///////////////////////////////////////////////////////////////////////////////\n    let do_conditional_absolute_jump = function (condition:boolean) {\n        // This function implements the JP [condition],nn instructions.\n        if (condition) {\n            // We're taking this jump, so write the new PC,\n            //  and then decrement the thing we just wrote,\n            //  because the instruction decoder increments the PC\n            //  unconditionally at the end of every instruction\n            //  and we need to counteract that so we end up at the jump target.\n            pc = core.mem_read((pc + 1) & 0xffff) |\n                (core.mem_read((pc + 2) & 0xffff) << 8);\n            pc = (pc - 1) & 0xffff;\n        }\n        else {\n            // We're not taking this jump, just move the PC past the operand.\n            pc = (pc + 2) & 0xffff;\n        }\n    };\n\n    let do_conditional_relative_jump = function (condition:boolean) {\n        // This function implements the JR [condition],n instructions.\n        if (condition) {\n            // We need a few more cycles to actually take the jump.\n            cycle_counter += 5;\n            // Calculate the offset specified by our operand.\n            var offset = get_signed_offset_byte(core.mem_read((pc + 1) & 0xffff));\n            // Add the offset to the PC, also skipping past this instruction.\n            pc = (pc + offset + 1) & 0xffff;\n        }\n        else {\n            // No jump happening, just skip the operand.\n            pc = (pc + 1) & 0xffff;\n        }\n    };\n\n    let do_conditional_call = function (condition:boolean) {\n        // This function is the CALL [condition],nn instructions.\n        // If you've seen the previous functions, you know this drill.\n        if (condition) {\n            cycle_counter += 7;\n            push_word((pc + 3) & 0xffff);\n            pc = core.mem_read((pc + 1) & 0xffff) |\n                (core.mem_read((pc + 2) & 0xffff) << 8);\n            pc = (pc - 1) & 0xffff;\n        }\n        else {\n            pc = (pc + 2) & 0xffff;\n        }\n    };\n\n    let do_conditional_return = function (condition:boolean) {\n        if (condition) {\n            cycle_counter += 6;\n            pc = (pop_word() - 1) & 0xffff;\n        }\n    };\n\n    let do_reset = function (address:number) {\n        // The RST [address] instructions go through here.\n        push_word((pc + 1) & 0xffff);\n        pc = (address - 1) & 0xffff;\n    };\n\n    let do_add = function (operand:number) {\n        // This is the ADD A, [operand] instructions.\n        // We'll do the literal addition, which includes any overflow,\n        //  so that we can more easily figure out whether we had\n        //  an overflow or a carry and set the flags accordingly.\n        var result = a + operand;\n\n        // The great majority of the work for the arithmetic instructions\n        //  turns out to be setting the flags rather than the actual operation.\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((operand & 0x0f) + (a & 0x0f)) & 0x10) ? 1 : 0;\n        // An overflow has happened if the sign bits of the accumulator and the operand\n        //  don't match the sign bit of the result value.\n        flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_adc = function (operand:number) {\n        var result = a + operand + flags.C;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((operand & 0x0f) + (a & 0x0f) + flags.C) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_sub = function (operand:number) {\n        var result = a - operand;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((a & 0x0f) - (operand & 0x0f)) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_sbc = function (operand:number) {\n        var result = a - operand - flags.C;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((a & 0x0f) - (operand & 0x0f) - flags.C) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_cp = function (operand:number) {\n        // A compare instruction is just a subtraction that doesn't save the value,\n        //  so we implement it as... a subtraction that doesn't save the value.\n        var temp = a;\n        do_sub(operand);\n        a = temp;\n        // Since this instruction has no \"result\" value, the undocumented flags\n        //  are set based on the operand instead.\n        update_xy_flags(operand);\n    };\n\n    let do_and = function (operand:number) {\n        // The logic instructions are all pretty straightforward.\n        a &= operand & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 1;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_or = function (operand:number) {\n        a = (operand | a) & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 0;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_xor = function (operand:number) {\n        a = (operand ^ a) & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 0;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_inc = function (operand:number) {\n        var result = operand + 1;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = ((operand & 0x0f) === 0x0f) ? 1 : 0;\n        // It's a good deal easier to detect overflow for an increment/decrement.\n        flags.P = (operand === 0x7f) ? 1 : 0;\n        flags.N = 0;\n\n        result &= 0xff;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_dec = function (operand:number) {\n        var result = operand - 1;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = ((operand & 0x0f) === 0x00) ? 1 : 0;\n        flags.P = (operand === 0x80) ? 1 : 0;\n        flags.N = 1;\n\n        result &= 0xff;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_hl_add = function (operand:number) {\n        // The HL arithmetic instructions are the same as the A ones,\n        //  just with twice as many bits happening.\n        var hl = l | (h << 8), result = hl + operand;\n\n        flags.N = 0;\n        flags.C = (result & 0x10000) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        update_xy_flags(h);\n    };\n\n    let do_hl_adc = function (operand:number) {\n        operand += flags.C;\n        var hl = l | (h << 8), result = hl + operand;\n\n        flags.S = (result & 0x8000) ? 1 : 0;\n        flags.Z = !(result & 0xffff) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n        flags.P = ((hl & 0x8000) === (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x10000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result >>> 8) & 0xff;\n\n        update_xy_flags(h);\n    };\n\n    let do_hl_sbc = function (operand:number) {\n        operand += flags.C;\n        var hl = l | (h << 8), result = hl - operand;\n\n        flags.S = (result & 0x8000) ? 1 : 0;\n        flags.Z = !(result & 0xffff) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) - (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n        flags.P = ((hl & 0x8000) !== (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x10000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result >>> 8) & 0xff;\n\n        update_xy_flags(h);\n    };\n\n    let do_in = function (port:number) {\n        var result = core.io_read(port);\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = result ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(result) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_neg = function () {\n        // This instruction is defined to not alter the register if it === 0x80.\n        if (a !== 0x80) {\n            // This is a signed operation, so convert A to a signed value.\n            a = get_signed_offset_byte(a);\n\n            a = (-a) & 0xff;\n        }\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = (((-a) & 0x0f) > 0) ? 1 : 0;\n        flags.P = (a === 0x80) ? 1 : 0;\n        flags.N = 1;\n        flags.C = a ? 1 : 0;\n        update_xy_flags(a);\n    };\n\n    let do_ldi = function () {\n        // Copy the value that we're supposed to copy.\n        var read_value = core.mem_read(l | (h << 8));\n        core.mem_write(e | (d << 8), read_value);\n\n        // Increment DE and HL, and decrement BC.\n        var result = (e | (d << 8)) + 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n        result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.H = 0;\n        flags.P = (c || b) ? 1 : 0;\n        flags.N = 0;\n        flags.Y = ((a + read_value) & 0x02) >>> 1;\n        flags.X = ((a + read_value) & 0x08) >>> 3;\n    };\n\n    let do_cpi = function () {\n        var temp_carry = flags.C;\n        var read_value = core.mem_read(l | (h << 8))\n        do_cp(read_value);\n        flags.C = temp_carry;\n        flags.Y = ((a - read_value - flags.H) & 0x02) >>> 1;\n        flags.X = ((a - read_value - flags.H) & 0x08) >>> 3;\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = result ? 1 : 0;\n    };\n\n    let do_ini = function () {\n        b = do_dec(b);\n\n        core.mem_write(l | (h << 8), core.io_read((b << 8) | c));\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        flags.N = 1;\n    };\n\n    let do_outi = function () {\n        core.io_write((b << 8) | c, core.mem_read(l | (h << 8)));\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        b = do_dec(b);\n        flags.N = 1;\n    };\n\n    let do_ldd = function () {\n        flags.N = 0;\n        flags.H = 0;\n\n        var read_value = core.mem_read(l | (h << 8));\n        core.mem_write(e | (d << 8), read_value);\n\n        var result = (e | (d << 8)) - 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n        result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = (c || b) ? 1 : 0;\n        flags.Y = ((a + read_value) & 0x02) >>> 1;\n        flags.X = ((a + read_value) & 0x08) >>> 3;\n    };\n\n    let do_cpd = function () {\n        var temp_carry = flags.C\n        var read_value = core.mem_read(l | (h << 8))\n        do_cp(read_value);\n        flags.C = temp_carry;\n        flags.Y = ((a - read_value - flags.H) & 0x02) >>> 1;\n        flags.X = ((a - read_value - flags.H) & 0x08) >>> 3;\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = result ? 1 : 0;\n    };\n\n    let do_ind = function () {\n        b = do_dec(b);\n\n        core.mem_write(l | (h << 8), core.io_read((b << 8) | c));\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        flags.N = 1;\n    };\n\n    let do_outd = function () {\n        core.io_write((b << 8) | c, core.mem_read(l | (h << 8)));\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        b = do_dec(b);\n        flags.N = 1;\n    };\n\n    let do_rlc = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) | flags.C) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_rrc = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (flags.C << 7);\n\n        flags.Z = !(operand & 0xff) ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand & 0xff;\n    };\n\n    let do_rl = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        var temp = flags.C;\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) | temp) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_rr = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        var temp = flags.C;\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (temp << 7);\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sla = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = (operand << 1) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sra = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (operand & 0x80);\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sll = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) & 0xff) | 1;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_srl = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = (operand >>> 1) & 0x7f;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_ix_add = function (operand:number) {\n        flags.N = 0;\n\n        var result = ix + operand;\n\n        flags.C = (result & 0x10000) ? 1 : 0;\n        flags.H = (((ix & 0xfff) + (operand & 0xfff)) & 0x1000) ? 1 : 0;\n        update_xy_flags((result & 0xff00) >>> 8);\n\n        ix = result;\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// This table contains the implementations for the instructions that weren't\n    ///  implemented directly in the decoder function (everything but the 8-bit\n    ///  register loads and the accumulator ALU instructions, in other words).\n    /// Similar tables for the ED and DD/FD prefixes follow this one.\n    ///////////////////////////////////////////////////////////////////////////////\n    let instructions:any[] = [];\n\n    // 0x00 : NOP\n    instructions[0x00] = function () { };\n    // 0x01 : LD BC, nn\n    instructions[0x01] = function () {\n        pc = (pc + 1) & 0xffff;\n        c = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        b = core.mem_read(pc);\n    };\n    // 0x02 : LD (BC), A\n    instructions[0x02] = function () {\n        core.mem_write(c | (b << 8), a);\n    };\n    // 0x03 : INC BC\n    instructions[0x03] = function () {\n        var result = (c | (b << 8));\n        result += 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0x04 : INC B\n    instructions[0x04] = function () {\n        b = do_inc(b);\n    };\n    // 0x05 : DEC B\n    instructions[0x05] = function () {\n        b = do_dec(b);\n    };\n    // 0x06 : LD B, n\n    instructions[0x06] = function () {\n        pc = (pc + 1) & 0xffff;\n        b = core.mem_read(pc);\n    };\n    // 0x07 : RLCA\n    instructions[0x07] = function () {\n        // This instruction is implemented as a special case of the\n        //  more general Z80-specific RLC instruction.\n        // Specifially, RLCA is a version of RLC A that affects fewer flags.\n        // The same applies to RRCA, RLA, and RRA.\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rlc(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x08 : EX AF, AF'\n    instructions[0x08] = function () {\n        var temp = a;\n        a = a_prime;\n        a_prime = temp;\n\n        temp = get_flags_register();\n        set_flags_register(get_flags_prime());\n        set_flags_prime(temp);\n    };\n    // 0x09 : ADD HL, BC\n    instructions[0x09] = function () {\n        do_hl_add(c | (b << 8));\n    };\n    // 0x0a : LD A, (BC)\n    instructions[0x0a] = function () {\n        a = core.mem_read(c | (b << 8));\n    };\n    // 0x0b : DEC BC\n    instructions[0x0b] = function () {\n        var result = (c | (b << 8));\n        result -= 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0x0c : INC C\n    instructions[0x0c] = function () {\n        c = do_inc(c);\n    };\n    // 0x0d : DEC C\n    instructions[0x0d] = function () {\n        c = do_dec(c);\n    };\n    // 0x0e : LD C, n\n    instructions[0x0e] = function () {\n        pc = (pc + 1) & 0xffff;\n        c = core.mem_read(pc);\n    };\n    // 0x0f : RRCA\n    instructions[0x0f] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rrc(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x10 : DJNZ nn\n    instructions[0x10] = function () {\n        b = (b - 1) & 0xff;\n        do_conditional_relative_jump(b !== 0);\n    };\n    // 0x11 : LD DE, nn\n    instructions[0x11] = function () {\n        pc = (pc + 1) & 0xffff;\n        e = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        d = core.mem_read(pc);\n    };\n    // 0x12 : LD (DE), A\n    instructions[0x12] = function () {\n        core.mem_write(e | (d << 8), a);\n    };\n    // 0x13 : INC DE\n    instructions[0x13] = function () {\n        var result = (e | (d << 8));\n        result += 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0x14 : INC D\n    instructions[0x14] = function () {\n        d = do_inc(d);\n    };\n    // 0x15 : DEC D\n    instructions[0x15] = function () {\n        d = do_dec(d);\n    };\n    // 0x16 : LD D, n\n    instructions[0x16] = function () {\n        pc = (pc + 1) & 0xffff;\n        d = core.mem_read(pc);\n    };\n    // 0x17 : RLA\n    instructions[0x17] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rl(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x18 : JR n\n    instructions[0x18] = function () {\n        var offset = get_signed_offset_byte(core.mem_read((pc + 1) & 0xffff));\n        pc = (pc + offset + 1) & 0xffff;\n    };\n    // 0x19 : ADD HL, DE\n    instructions[0x19] = function () {\n        do_hl_add(e | (d << 8));\n    };\n    // 0x1a : LD A, (DE)\n    instructions[0x1a] = function () {\n        a = core.mem_read(e | (d << 8));\n    };\n    // 0x1b : DEC DE\n    instructions[0x1b] = function () {\n        var result = (e | (d << 8));\n        result -= 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0x1c : INC E\n    instructions[0x1c] = function () {\n        e = do_inc(e);\n    };\n    // 0x1d : DEC E\n    instructions[0x1d] = function () {\n        e = do_dec(e);\n    };\n    // 0x1e : LD E, n\n    instructions[0x1e] = function () {\n        pc = (pc + 1) & 0xffff;\n        e = core.mem_read(pc);\n    };\n    // 0x1f : RRA\n    instructions[0x1f] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rr(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x20 : JR NZ, n\n    instructions[0x20] = function () {\n        do_conditional_relative_jump(!flags.Z);\n    };\n    // 0x21 : LD HL, nn\n    instructions[0x21] = function () {\n        pc = (pc + 1) & 0xffff;\n        l = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        h = core.mem_read(pc);\n    };\n    // 0x22 : LD (nn), HL\n    instructions[0x22] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, l);\n        core.mem_write((address + 1) & 0xffff, h);\n    };\n    // 0x23 : INC HL\n    instructions[0x23] = function () {\n        var result = (l | (h << 8));\n        result += 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0x24 : INC H\n    instructions[0x24] = function () {\n        h = do_inc(h);\n    };\n    // 0x25 : DEC H\n    instructions[0x25] = function () {\n        h = do_dec(h);\n    };\n    // 0x26 : LD H, n\n    instructions[0x26] = function () {\n        pc = (pc + 1) & 0xffff;\n        h = core.mem_read(pc);\n    };\n    // 0x27 : DAA\n    instructions[0x27] = function () {\n        var temp = a;\n        if (!flags.N) {\n            if (flags.H || ((a & 0x0f) > 9))\n                temp += 0x06;\n            if (flags.C || (a > 0x99))\n                temp += 0x60;\n        }\n        else {\n            if (flags.H || ((a & 0x0f) > 9))\n                temp -= 0x06;\n            if (flags.C || (a > 0x99))\n                temp -= 0x60;\n        }\n\n        flags.S = (temp & 0x80) ? 1 : 0;\n        flags.Z = !(temp & 0xff) ? 1 : 0;\n        flags.H = ((a & 0x10) ^ (temp & 0x10)) ? 1 : 0;\n        flags.P = get_parity(temp & 0xff);\n        // DAA never clears the carry flag if it was already set,\n        //  but it is able to set the carry flag if it was clear.\n        // Don't ask me, I don't know.\n        // Note also that we check for a BCD carry, instead of the usual.\n        flags.C = (flags.C || (a > 0x99)) ? 1 : 0;\n\n        a = temp & 0xff;\n\n        update_xy_flags(a);\n    };\n    // 0x28 : JR Z, n\n    instructions[0x28] = function () {\n        do_conditional_relative_jump(!!flags.Z);\n    };\n    // 0x29 : ADD HL, HL\n    instructions[0x29] = function () {\n        do_hl_add(l | (h << 8));\n    };\n    // 0x2a : LD HL, (nn)\n    instructions[0x2a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        l = core.mem_read(address);\n        h = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x2b : DEC HL\n    instructions[0x2b] = function () {\n        var result = (l | (h << 8));\n        result -= 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0x2c : INC L\n    instructions[0x2c] = function () {\n        l = do_inc(l);\n    };\n    // 0x2d : DEC L\n    instructions[0x2d] = function () {\n        l = do_dec(l);\n    };\n    // 0x2e : LD L, n\n    instructions[0x2e] = function () {\n        pc = (pc + 1) & 0xffff;\n        l = core.mem_read(pc);\n    };\n    // 0x2f : CPL\n    instructions[0x2f] = function () {\n        a = (~a) & 0xff;\n        flags.N = 1;\n        flags.H = 1;\n        update_xy_flags(a);\n    };\n    // 0x30 : JR NC, n\n    instructions[0x30] = function () {\n        do_conditional_relative_jump(!flags.C);\n    };\n    // 0x31 : LD SP, nn\n    instructions[0x31] = function () {\n        sp = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc + 2) & 0xffff;\n    };\n    // 0x32 : LD (nn), A\n    instructions[0x32] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, a);\n    };\n    // 0x33 : INC SP\n    instructions[0x33] = function () {\n        sp = (sp + 1) & 0xffff;\n    };\n    // 0x34 : INC (HL)\n    instructions[0x34] = function () {\n        var address = l | (h << 8);\n        core.mem_write(address, do_inc(core.mem_read(address)));\n    };\n    // 0x35 : DEC (HL)\n    instructions[0x35] = function () {\n        var address = l | (h << 8);\n        core.mem_write(address, do_dec(core.mem_read(address)));\n    };\n    // 0x36 : LD (HL), n\n    instructions[0x36] = function () {\n        pc = (pc + 1) & 0xffff;\n        core.mem_write(l | (h << 8), core.mem_read(pc));\n    };\n    // 0x37 : SCF\n    instructions[0x37] = function () {\n        flags.N = 0;\n        flags.H = 0;\n        flags.C = 1;\n        update_xy_flags(a);\n    };\n    // 0x38 : JR C, n\n    instructions[0x38] = function () {\n        do_conditional_relative_jump(!!flags.C);\n    };\n    // 0x39 : ADD HL, SP\n    instructions[0x39] = function () {\n        do_hl_add(sp);\n    };\n    // 0x3a : LD A, (nn)\n    instructions[0x3a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        a = core.mem_read(address);\n    };\n    // 0x3b : DEC SP\n    instructions[0x3b] = function () {\n        sp = (sp - 1) & 0xffff;\n    };\n    // 0x3c : INC A\n    instructions[0x3c] = function () {\n        a = do_inc(a);\n    };\n    // 0x3d : DEC A\n    instructions[0x3d] = function () {\n        a = do_dec(a);\n    };\n    // 0x3e : LD A, n\n    instructions[0x3e] = function () {\n        a = core.mem_read((pc + 1) & 0xffff);\n        pc = (pc + 1) & 0xffff;\n    };\n    // 0x3f : CCF\n    instructions[0x3f] = function () {\n        flags.N = 0;\n        flags.H = flags.C;\n        flags.C = flags.C ? 0 : 1;\n        update_xy_flags(a);\n    };\n    // 0xc0 : RET NZ\n    instructions[0xc0] = function () {\n        do_conditional_return(!flags.Z);\n    };\n    // 0xc1 : POP BC\n    instructions[0xc1] = function () {\n        var result = pop_word();\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0xc2 : JP NZ, nn\n    instructions[0xc2] = function () {\n        do_conditional_absolute_jump(!flags.Z);\n    };\n    // 0xc3 : JP nn\n    instructions[0xc3] = function () {\n        pc = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xc4 : CALL NZ, nn\n    instructions[0xc4] = function () {\n        do_conditional_call(!flags.Z);\n    };\n    // 0xc5 : PUSH BC\n    instructions[0xc5] = function () {\n        push_word(c | (b << 8));\n    };\n    // 0xc6 : ADD A, n\n    instructions[0xc6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_add(core.mem_read(pc));\n    };\n    // 0xc7 : RST 00h\n    instructions[0xc7] = function () {\n        do_reset(0x00);\n    };\n    // 0xc8 : RET Z\n    instructions[0xc8] = function () {\n        do_conditional_return(!!flags.Z);\n    };\n    // 0xc9 : RET\n    instructions[0xc9] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n    };\n    // 0xca : JP Z, nn\n    instructions[0xca] = function () {\n        do_conditional_absolute_jump(!!flags.Z);\n    };\n    // 0xcb : CB Prefix\n    instructions[0xcb] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        // We don't have a table for this prefix,\n        //  the instructions are all so uniform that we can directly decode them.\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            bit_number = (opcode & 0x38) >>> 3,\n            reg_code = opcode & 0x07;\n\n        if (opcode < 0x40) {\n            // Shift/rotate instructions\n            var op_array = [do_rlc, do_rrc, do_rl, do_rr,\n                do_sla, do_sra, do_sll, do_srl];\n\n            if (reg_code === 0)\n                b = op_array[bit_number](b);\n            else if (reg_code === 1)\n                c = op_array[bit_number](c);\n            else if (reg_code === 2)\n                d = op_array[bit_number](d);\n            else if (reg_code === 3)\n                e = op_array[bit_number](e);\n            else if (reg_code === 4)\n                h = op_array[bit_number](h);\n            else if (reg_code === 5)\n                l = op_array[bit_number](l);\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    op_array[bit_number](core.mem_read(l | (h << 8))));\n            else if (reg_code === 7)\n                a = op_array[bit_number](a);\n        }\n        else if (opcode < 0x80) {\n            // BIT instructions\n            if (reg_code === 0)\n                flags.Z = !(b & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 1)\n                flags.Z = !(c & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 2)\n                flags.Z = !(d & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 3)\n                flags.Z = !(e & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 4)\n                flags.Z = !(h & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 5)\n                flags.Z = !(l & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 6)\n                flags.Z = !((core.mem_read(l | (h << 8))) & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 7)\n                flags.Z = !(a & (1 << bit_number)) ? 1 : 0;\n\n            flags.N = 0;\n            flags.H = 1;\n            flags.P = flags.Z;\n            flags.S = ((bit_number === 7) && !flags.Z) ? 1 : 0;\n            // For the BIT n, (HL) instruction, the X and Y flags are obtained\n            //  from what is apparently an internal temporary register used for\n            //  some of the 16-bit arithmetic instructions.\n            // I haven't implemented that register here,\n            //  so for now we'll set X and Y the same way for every BIT opcode,\n            //  which means that they will usually be wrong for BIT n, (HL).\n            flags.Y = ((bit_number === 5) && !flags.Z) ? 1 : 0;\n            flags.X = ((bit_number === 3) && !flags.Z) ? 1 : 0;\n        }\n        else if (opcode < 0xc0) {\n            // RES instructions\n            if (reg_code === 0)\n                b &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 1)\n                c &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 2)\n                d &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 3)\n                e &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 4)\n                h &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 5)\n                l &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    core.mem_read(l | (h << 8)) & ~(1 << bit_number));\n            else if (reg_code === 7)\n                a &= (0xff & ~(1 << bit_number));\n        }\n        else {\n            // SET instructions\n            if (reg_code === 0)\n                b |= (1 << bit_number);\n            else if (reg_code === 1)\n                c |= (1 << bit_number);\n            else if (reg_code === 2)\n                d |= (1 << bit_number);\n            else if (reg_code === 3)\n                e |= (1 << bit_number);\n            else if (reg_code === 4)\n                h |= (1 << bit_number);\n            else if (reg_code === 5)\n                l |= (1 << bit_number);\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    core.mem_read(l | (h << 8)) | (1 << bit_number));\n            else if (reg_code === 7)\n                a |= (1 << bit_number);\n        }\n\n        cycle_counter += cycle_counts_cb[opcode];\n    };\n    // 0xcc : CALL Z, nn\n    instructions[0xcc] = function () {\n        do_conditional_call(!!flags.Z);\n    };\n    // 0xcd : CALL nn\n    instructions[0xcd] = function () {\n        push_word((pc + 3) & 0xffff);\n        pc = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xce : ADC A, n\n    instructions[0xce] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_adc(core.mem_read(pc));\n    };\n    // 0xcf : RST 08h\n    instructions[0xcf] = function () {\n        do_reset(0x08);\n    };\n    // 0xd0 : RET NC\n    instructions[0xd0] = function () {\n        do_conditional_return(!flags.C);\n    };\n    // 0xd1 : POP DE\n    instructions[0xd1] = function () {\n        var result = pop_word();\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0xd2 : JP NC, nn\n    instructions[0xd2] = function () {\n        do_conditional_absolute_jump(!flags.C);\n    };\n    // 0xd3 : OUT (n), A\n    instructions[0xd3] = function () {\n        pc = (pc + 1) & 0xffff;\n        core.io_write((a << 8) | core.mem_read(pc), a);\n    };\n    // 0xd4 : CALL NC, nn\n    instructions[0xd4] = function () {\n        do_conditional_call(!flags.C);\n    };\n    // 0xd5 : PUSH DE\n    instructions[0xd5] = function () {\n        push_word(e | (d << 8));\n    };\n    // 0xd6 : SUB n\n    instructions[0xd6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_sub(core.mem_read(pc));\n    };\n    // 0xd7 : RST 10h\n    instructions[0xd7] = function () {\n        do_reset(0x10);\n    };\n    // 0xd8 : RET C\n    instructions[0xd8] = function () {\n        do_conditional_return(!!flags.C);\n    };\n    // 0xd9 : EXX\n    instructions[0xd9] = function () {\n        var temp = b;\n        b = b_prime;\n        b_prime = temp;\n        temp = c;\n        c = c_prime;\n        c_prime = temp;\n        temp = d;\n        d = d_prime;\n        d_prime = temp;\n        temp = e;\n        e = e_prime;\n        e_prime = temp;\n        temp = h;\n        h = h_prime;\n        h_prime = temp;\n        temp = l;\n        l = l_prime;\n        l_prime = temp;\n    };\n    // 0xda : JP C, nn\n    instructions[0xda] = function () {\n        do_conditional_absolute_jump(!!flags.C);\n    };\n    // 0xdb : IN A, (n)\n    instructions[0xdb] = function () {\n        pc = (pc + 1) & 0xffff;\n        a = core.io_read((a << 8) | core.mem_read(pc));\n    };\n    // 0xdc : CALL C, nn\n    instructions[0xdc] = function () {\n        do_conditional_call(!!flags.C);\n    };\n    // 0xdd : DD Prefix (IX instructions)\n    instructions[0xdd] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = dd_instructions[opcode];\n\n        if (func) {\n            //func = func.bind(this);\n            func();\n            cycle_counter += cycle_counts_dd[opcode];\n        }\n        else {\n            // Apparently if a DD opcode doesn't exist,\n            //  it gets treated as an unprefixed opcode.\n            // What we'll do to handle that is just back up the\n            //  program counter, so that this byte gets decoded\n            //  as a normal instruction.\n            pc = (pc - 1) & 0xffff;\n            // And we'll add in the cycle count for a NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xde : SBC n\n    instructions[0xde] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_sbc(core.mem_read(pc));\n    };\n    // 0xdf : RST 18h\n    instructions[0xdf] = function () {\n        do_reset(0x18);\n    };\n    // 0xe0 : RET PO\n    instructions[0xe0] = function () {\n        do_conditional_return(!flags.P);\n    };\n    // 0xe1 : POP HL\n    instructions[0xe1] = function () {\n        var result = pop_word();\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0xe2 : JP PO, (nn)\n    instructions[0xe2] = function () {\n        do_conditional_absolute_jump(!flags.P);\n    };\n    // 0xe3 : EX (SP), HL\n    instructions[0xe3] = function () {\n        var temp = core.mem_read(sp);\n        core.mem_write(sp, l);\n        l = temp;\n        temp = core.mem_read((sp + 1) & 0xffff);\n        core.mem_write((sp + 1) & 0xffff, h);\n        h = temp;\n    };\n    // 0xe4 : CALL PO, nn\n    instructions[0xe4] = function () {\n        do_conditional_call(!flags.P);\n    };\n    // 0xe5 : PUSH HL\n    instructions[0xe5] = function () {\n        push_word(l | (h << 8));\n    };\n    // 0xe6 : AND n\n    instructions[0xe6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_and(core.mem_read(pc));\n    };\n    // 0xe7 : RST 20h\n    instructions[0xe7] = function () {\n        do_reset(0x20);\n    };\n    // 0xe8 : RET PE\n    instructions[0xe8] = function () {\n        do_conditional_return(!!flags.P);\n    };\n    // 0xe9 : JP (HL)\n    instructions[0xe9] = function () {\n        pc = l | (h << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xea : JP PE, nn\n    instructions[0xea] = function () {\n        do_conditional_absolute_jump(!!flags.P);\n    };\n    // 0xeb : EX DE, HL\n    instructions[0xeb] = function () {\n        var temp = d;\n        d = h;\n        h = temp;\n        temp = e;\n        e = l;\n        l = temp;\n    };\n    // 0xec : CALL PE, nn\n    instructions[0xec] = function () {\n        do_conditional_call(!!flags.P);\n    };\n    // 0xed : ED Prefix\n    instructions[0xed] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = ed_instructions[opcode];\n\n        if (func) {\n            //func = func.bind(this);\n            func();\n            cycle_counter += cycle_counts_ed[opcode];\n        }\n        else {\n            // If the opcode didn't exist, the whole thing is a two-byte NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xee : XOR n\n    instructions[0xee] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_xor(core.mem_read(pc));\n    };\n    // 0xef : RST 28h\n    instructions[0xef] = function () {\n        do_reset(0x28);\n    };\n    // 0xf0 : RET P\n    instructions[0xf0] = function () {\n        do_conditional_return(!flags.S);\n    };\n    // 0xf1 : POP AF\n    instructions[0xf1] = function () {\n        var result = pop_word();\n        set_flags_register(result & 0xff);\n        a = (result & 0xff00) >>> 8;\n    };\n    // 0xf2 : JP P, nn\n    instructions[0xf2] = function () {\n        do_conditional_absolute_jump(!flags.S);\n    };\n    // 0xf3 : DI\n    instructions[0xf3] = function () {\n        // DI doesn't actually take effect until after the next instruction.\n        do_delayed_di = true;\n    };\n    // 0xf4 : CALL P, nn\n    instructions[0xf4] = function () {\n        do_conditional_call(!flags.S);\n    };\n    // 0xf5 : PUSH AF\n    instructions[0xf5] = function () {\n        push_word(get_flags_register() | (a << 8));\n    };\n    // 0xf6 : OR n\n    instructions[0xf6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_or(core.mem_read(pc));\n    };\n    // 0xf7 : RST 30h\n    instructions[0xf7] = function () {\n        do_reset(0x30);\n    };\n    // 0xf8 : RET M\n    instructions[0xf8] = function () {\n        do_conditional_return(!!flags.S);\n    };\n    // 0xf9 : LD SP, HL\n    instructions[0xf9] = function () {\n        sp = l | (h << 8);\n    };\n    // 0xfa : JP M, nn\n    instructions[0xfa] = function () {\n        do_conditional_absolute_jump(!!flags.S);\n    };\n    // 0xfb : EI\n    instructions[0xfb] = function () {\n        // EI doesn't actually take effect until after the next instruction.\n        do_delayed_ei = true;\n    };\n    // 0xfc : CALL M, nn\n    instructions[0xfc] = function () {\n        do_conditional_call(!!flags.S);\n    };\n    // 0xfd : FD Prefix (IY instructions)\n    instructions[0xfd] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = dd_instructions[opcode];\n\n        if (func) {\n            // Rather than copy and paste all the IX instructions into IY instructions,\n            //  what we'll do is sneakily copy IY into IX, run the IX instruction,\n            //  and then copy the result into IY and restore the old IX.\n            var temp = ix;\n            ix = iy;\n            //func = func.bind(this);\n            func();\n            iy = ix;\n            ix = temp;\n\n            cycle_counter += cycle_counts_dd[opcode];\n        }\n        else {\n            // Apparently if an FD opcode doesn't exist,\n            //  it gets treated as an unprefixed opcode.\n            // What we'll do to handle that is just back up the\n            //  program counter, so that this byte gets decoded\n            //  as a normal instruction.\n            pc = (pc - 1) & 0xffff;\n            // And we'll add in the cycle count for a NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xfe : CP n\n    instructions[0xfe] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_cp(core.mem_read(pc));\n    };\n    // 0xff : RST 38h\n    instructions[0xff] = function () {\n        do_reset(0x38);\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// This table of ED opcodes is pretty sparse;\n    ///  there are not very many valid ED-prefixed opcodes in the Z80,\n    ///  and many of the ones that are valid are not documented.\n    ///////////////////////////////////////////////////////////////////////////////\n    let ed_instructions:any[] = [];\n    // 0x40 : IN B, (C)\n    ed_instructions[0x40] = function () {\n        b = do_in((b << 8) | c);\n    };\n    // 0x41 : OUT (C), B\n    ed_instructions[0x41] = function () {\n        core.io_write((b << 8) | c, b);\n    };\n    // 0x42 : SBC HL, BC\n    ed_instructions[0x42] = function () {\n        do_hl_sbc(c | (b << 8));\n    };\n    // 0x43 : LD (nn), BC\n    ed_instructions[0x43] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, c);\n        core.mem_write((address + 1) & 0xffff, b);\n    };\n    // 0x44 : NEG\n    ed_instructions[0x44] = function () {\n        do_neg();\n    };\n    // 0x45 : RETN\n    ed_instructions[0x45] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x46 : IM 0\n    ed_instructions[0x46] = function () {\n        imode = 0;\n    };\n    // 0x47 : LD I, A\n    ed_instructions[0x47] = function () {\n        i = a\n    };\n    // 0x48 : IN C, (C)\n    ed_instructions[0x48] = function () {\n        c = do_in((b << 8) | c);\n    };\n    // 0x49 : OUT (C), C\n    ed_instructions[0x49] = function () {\n        core.io_write((b << 8) | c, c);\n    };\n    // 0x4a : ADC HL, BC\n    ed_instructions[0x4a] = function () {\n        do_hl_adc(c | (b << 8));\n    };\n    // 0x4b : LD BC, (nn)\n    ed_instructions[0x4b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        c = core.mem_read(address);\n        b = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x4c : NEG (Undocumented)\n    ed_instructions[0x4c] = function () {\n        do_neg();\n    };\n    // 0x4d : RETI\n    ed_instructions[0x4d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n    };\n    // 0x4e : IM 0 (Undocumented)\n    ed_instructions[0x4e] = function () {\n        imode = 0;\n    };\n    // 0x4f : LD R, A\n    ed_instructions[0x4f] = function () {\n        r = a;\n    };\n    // 0x50 : IN D, (C)\n    ed_instructions[0x50] = function () {\n        d = do_in((b << 8) | c);\n    };\n    // 0x51 : OUT (C), D\n    ed_instructions[0x51] = function () {\n        core.io_write((b << 8) | c, d);\n    };\n    // 0x52 : SBC HL, DE\n    ed_instructions[0x52] = function () {\n        do_hl_sbc(e | (d << 8));\n    };\n    // 0x53 : LD (nn), DE\n    ed_instructions[0x53] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, e);\n        core.mem_write((address + 1) & 0xffff, d);\n    };\n    // 0x54 : NEG (Undocumented)\n    ed_instructions[0x54] = function () {\n        do_neg();\n    };\n    // 0x55 : RETN\n    ed_instructions[0x55] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x56 : IM 1\n    ed_instructions[0x56] = function () {\n        imode = 1;\n    };\n    // 0x57 : LD A, I\n    ed_instructions[0x57] = function () {\n        a = i;\n        flags.S = i & 0x80 ? 1 : 0;\n        flags.Z = i ? 0 : 1;\n        flags.H = 0;\n        flags.P = iff2;\n        flags.N = 0;\n    };\n    // 0x58 : IN E, (C)\n    ed_instructions[0x58] = function () {\n        e = do_in((b << 8) | c);\n    };\n    // 0x59 : OUT (C), E\n    ed_instructions[0x59] = function () {\n        core.io_write((b << 8) | c, e);\n    };\n    // 0x5a : ADC HL, DE\n    ed_instructions[0x5a] = function () {\n        do_hl_adc(e | (d << 8));\n    };\n    // 0x5b : LD DE, (nn)\n    ed_instructions[0x5b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        e = core.mem_read(address);\n        d = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x5c : NEG (Undocumented)\n    ed_instructions[0x5c] = function () {\n        do_neg();\n    };\n    // 0x5d : RETN\n    ed_instructions[0x5d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x5e : IM 2\n    ed_instructions[0x5e] = function () {\n        imode = 2;\n    };\n    // 0x5f : LD A, R\n    ed_instructions[0x5f] = function () {\n        a = r;\n        flags.P = iff2;\n    };\n    // 0x60 : IN H, (C)\n    ed_instructions[0x60] = function () {\n        h = do_in((b << 8) | c);\n    };\n    // 0x61 : OUT (C), H\n    ed_instructions[0x61] = function () {\n        core.io_write((b << 8) | c, h);\n    };\n    // 0x62 : SBC HL, HL\n    ed_instructions[0x62] = function () {\n        do_hl_sbc(l | (h << 8));\n    };\n    // 0x63 : LD (nn), HL (Undocumented)\n    ed_instructions[0x63] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, l);\n        core.mem_write((address + 1) & 0xffff, h);\n    };\n    // 0x64 : NEG (Undocumented)\n    ed_instructions[0x64] = function () {\n        do_neg();\n    };\n    // 0x65 : RETN\n    ed_instructions[0x65] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x66 : IM 0\n    ed_instructions[0x66] = function () {\n        imode = 0;\n    };\n    // 0x67 : RRD\n    ed_instructions[0x67] = function () {\n        var hl_value = core.mem_read(l | (h << 8));\n        var temp1 = hl_value & 0x0f, temp2 = a & 0x0f;\n        hl_value = ((hl_value & 0xf0) >>> 4) | (temp2 << 4);\n        a = (a & 0xf0) | temp1;\n        core.mem_write(l | (h << 8), hl_value);\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = a ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(a) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(a);\n    };\n    // 0x68 : IN L, (C)\n    ed_instructions[0x68] = function () {\n        l = do_in((b << 8) | c);\n    };\n    // 0x69 : OUT (C), L\n    ed_instructions[0x69] = function () {\n        core.io_write((b << 8) | c, l);\n    };\n    // 0x6a : ADC HL, HL\n    ed_instructions[0x6a] = function () {\n        do_hl_adc(l | (h << 8));\n    };\n    // 0x6b : LD HL, (nn) (Undocumented)\n    ed_instructions[0x6b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        l = core.mem_read(address);\n        h = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x6c : NEG (Undocumented)\n    ed_instructions[0x6c] = function () {\n        do_neg();\n    };\n    // 0x6d : RETN\n    ed_instructions[0x6d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x6e : IM 0 (Undocumented)\n    ed_instructions[0x6e] = function () {\n        imode = 0;\n    };\n    // 0x6f : RLD\n    ed_instructions[0x6f] = function () {\n        var hl_value = core.mem_read(l | (h << 8));\n        var temp1 = hl_value & 0xf0, temp2 = a & 0x0f;\n        hl_value = ((hl_value & 0x0f) << 4) | temp2;\n        a = (a & 0xf0) | (temp1 >>> 4);\n        core.mem_write(l | (h << 8), hl_value);\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = a ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(a) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(a);\n    };\n    // 0x70 : IN (C) (Undocumented)\n    ed_instructions[0x70] = function () {\n        do_in((b << 8) | c);\n    };\n    // 0x71 : OUT (C), 0 (Undocumented)\n    ed_instructions[0x71] = function () {\n        core.io_write((b << 8) | c, 0);\n    };\n    // 0x72 : SBC HL, SP\n    ed_instructions[0x72] = function () {\n        do_hl_sbc(sp);\n    };\n    // 0x73 : LD (nn), SP\n    ed_instructions[0x73] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, sp & 0xff);\n        core.mem_write((address + 1) & 0xffff, (sp >>> 8) & 0xff);\n    };\n    // 0x74 : NEG (Undocumented)\n    ed_instructions[0x74] = function () {\n        do_neg();\n    };\n    // 0x75 : RETN\n    ed_instructions[0x75] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x76 : IM 1\n    ed_instructions[0x76] = function () {\n        imode = 1;\n    };\n    // 0x78 : IN A, (C)\n    ed_instructions[0x78] = function () {\n        a = do_in((b << 8) | c);\n    };\n    // 0x79 : OUT (C), A\n    ed_instructions[0x79] = function () {\n        core.io_write((b << 8) | c, a);\n    };\n    // 0x7a : ADC HL, SP\n    ed_instructions[0x7a] = function () {\n        do_hl_adc(sp);\n    };\n    // 0x7b : LD SP, (nn)\n    ed_instructions[0x7b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        sp = core.mem_read(address);\n        sp |= core.mem_read((address + 1) & 0xffff) << 8;\n    };\n    // 0x7c : NEG (Undocumented)\n    ed_instructions[0x7c] = function () {\n        do_neg();\n    };\n    // 0x7d : RETN\n    ed_instructions[0x7d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x7e : IM 2\n    ed_instructions[0x7e] = function () {\n        imode = 2;\n    };\n    // 0xa0 : LDI\n    ed_instructions[0xa0] = function () {\n        do_ldi();\n    };\n    // 0xa1 : CPI\n    ed_instructions[0xa1] = function () {\n        do_cpi();\n    };\n    // 0xa2 : INI\n    ed_instructions[0xa2] = function () {\n        do_ini();\n    };\n    // 0xa3 : OUTI\n    ed_instructions[0xa3] = function () {\n        do_outi();\n    };\n    // 0xa8 : LDD\n    ed_instructions[0xa8] = function () {\n        do_ldd();\n    };\n    // 0xa9 : CPD\n    ed_instructions[0xa9] = function () {\n        do_cpd();\n    };\n    // 0xaa : IND\n    ed_instructions[0xaa] = function () {\n        do_ind();\n    };\n    // 0xab : OUTD\n    ed_instructions[0xab] = function () {\n        do_outd();\n    };\n    // 0xb0 : LDIR\n    ed_instructions[0xb0] = function () {\n        do_ldi();\n        if (b || c) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb1 : CPIR\n    ed_instructions[0xb1] = function () {\n        do_cpi();\n        if (!flags.Z && (b || c)) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb2 : INIR\n    ed_instructions[0xb2] = function () {\n        do_ini();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb3 : OTIR\n    ed_instructions[0xb3] = function () {\n        do_outi();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb8 : LDDR\n    ed_instructions[0xb8] = function () {\n        do_ldd();\n        if (b || c) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb9 : CPDR\n    ed_instructions[0xb9] = function () {\n        do_cpd();\n        if (!flags.Z && (b || c)) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xba : INDR\n    ed_instructions[0xba] = function () {\n        do_ind();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xbb : OTDR\n    ed_instructions[0xbb] = function () {\n        do_outd();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// Like ED, this table is quite sparse,\n    ///  and many of the opcodes here are also undocumented.\n    /// The undocumented instructions here are those that deal with only one byte\n    ///  of the two-byte IX register; the bytes are designed IXH and IXL here.\n    ///////////////////////////////////////////////////////////////////////////////\n    let dd_instructions: (() => void)[] = [];\n    // 0x09 : ADD IX, BC\n    dd_instructions[0x09] = function () {\n        do_ix_add(c | (b << 8));\n    };\n    // 0x19 : ADD IX, DE\n    dd_instructions[0x19] = function () {\n        do_ix_add(e | (d << 8));\n    };\n    // 0x21 : LD IX, nn\n    dd_instructions[0x21] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        ix |= (core.mem_read(pc) << 8);\n    };\n    // 0x22 : LD (nn), IX\n    dd_instructions[0x22] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= (core.mem_read(pc) << 8);\n\n        core.mem_write(address, ix & 0xff);\n        core.mem_write((address + 1) & 0xffff, (ix >>> 8) & 0xff);\n    };\n    // 0x23 : INC IX\n    dd_instructions[0x23] = function () {\n        ix = (ix + 1) & 0xffff;\n    };\n    // 0x24 : INC IXH (Undocumented)\n    dd_instructions[0x24] = function () {\n        ix = (do_inc(ix >>> 8) << 8) | (ix & 0xff);\n    };\n    // 0x25 : DEC IXH (Undocumented)\n    dd_instructions[0x25] = function () {\n        ix = (do_dec(ix >>> 8) << 8) | (ix & 0xff);\n    };\n    // 0x26 : LD IXH, n (Undocumented)\n    dd_instructions[0x26] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = (core.mem_read(pc) << 8) | (ix & 0xff);\n    };\n    // 0x29 : ADD IX, IX\n    dd_instructions[0x29] = function () {\n        do_ix_add(ix);\n    };\n    // 0x2a : LD IX, (nn)\n    dd_instructions[0x2a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= (core.mem_read(pc) << 8);\n\n        ix = core.mem_read(address);\n        ix |= (core.mem_read((address + 1) & 0xffff) << 8);\n    };\n    // 0x2b : DEC IX\n    dd_instructions[0x2b] = function () {\n        ix = (ix - 1) & 0xffff;\n    };\n    // 0x2c : INC IXL (Undocumented)\n    dd_instructions[0x2c] = function () {\n        ix = do_inc(ix & 0xff) | (ix & 0xff00);\n    };\n    // 0x2d : DEC IXL (Undocumented)\n    dd_instructions[0x2d] = function () {\n        ix = do_dec(ix & 0xff) | (ix & 0xff00);\n    };\n    // 0x2e : LD IXL, n (Undocumented)\n    dd_instructions[0x2e] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = (core.mem_read(pc) & 0xff) | (ix & 0xff00);\n    };\n    // 0x34 : INC (IX+n)\n    dd_instructions[0x34] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc)),\n            value = core.mem_read((offset + ix) & 0xffff);\n        core.mem_write((offset + ix) & 0xffff, do_inc(value));\n    };\n    // 0x35 : DEC (IX+n)\n    dd_instructions[0x35] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc)),\n            value = core.mem_read((offset + ix) & 0xffff);\n        core.mem_write((offset + ix) & 0xffff, do_dec(value));\n    };\n    // 0x36 : LD (IX+n), n\n    dd_instructions[0x36] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        pc = (pc + 1) & 0xffff;\n        core.mem_write((ix + offset) & 0xffff, core.mem_read(pc));\n    };\n    // 0x39 : ADD IX, SP\n    dd_instructions[0x39] = function () {\n        do_ix_add(sp);\n    };\n    // 0x44 : LD B, IXH (Undocumented)\n    dd_instructions[0x44] = function () {\n        b = (ix >>> 8) & 0xff;\n    };\n    // 0x45 : LD B, IXL (Undocumented)\n    dd_instructions[0x45] = function () {\n        b = ix & 0xff;\n    };\n    // 0x46 : LD B, (IX+n)\n    dd_instructions[0x46] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        b = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x4c : LD C, IXH (Undocumented)\n    dd_instructions[0x4c] = function () {\n        c = (ix >>> 8) & 0xff;\n    };\n    // 0x4d : LD C, IXL (Undocumented)\n    dd_instructions[0x4d] = function () {\n        c = ix & 0xff;\n    };\n    // 0x4e : LD C, (IX+n)\n    dd_instructions[0x4e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        c = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x54 : LD D, IXH (Undocumented)\n    dd_instructions[0x54] = function () {\n        d = (ix >>> 8) & 0xff;\n    };\n    // 0x55 : LD D, IXL (Undocumented)\n    dd_instructions[0x55] = function () {\n        d = ix & 0xff;\n    };\n    // 0x56 : LD D, (IX+n)\n    dd_instructions[0x56] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        d = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x5c : LD E, IXH (Undocumented)\n    dd_instructions[0x5c] = function () {\n        e = (ix >>> 8) & 0xff;\n    };\n    // 0x5d : LD E, IXL (Undocumented)\n    dd_instructions[0x5d] = function () {\n        e = ix & 0xff;\n    };\n    // 0x5e : LD E, (IX+n)\n    dd_instructions[0x5e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        e = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x60 : LD IXH, B (Undocumented)\n    dd_instructions[0x60] = function () {\n        ix = (ix & 0xff) | (b << 8);\n    };\n    // 0x61 : LD IXH, C (Undocumented)\n    dd_instructions[0x61] = function () {\n        ix = (ix & 0xff) | (c << 8);\n    };\n    // 0x62 : LD IXH, D (Undocumented)\n    dd_instructions[0x62] = function () {\n        ix = (ix & 0xff) | (d << 8);\n    };\n    // 0x63 : LD IXH, E (Undocumented)\n    dd_instructions[0x63] = function () {\n        ix = (ix & 0xff) | (e << 8);\n    };\n    // 0x64 : LD IXH, IXH (Undocumented)\n    dd_instructions[0x64] = function () {\n        // No-op.\n    };\n    // 0x65 : LD IXH, IXL (Undocumented)\n    dd_instructions[0x65] = function () {\n        ix = (ix & 0xff) | ((ix & 0xff) << 8);\n    };\n    // 0x66 : LD H, (IX+n)\n    dd_instructions[0x66] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        h = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x67 : LD IXH, A (Undocumented)\n    dd_instructions[0x67] = function () {\n        ix = (ix & 0xff) | (a << 8);\n    };\n    // 0x68 : LD IXL, B (Undocumented)\n    dd_instructions[0x68] = function () {\n        ix = (ix & 0xff00) | b;\n    };\n    // 0x69 : LD IXL, C (Undocumented)\n    dd_instructions[0x69] = function () {\n        ix = (ix & 0xff00) | c;\n    };\n    // 0x6a : LD IXL, D (Undocumented)\n    dd_instructions[0x6a] = function () {\n        ix = (ix & 0xff00) | d;\n    };\n    // 0x6b : LD IXL, E (Undocumented)\n    dd_instructions[0x6b] = function () {\n        ix = (ix & 0xff00) | e;\n    };\n    // 0x6c : LD IXL, IXH (Undocumented)\n    dd_instructions[0x6c] = function () {\n        ix = (ix & 0xff00) | (ix >>> 8);\n    };\n    // 0x6d : LD IXL, IXL (Undocumented)\n    dd_instructions[0x6d] = function () {\n        // No-op.\n    };\n    // 0x6e : LD L, (IX+n)\n    dd_instructions[0x6e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        l = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x6f : LD IXL, A (Undocumented)\n    dd_instructions[0x6f] = function () {\n        ix = (ix & 0xff00) | a;\n    };\n    // 0x70 : LD (IX+n), B\n    dd_instructions[0x70] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, b);\n    };\n    // 0x71 : LD (IX+n), C\n    dd_instructions[0x71] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, c);\n    };\n    // 0x72 : LD (IX+n), D\n    dd_instructions[0x72] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, d);\n    };\n    // 0x73 : LD (IX+n), E\n    dd_instructions[0x73] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, e);\n    };\n    // 0x74 : LD (IX+n), H\n    dd_instructions[0x74] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, h);\n    };\n    // 0x75 : LD (IX+n), L\n    dd_instructions[0x75] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, l);\n    };\n    // 0x77 : LD (IX+n), A\n    dd_instructions[0x77] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, a);\n    };\n    // 0x7c : LD A, IXH (Undocumented)\n    dd_instructions[0x7c] = function () {\n        a = (ix >>> 8) & 0xff;\n    };\n    // 0x7d : LD A, IXL (Undocumented)\n    dd_instructions[0x7d] = function () {\n        a = ix & 0xff;\n    };\n    // 0x7e : LD A, (IX+n)\n    dd_instructions[0x7e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        a = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x84 : ADD A, IXH (Undocumented)\n    dd_instructions[0x84] = function () {\n        do_add((ix >>> 8) & 0xff);\n    };\n    // 0x85 : ADD A, IXL (Undocumented)\n    dd_instructions[0x85] = function () {\n        do_add(ix & 0xff);\n    };\n    // 0x86 : ADD A, (IX+n)\n    dd_instructions[0x86] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_add(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x8c : ADC A, IXH (Undocumented)\n    dd_instructions[0x8c] = function () {\n        do_adc((ix >>> 8) & 0xff);\n    };\n    // 0x8d : ADC A, IXL (Undocumented)\n    dd_instructions[0x8d] = function () {\n        do_adc(ix & 0xff);\n    };\n    // 0x8e : ADC A, (IX+n)\n    dd_instructions[0x8e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_adc(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x94 : SUB IXH (Undocumented)\n    dd_instructions[0x94] = function () {\n        do_sub((ix >>> 8) & 0xff);\n    };\n    // 0x95 : SUB IXL (Undocumented)\n    dd_instructions[0x95] = function () {\n        do_sub(ix & 0xff);\n    };\n    // 0x96 : SUB A, (IX+n)\n    dd_instructions[0x96] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_sub(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x9c : SBC IXH (Undocumented)\n    dd_instructions[0x9c] = function () {\n        do_sbc((ix >>> 8) & 0xff);\n    };\n    // 0x9d : SBC IXL (Undocumented)\n    dd_instructions[0x9d] = function () {\n        do_sbc(ix & 0xff);\n    };\n    // 0x9e : SBC A, (IX+n)\n    dd_instructions[0x9e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_sbc(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xa4 : AND IXH (Undocumented)\n    dd_instructions[0xa4] = function () {\n        do_and((ix >>> 8) & 0xff);\n    };\n    // 0xa5 : AND IXL (Undocumented)\n    dd_instructions[0xa5] = function () {\n        do_and(ix & 0xff);\n    };\n    // 0xa6 : AND A, (IX+n)\n    dd_instructions[0xa6] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_and(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xac : XOR IXH (Undocumented)\n    dd_instructions[0xac] = function () {\n        do_xor((ix >>> 8) & 0xff);\n    };\n    // 0xad : XOR IXL (Undocumented)\n    dd_instructions[0xad] = function () {\n        do_xor(ix & 0xff);\n    };\n    // 0xae : XOR A, (IX+n)\n    dd_instructions[0xae] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_xor(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xb4 : OR IXH (Undocumented)\n    dd_instructions[0xb4] = function () {\n        do_or((ix >>> 8) & 0xff);\n    };\n    // 0xb5 : OR IXL (Undocumented)\n    dd_instructions[0xb5] = function () {\n        do_or(ix & 0xff);\n    };\n    // 0xb6 : OR A, (IX+n)\n    dd_instructions[0xb6] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_or(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xbc : CP IXH (Undocumented)\n    dd_instructions[0xbc] = function () {\n        do_cp((ix >>> 8) & 0xff);\n    };\n    // 0xbd : CP IXL (Undocumented)\n    dd_instructions[0xbd] = function () {\n        do_cp(ix & 0xff);\n    };\n    // 0xbe : CP A, (IX+n)\n    dd_instructions[0xbe] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_cp(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xcb : CB Prefix (IX bit instructions)\n    dd_instructions[0xcb] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc), value;\n\n        // As with the \"normal\" CB prefix, we implement the DDCB prefix\n        //  by decoding the opcode directly, rather than using a table.\n        if (opcode < 0x40) {\n            // Shift and rotate instructions.\n            var ddcb_functions = [do_rlc, do_rrc, do_rl, do_rr,\n                do_sla, do_sra, do_sll, do_srl];\n\n            // Most of the opcodes in this range are not valid,\n            //  so we map this opcode onto one of the ones that is.\n            var func = ddcb_functions[(opcode & 0x38) >>> 3];\n            value = func(core.mem_read((ix + offset) & 0xffff));\n\n            core.mem_write((ix + offset) & 0xffff, value);\n        }\n        else {\n            var bit_number = (opcode & 0x38) >>> 3;\n\n            if (opcode < 0x80) {\n                // BIT\n                flags.N = 0;\n                flags.H = 1;\n                flags.Z = !(core.mem_read((ix + offset) & 0xffff) & (1 << bit_number)) ? 1 : 0;\n                flags.P = flags.Z;\n                flags.S = ((bit_number === 7) && !flags.Z) ? 1 : 0;\n            }\n            else if (opcode < 0xc0) {\n                // RES\n                value = core.mem_read((ix + offset) & 0xffff) & ~(1 << bit_number) & 0xff;\n                core.mem_write((ix + offset) & 0xffff, value);\n            }\n            else {\n                // SET\n                value = core.mem_read((ix + offset) & 0xffff) | (1 << bit_number);\n                core.mem_write((ix + offset) & 0xffff, value);\n            }\n        }\n\n        // This implements the undocumented shift, RES, and SET opcodes,\n        //  which write their result to memory and also to an 8080 register.\n        if (value !== undefined) {\n            if ((opcode & 0x07) === 0)\n                b = value;\n            else if ((opcode & 0x07) === 1)\n                c = value;\n            else if ((opcode & 0x07) === 2)\n                d = value;\n            else if ((opcode & 0x07) === 3)\n                e = value;\n            else if ((opcode & 0x07) === 4)\n                h = value;\n            else if ((opcode & 0x07) === 5)\n                l = value;\n            // 6 is the documented opcode, which doesn't set a register.\n            else if ((opcode & 0x07) === 7)\n                a = value;\n        }\n\n        cycle_counter += cycle_counts_cb[opcode] + 8;\n    };\n    // 0xe1 : POP IX\n    dd_instructions[0xe1] = function () {\n        ix = pop_word();\n    };\n    // 0xe3 : EX (SP), IX\n    dd_instructions[0xe3] = function () {\n        var temp = ix;\n        ix = core.mem_read(sp);\n        ix |= core.mem_read((sp + 1) & 0xffff) << 8;\n        core.mem_write(sp, temp & 0xff);\n        core.mem_write((sp + 1) & 0xffff, (temp >>> 8) & 0xff);\n    };\n    // 0xe5 : PUSH IX\n    dd_instructions[0xe5] = function () {\n        push_word(ix);\n    };\n    // 0xe9 : JP (IX)\n    dd_instructions[0xe9] = function () {\n        pc = (ix - 1) & 0xffff;\n    };\n    // 0xf9 : LD SP, IX\n    dd_instructions[0xf9] = function () {\n        sp = ix;\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// These tables contain the number of T cycles used for each instruction.\n    /// In a few special cases, such as conditional control flow instructions,\n    ///  additional cycles might be added to these values.\n    /// The total number of cycles is the return value of run_instruction().\n    ///////////////////////////////////////////////////////////////////////////////\n    let cycle_counts = [\n        4, 10, 7, 6, 4, 4, 7, 4, 4, 11, 7, 6, 4, 4, 7, 4,\n        8, 10, 7, 6, 4, 4, 7, 4, 12, 11, 7, 6, 4, 4, 7, 4,\n        7, 10, 16, 6, 4, 4, 7, 4, 7, 11, 16, 6, 4, 4, 7, 4,\n        7, 10, 13, 6, 11, 11, 10, 4, 7, 11, 13, 6, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        7, 7, 7, 7, 7, 7, 4, 7, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        5, 10, 10, 10, 10, 11, 7, 11, 5, 10, 10, 0, 10, 17, 7, 11,\n        5, 10, 10, 11, 10, 11, 7, 11, 5, 4, 10, 11, 10, 0, 7, 11,\n        5, 10, 10, 19, 10, 11, 7, 11, 5, 4, 10, 4, 10, 0, 7, 11,\n        5, 10, 10, 4, 10, 11, 7, 11, 5, 6, 10, 4, 10, 0, 7, 11\n    ];\n\n    let cycle_counts_ed = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,\n        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,\n        12, 12, 15, 20, 8, 14, 8, 18, 12, 12, 15, 20, 8, 14, 8, 18,\n        12, 12, 15, 20, 8, 14, 8, 0, 12, 12, 15, 20, 8, 14, 8, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,\n        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n\n    let cycle_counts_cb = [\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8\n    ];\n\n    let cycle_counts_dd = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 14, 20, 10, 8, 8, 11, 0, 0, 15, 20, 10, 8, 8, 11, 0,\n        0, 0, 0, 0, 23, 23, 19, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        8, 8, 8, 8, 8, 8, 19, 8, 8, 8, 8, 8, 8, 8, 19, 8,\n        19, 19, 19, 19, 19, 19, 0, 19, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 14, 0, 23, 0, 15, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0\n    ];\n\n    // There's tons of stuff in this object,\n    //  but only these three functions are the public API.\n    return {\n        getState,\n        setState,\n        reset,\n        reset1,\n        run_instruction,\n        interrupt,\n    };\n}","\n/**\n * Parser/writer for the \"Intel hex\" format.\n */\n\n/*\n * A regexp that matches lines in a .hex file.\n *\n * One hexadecimal character is matched by \"[0-9A-Fa-f]\".\n * Two hex characters are matched by \"[0-9A-Fa-f]{2}\"\n * Eight or more hex characters are matched by \"[0-9A-Fa-f]{8,}\"\n * A capture group of two hex characters is \"([0-9A-Fa-f]{2})\"\n *\n * Record mark         :\n * 8 or more hex chars  ([0-9A-Fa-f]{8,})\n * Checksum                              ([0-9A-Fa-f]{2})\n * Optional newline                                      (?:\\r\\n|\\r|\\n|)\n */\nconst hexLineRegexp = /:([0-9A-Fa-f]{8,})([0-9A-Fa-f]{2})(?:\\r\\n|\\r|\\n|)/g;\n\n\n// Takes a Uint8Array as input,\n// Returns an integer in the 0-255 range.\nfunction checksum(bytes) {\n    return (-bytes.reduce((sum, v)=>sum + v, 0)) & 0xFF;\n}\n\n// Takes two Uint8Arrays as input,\n// Returns an integer in the 0-255 range.\nfunction checksumTwo(array1, array2) {\n    const partial1 = array1.reduce((sum, v)=>sum + v, 0);\n    const partial2 = array2.reduce((sum, v)=>sum + v, 0);\n    return -( partial1 + partial2 ) & 0xFF;\n}\n\n\n// Trivial utility. Converts a number to hex and pads with zeroes up to 2 characters.\nfunction hexpad(number) {\n    return number.toString(16).toUpperCase().padStart(2, '0');\n}\n\n\n// Polyfill as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\nNumber.isInteger = Number.isInteger || function(value) {\n    return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\n/**\n * @class MemoryMap\n *\n * Represents the contents of a memory layout, with main focus into (possibly sparse) blocks of data.\n *<br/>\n * A {@linkcode MemoryMap} acts as a subclass of\n * {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|Map}.\n * In every entry of it, the key is the starting address of a data block (an integer number),\n * and the value is the <tt>Uint8Array</tt> with the data for that block.\n *<br/>\n * The main rationale for this is that a .hex file can contain a single block of contiguous\n * data starting at memory address 0 (and it's the common case for simple .hex files),\n * but complex files with several non-contiguous data blocks are also possible, thus\n * the need for a data structure on top of the <tt>Uint8Array</tt>s.\n *<br/>\n * In order to parse <tt>.hex</tt> files, use the {@linkcode MemoryMap.fromHex} <em>static</em> factory\n * method. In order to write <tt>.hex</tt> files, create a new {@linkcode MemoryMap} and call\n * its {@linkcode MemoryMap.asHexString} method.\n *\n * @extends Map\n * @example\n * import MemoryMap from 'nrf-intel-hex';\n *\n * let memMap1 = new MemoryMap();\n * let memMap2 = new MemoryMap([[0, new Uint8Array(1,2,3,4)]]);\n * let memMap3 = new MemoryMap({0: new Uint8Array(1,2,3,4)});\n * let memMap4 = new MemoryMap({0xCF0: new Uint8Array(1,2,3,4)});\n */\nclass MemoryMap {\n    /**\n     * @param {Iterable} blocks The initial value for the memory blocks inside this\n     * <tt>MemoryMap</tt>. All keys must be numeric, and all values must be instances of\n     * <tt>Uint8Array</tt>. Optionally it can also be a plain <tt>Object</tt> with\n     * only numeric keys.\n     */\n    constructor(blocks) {\n        this._blocks = new Map();\n\n        if (blocks && typeof blocks[Symbol.iterator] === 'function') {\n            for (const tuple of blocks) {\n                if (!(tuple instanceof Array) || tuple.length !== 2) {\n                    throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n                }\n                this.set(tuple[0], tuple[1]);\n            }\n        } else if (typeof blocks === 'object') {\n            // Try iterating through the object's keys\n            const addrs = Object.keys(blocks);\n            for (const addr of addrs) {\n                this.set(parseInt(addr), blocks[addr]);\n            }\n\n        } else if (blocks !== undefined && blocks !== null) {\n            throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n        }\n    }\n\n    set(addr, value) {\n        if (!Number.isInteger(addr)) {\n            throw new Error('Address passed to MemoryMap is not an integer');\n        }\n        if (addr < 0) {\n            throw new Error('Address passed to MemoryMap is negative');\n        }\n        if (!(value instanceof Uint8Array)) {\n            throw new Error('Bytes passed to MemoryMap are not an Uint8Array');\n        }\n        return this._blocks.set(addr, value);\n    }\n    // Delegate the following to the 'this._blocks' Map:\n    get(addr)    { return this._blocks.get(addr);    }\n    clear()      { return this._blocks.clear();      }\n    delete(addr) { return this._blocks.delete(addr); }\n    entries()    { return this._blocks.entries();    }\n    forEach(callback, that) { return this._blocks.forEach(callback, that); }\n    has(addr)    { return this._blocks.has(addr);    }\n    keys()       { return this._blocks.keys();       }\n    values()     { return this._blocks.values();     }\n    get size()   { return this._blocks.size;         }\n    [Symbol.iterator]() { return this._blocks[Symbol.iterator](); }\n\n\n    /**\n     * Parses a string containing data formatted in \"Intel HEX\" format, and\n     * returns an instance of {@linkcode MemoryMap}.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * The parser has an opinionated behaviour, and will throw a descriptive error if it\n     * encounters some malformed input. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, any contiguous data block larger than that will\n     * be split in several blocks.\n     *\n     * @param {String} hexText The contents of a .hex file.\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the returned <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let intelHexString =\n     *     \":100000000102030405060708090A0B0C0D0E0F1068\\n\" +\n     *     \":00000001FF\";\n     *\n     * let memMap = MemoryMap.fromHex(intelHexString);\n     *\n     * for (let [address, dataBlock] of memMap) {\n     *     console.log('Data block at ', address, ', bytes: ', dataBlock);\n     * }\n     */\n    static fromHex(hexText, maxBlockSize = Infinity) {\n        const blocks = new MemoryMap();\n\n        let lastCharacterParsed = 0;\n        let matchResult;\n        let recordCount = 0;\n\n        // Upper Linear Base Address, the 16 most significant bits (2 bytes) of\n        // the current 32-bit (4-byte) address\n        // In practice this is a offset that is summed to the \"load offset\" of the\n        // data records\n        let ulba = 0;\n\n        hexLineRegexp.lastIndex = 0; // Reset the regexp, if not it would skip content when called twice\n\n        while ((matchResult = hexLineRegexp.exec(hexText)) !== null) {\n            recordCount++;\n\n            // By default, a regexp loop ignores gaps between matches, but\n            // we want to be aware of them.\n            if (lastCharacterParsed !== matchResult.index) {\n                throw new Error(\n                    'Malformed hex file: Could not parse between characters ' +\n                    lastCharacterParsed +\n                    ' and ' +\n                    matchResult.index +\n                    ' (\"' +\n                    hexText.substring(lastCharacterParsed, Math.min(matchResult.index, lastCharacterParsed + 16)).trim() +\n                    '\")');\n            }\n            lastCharacterParsed = hexLineRegexp.lastIndex;\n\n            // Give pretty names to the match's capture groups\n            const [, recordStr, recordChecksum] = matchResult;\n\n            // String to Uint8Array - https://stackoverflow.com/questions/43131242/how-to-convert-a-hexademical-string-of-data-to-an-arraybuffer-in-javascript\n            const recordBytes = new Uint8Array(recordStr.match(/[\\da-f]{2}/gi).map((h)=>parseInt(h, 16)));\n\n            const recordLength = recordBytes[0];\n            if (recordLength + 4 !== recordBytes.length) {\n                throw new Error('Mismatched record length at record ' + recordCount + ' (' + matchResult[0].trim() + '), expected ' + (recordLength) + ' data bytes but actual length is ' + (recordBytes.length - 4));\n            }\n\n            const cs = checksum(recordBytes);\n            if (parseInt(recordChecksum, 16) !== cs) {\n                throw new Error('Checksum failed at record ' + recordCount + ' (' + matchResult[0].trim() + '), should be ' + cs.toString(16) );\n            }\n\n            const offset = (recordBytes[1] << 8) + recordBytes[2];\n            const recordType = recordBytes[3];\n            const data = recordBytes.subarray(4);\n\n            if (recordType === 0) {\n                // Data record, contains data\n                // Create a new block, at (upper linear base address + offset)\n                if (blocks.has(ulba + offset)) {\n                    throw new Error('Duplicated data at record ' + recordCount + ' (' + matchResult[0].trim() + ')');\n                }\n                if (offset + data.length > 0x10000) {\n                    throw new Error(\n                        'Data at record ' +\n                        recordCount +\n                        ' (' +\n                        matchResult[0].trim() +\n                        ') wraps over 0xFFFF. This would trigger ambiguous behaviour. Please restructure your data so that for every record the data offset plus the data length do not exceed 0xFFFF.');\n                }\n\n                blocks.set( ulba + offset, data );\n\n            } else {\n\n                // All non-data records must have a data offset of zero\n                if (offset !== 0) {\n                    throw new Error('Record ' + recordCount + ' (' + matchResult[0].trim() + ') must have 0000 as data offset.');\n                }\n\n                switch (recordType) {\n                case 1: // EOF\n                    if (lastCharacterParsed !== hexText.length) {\n                        // This record should be at the very end of the string\n                        throw new Error('There is data after an EOF record at record ' + recordCount);\n                    }\n\n                    return blocks.join(maxBlockSize);\n\n                case 2: // Extended Segment Address Record\n                    // Sets the 16 most significant bits of the 20-bit Segment Base\n                    // Address for the subsequent data.\n                    ulba = ((data[0] << 8) + data[1]) << 4;\n                    break;\n\n                case 3: // Start Segment Address Record\n                    // Do nothing. Record type 3 only applies to 16-bit Intel CPUs,\n                    // where it should reset the program counter (CS+IP CPU registers)\n                    break;\n\n                case 4: // Extended Linear Address Record\n                    // Sets the 16 most significant (upper) bits of the 32-bit Linear Address\n                    // for the subsequent data\n                    ulba = ((data[0] << 8) + data[1]) << 16;\n                    break;\n\n                case 5: // Start Linear Address Record\n                    // Do nothing. Record type 5 only applies to 32-bit Intel CPUs,\n                    // where it should reset the program counter (EIP CPU register)\n                    // It might have meaning for other CPU architectures\n                    // (see http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka9903.html )\n                    // but will be ignored nonetheless.\n                    break;\n                default:\n                    throw new Error('Invalid record type 0x' + hexpad(recordType) + ' at record ' + recordCount + ' (should be between 0x00 and 0x05)');\n                }\n            }\n        }\n\n        if (recordCount) {\n            throw new Error('No EOF record at end of file');\n        } else {\n            throw new Error('Malformed .hex file, could not parse any registers');\n        }\n    }\n\n\n    /**\n     * Returns a <strong>new</strong> instance of {@linkcode MemoryMap}, containing\n     * the same data, but concatenating together those memory blocks that are adjacent.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, blocks will be concatenated together only\n     * until the joined block reaches this size in bytes. This means that the output\n     * {@linkcode MemoryMap} might have more entries than the input one.\n     *<br/>\n     * If there is any overlap between blocks, an error will be thrown.\n     *<br/>\n     * The returned {@linkcode MemoryMap} will use newly allocated memory.\n     *\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the <tt>Uint8Array</tt>s in the\n     * returned {@linkcode MemoryMap}.\n     *\n     * @return {MemoryMap}\n     */\n    join(maxBlockSize = Infinity) {\n\n        // First pass, create a Map of address→length of contiguous blocks\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        const blockSizes = new Map();\n        let lastBlockAddr = -1;\n        let lastBlockEndAddr = -1;\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const blockLength = this.get(sortedKeys[i]).length;\n\n            if (lastBlockEndAddr === blockAddr && (lastBlockEndAddr - lastBlockAddr) < maxBlockSize) {\n                // Grow when the previous end address equals the current,\n                // and we don't go over the maximum block size.\n                blockSizes.set(lastBlockAddr, blockSizes.get(lastBlockAddr) + blockLength);\n                lastBlockEndAddr += blockLength;\n            } else if (lastBlockEndAddr <= blockAddr) {\n                // Else mark a new block.\n                blockSizes.set(blockAddr, blockLength);\n                lastBlockAddr = blockAddr;\n                lastBlockEndAddr = blockAddr + blockLength;\n            } else {\n                throw new Error('Overlapping data around address 0x' + blockAddr.toString(16));\n            }\n        }\n\n        // Second pass: allocate memory for the contiguous blocks and copy data around.\n        const mergedBlocks = new MemoryMap();\n        let mergingBlock;\n        let mergingBlockAddr = -1;\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            if (blockSizes.has(blockAddr)) {\n                mergingBlock = new Uint8Array(blockSizes.get(blockAddr));\n                mergedBlocks.set(blockAddr, mergingBlock);\n                mergingBlockAddr = blockAddr;\n            }\n            mergingBlock.set(this.get(blockAddr), blockAddr - mergingBlockAddr);\n        }\n\n        return mergedBlocks;\n    }\n\n    /**\n     * Given a {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|<tt>Map</tt>}\n     * of {@linkcode MemoryMap}s, indexed by a alphanumeric ID,\n     * returns a <tt>Map</tt> of address to tuples (<tt>Arrays</tt>s of length 2) of the form\n     * <tt>(id, Uint8Array)</tt>s.\n     *<br/>\n     * The scenario for using this is having several {@linkcode MemoryMap}s, from several calls to\n     * {@link module:nrf-intel-hex~hexToArrays|hexToArrays}, each having a different identifier.\n     * This function locates where those memory block sets overlap, and returns a <tt>Map</tt>\n     * containing addresses as keys, and arrays as values. Each array will contain 1 or more\n     * <tt>(id, Uint8Array)</tt> tuples: the identifier of the memory block set that has\n     * data in that region, and the data itself. When memory block sets overlap, there will\n     * be more than one tuple.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output are\n     * {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray|subarrays}\n     * of the input data; new memory is <strong>not</strong> allocated for them.\n     *<br/>\n     * The insertion order of keys in the output <tt>Map</tt> is guaranteed to be strictly\n     * ascending. In other words, when iterating through the <tt>Map</tt>, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * When two blocks overlap, the corresponding array of tuples will have the tuples ordered\n     * in the insertion order of the input <tt>Map</tt> of block sets.\n     *<br/>\n     *\n     * @param {Map.MemoryMap} memoryMaps The input memory block sets\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap1 = MemoryMap.fromHex( hexdata1 );\n     * let memMap2 = MemoryMap.fromHex( hexdata2 );\n     * let memMap3 = MemoryMap.fromHex( hexdata3 );\n     *\n     * let maps = new Map([\n     *  ['file A', blocks1],\n     *  ['file B', blocks2],\n     *  ['file C', blocks3]\n     * ]);\n     *\n     * let overlappings = MemoryMap.overlapMemoryMaps(maps);\n     *\n     * for (let [address, tuples] of overlappings) {\n     *     // if 'tuples' has length > 1, there is an overlap starting at 'address'\n     *\n     *     for (let [address, tuples] of overlappings) {\n     *         let [id, bytes] = tuple;\n     *         // 'id' in this example is either 'file A', 'file B' or 'file C'\n     *     }\n     * }\n     * @return {Map.Array<mixed,Uint8Array>} The map of possibly overlapping memory blocks\n     */\n    static overlapMemoryMaps(memoryMaps) {\n        // First pass: create a list of addresses where any block starts or ends.\n        const cuts = new Set();\n        for (const [, blocks] of memoryMaps) {\n            for (const [address, block] of blocks) {\n                cuts.add(address);\n                cuts.add(address + block.length);\n            }\n        }\n\n        const orderedCuts = Array.from(cuts.values()).sort((a,b)=>a-b);\n        const overlaps = new Map();\n\n        // Second pass: iterate through the cuts, get slices of every intersecting blockset\n        for (let i=0, l=orderedCuts.length-1; i<l; i++) {\n            const cut = orderedCuts[i];\n            const nextCut = orderedCuts[i+1];\n            const tuples = [];\n\n            for (const [setId, blocks] of memoryMaps) {\n                // Find the block with the highest address that is equal or lower to\n                // the current cut (if any)\n                const blockAddr = Array.from(blocks.keys()).reduce((acc, val)=>{\n                    if (val > cut) {\n                        return acc;\n                    }\n                    return Math.max( acc, val );\n                }, -1);\n\n                if (blockAddr !== -1) {\n                    const block = blocks.get(blockAddr);\n                    const subBlockStart = cut - blockAddr;\n                    const subBlockEnd = nextCut - blockAddr;\n\n                    if (subBlockStart < block.length) {\n                        tuples.push([ setId, block.subarray(subBlockStart, subBlockEnd) ]);\n                    }\n                }\n            }\n\n            if (tuples.length) {\n                overlaps.set(cut, tuples);\n            }\n        }\n\n        return overlaps;\n    }\n\n\n    /**\n     * Given the output of the {@linkcode MemoryMap.overlapMemoryMaps|overlapMemoryMaps}\n     * (a <tt>Map</tt> of address to an <tt>Array</tt> of <tt>(id, Uint8Array)</tt> tuples),\n     * returns a {@linkcode MemoryMap}. This discards the IDs in the process.\n     *<br/>\n     * The output <tt>Map</tt> contains as many entries as the input one (using the same addresses\n     * as keys), but the value for each entry will be the <tt>Uint8Array</tt> of the <b>last</b>\n     * tuple for each address in the input data.\n     *<br/>\n     * The scenario is wanting to join together several parsed .hex files, not worrying about\n     * their overlaps.\n     *<br/>\n     *\n     * @param {Map.Array<mixed,Uint8Array>} overlaps The (possibly overlapping) input memory blocks\n     * @return {MemoryMap} The flattened memory blocks\n     */\n    static flattenOverlaps(overlaps) {\n        return new MemoryMap(\n            Array.from(overlaps.entries()).map(([address, tuples]) => {\n                return [address, tuples[tuples.length - 1][1] ];\n            })\n        );\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, where:\n     *\n     * <ul>\n     *  <li>Each key (the start address of each <tt>Uint8Array</tt>) is a multiple of\n     *    <tt>pageSize</tt></li>\n     *  <li>The size of each <tt>Uint8Array</tt> is exactly <tt>pageSize</tt></li>\n     *  <li>Bytes from the input map to bytes in the output</li>\n     *  <li>Bytes not in the input are replaced by a padding value</li>\n     * </ul>\n     *<br/>\n     * The scenario is wanting to prepare pages of bytes for a write operation, where the write\n     * operation affects a whole page/sector at once.\n     *<br/>\n     * The insertion order of keys in the output {@linkcode MemoryMap} is guaranteed\n     * to be strictly ascending. In other words, when iterating through the\n     * {@linkcode MemoryMap}, the addresses will be ordered in ascending order.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output will be newly allocated.\n     *<br/>\n     *\n     * @param {Number} [pageSize=1024] The size of the output pages, in bytes\n     * @param {Number} [pad=0xFF] The byte value to use for padding\n     * @return {MemoryMap}\n     */\n    paginate( pageSize=1024, pad=0xFF) {\n        if (pageSize <= 0) {\n            throw new Error('Page size must be greater than zero');\n        }\n        const outPages = new MemoryMap();\n        let page;\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            for (let pageAddr = blockAddr - (blockAddr % pageSize); pageAddr < blockEnd; pageAddr += pageSize) {\n                page = outPages.get(pageAddr);\n                if (!page) {\n                    page = new Uint8Array(pageSize);\n                    page.fill(pad);\n                    outPages.set(pageAddr, page);\n                }\n\n                const offset = pageAddr - blockAddr;\n                let subBlock;\n                if (offset <= 0) {\n                    // First page which intersects the block\n                    subBlock = block.subarray(0, Math.min(pageSize + offset, blockLength));\n                    page.set(subBlock, -offset);\n                } else {\n                    // Any other page which intersects the block\n                    subBlock = block.subarray(offset, offset + Math.min(pageSize, blockLength - offset));\n                    page.set(subBlock, 0);\n                }\n            }\n        }\n\n        return outPages;\n    }\n\n\n    /**\n     * Locates the <tt>Uint8Array</tt> which contains the given offset,\n     * and returns the four bytes held at that offset, as a 32-bit unsigned integer.\n     *\n     *<br/>\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|DataView.prototype.getUint32},\n     * except that this operates over a {@linkcode MemoryMap} instead of\n     * over an <tt>ArrayBuffer</tt>, and that this may return <tt>undefined</tt> if\n     * the address is not <em>entirely</em> contained within one of the <tt>Uint8Array</tt>s.\n     *<br/>\n     *\n     * @param {Number} offset The memory offset to read the data\n     * @param {Boolean} [littleEndian=false] Whether to fetch the 4 bytes as a little- or big-endian integer\n     * @return {Number|undefined} An unsigned 32-bit integer number\n     */\n    getUint32(offset, littleEndian) {\n        const keys = Array.from(this.keys());\n\n        for (let i=0,l=keys.length; i<l; i++) {\n            const blockAddr = keys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            if (blockAddr <= offset && (offset+4) <= blockEnd) {\n                return (new DataView(block.buffer, offset - blockAddr, 4)).getUint32(0, littleEndian);\n            }\n        }\n        return;\n    }\n\n\n    /**\n     * Returns a <tt>String</tt> of text representing a .hex file.\n     * <br/>\n     * The writer has an opinionated behaviour. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *\n     * @param {Number} [lineSize=16] Maximum number of bytes to be encoded in each data record.\n     * Must have a value between 1 and 255, as per the specification.\n     *\n     * @return {String} String of text with the .hex representation of the input binary data\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap = new MemoryMap();\n     * let bytes = new Uint8Array(....);\n     * memMap.set(0x0FF80000, bytes); // The block with 'bytes' will start at offset 0x0FF80000\n     *\n     * let string = memMap.asHexString();\n     */\n    asHexString(lineSize = 16) {\n        let lowAddress  = 0;    // 16 least significant bits of the current addr\n        let highAddress = -1 << 16; // 16 most significant bits of the current addr\n        const records = [];\n        if (lineSize <=0) {\n            throw new Error('Size of record must be greater than zero');\n        } else if (lineSize > 255) {\n            throw new Error('Size of record must be less than 256');\n        }\n\n        // Placeholders\n        const offsetRecord = new Uint8Array(6);\n        const recordHeader = new Uint8Array(4);\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n\n            // Sanity checks\n            if (!(block instanceof Uint8Array)) {\n                throw new Error('Block at offset ' + blockAddr + ' is not an Uint8Array');\n            }\n            if (blockAddr < 0) {\n                throw new Error('Block at offset ' + blockAddr + ' has a negative thus invalid address');\n            }\n            const blockSize = block.length;\n            if (!blockSize) { continue; }   // Skip zero-length blocks\n\n\n            if (blockAddr > (highAddress + 0xFFFF)) {\n                // Insert a new 0x04 record to jump to a new 64KiB block\n\n                // Round up the least significant 16 bits - no bitmasks because they trigger\n                // base-2 negative numbers, whereas subtracting the modulo maintains precision\n                highAddress = blockAddr - blockAddr % 0x10000;\n                lowAddress = 0;\n\n                offsetRecord[0] = 2;    // Length\n                offsetRecord[1] = 0;    // Load offset, high byte\n                offsetRecord[2] = 0;    // Load offset, low byte\n                offsetRecord[3] = 4;    // Record type\n                offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                records.push(\n                    ':' +\n                    Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                    hexpad(checksum(offsetRecord))\n                );\n            }\n\n            if (blockAddr < (highAddress + lowAddress)) {\n                throw new Error(\n                    'Block starting at 0x' +\n                    blockAddr.toString(16) +\n                    ' overlaps with a previous block.');\n            }\n\n            lowAddress = blockAddr % 0x10000;\n            let blockOffset = 0;\n            const blockEnd = blockAddr + blockSize;\n            if (blockEnd > 0xFFFFFFFF) {\n                throw new Error('Data cannot be over 0xFFFFFFFF');\n            }\n\n            // Loop for every 64KiB memory segment that spans this block\n            while (highAddress + lowAddress < blockEnd) {\n\n                if (lowAddress > 0xFFFF) {\n                    // Insert a new 0x04 record to jump to a new 64KiB block\n                    highAddress += 1 << 16; // Increase by one\n                    lowAddress = 0;\n\n                    offsetRecord[0] = 2;    // Length\n                    offsetRecord[1] = 0;    // Load offset, high byte\n                    offsetRecord[2] = 0;    // Load offset, low byte\n                    offsetRecord[3] = 4;    // Record type\n                    offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                    offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                    records.push(\n                        ':' +\n                        Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                        hexpad(checksum(offsetRecord))\n                    );\n                }\n\n                let recordSize = -1;\n                // Loop for every record for that spans the current 64KiB memory segment\n                while (lowAddress < 0x10000 && recordSize) {\n                    recordSize = Math.min(\n                        lineSize,                            // Normal case\n                        blockEnd - highAddress - lowAddress, // End of block\n                        0x10000 - lowAddress                 // End of low addresses\n                    );\n\n                    if (recordSize) {\n\n                        recordHeader[0] = recordSize;   // Length\n                        recordHeader[1] = lowAddress >> 8;    // Load offset, high byte\n                        recordHeader[2] = lowAddress;    // Load offset, low byte\n                        recordHeader[3] = 0;    // Record type\n\n                        const subBlock = block.subarray(blockOffset, blockOffset + recordSize);   // Data bytes for this record\n\n                        records.push(\n                            ':' +\n                            Array.prototype.map.call(recordHeader, hexpad).join('') +\n                            Array.prototype.map.call(subBlock, hexpad).join('') +\n                            hexpad(checksumTwo(recordHeader, subBlock))\n                        );\n\n                        blockOffset += recordSize;\n                        lowAddress += recordSize;\n                    }\n                }\n            }\n        }\n\n        records.push(':00000001FF');    // EOF record\n\n        return records.join('\\n');\n    }\n\n\n    /**\n     * Performs a deep copy of the current {@linkcode MemoryMap}, returning a new one\n     * with exactly the same contents, but allocating new memory for each of its\n     * <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     */\n    clone() {\n        const cloned = new MemoryMap();\n\n        for (let [addr, value] of this) {\n            cloned.set(addr, new Uint8Array(value));\n        }\n\n        return cloned;\n    }\n\n\n    /**\n     * Given one <tt>Uint8Array</tt>, looks through its contents and returns a new\n     * {@linkcode MemoryMap}, stripping away those regions where there are only\n     * padding bytes.\n     * <br/>\n     * The start of the input <tt>Uint8Array</tt> is assumed to be offset zero for the output.\n     * <br/>\n     * The use case here is dumping memory from a working device and try to see the\n     * \"interesting\" memory regions it has. This assumes that there is a constant,\n     * predefined padding byte value being used in the \"non-interesting\" regions.\n     * In other words: this will work as long as the dump comes from a flash memory\n     * which has been previously erased (thus <tt>0xFF</tt>s for padding), or from a\n     * previously blanked HDD (thus <tt>0x00</tt>s for padding).\n     * <br/>\n     * This method uses <tt>subarray</tt> on the input data, and thus does not allocate memory\n     * for the <tt>Uint8Array</tt>s.\n     *\n     * @param {Uint8Array} bytes The input data\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @param {Number} [minPadLength=64] The minimum number of consecutive pad bytes to\n     * be considered actual padding\n     *\n     * @return {MemoryMap}\n     */\n    static fromPaddedUint8Array(bytes, padByte=0xFF, minPadLength=64) {\n\n        if (!(bytes instanceof Uint8Array)) {\n            throw new Error('Bytes passed to fromPaddedUint8Array are not an Uint8Array');\n        }\n\n        // The algorithm used is naïve and checks every byte.\n        // An obvious optimization would be to implement Boyer-Moore\n        // (see https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm )\n        // or otherwise start skipping up to minPadLength bytes when going through a non-pad\n        // byte.\n        // Anyway, we could expect a lot of cases where there is a majority of pad bytes,\n        // and the algorithm should check most of them anyway, so the perf gain is questionable.\n\n        const memMap = new MemoryMap();\n        let consecutivePads = 0;\n        let lastNonPad = -1;\n        let firstNonPad = 0;\n        let skippingBytes = false;\n        const l = bytes.length;\n\n        for (let addr = 0; addr < l; addr++) {\n            const byte = bytes[addr];\n\n            if (byte === padByte) {\n                consecutivePads++;\n                if (consecutivePads >= minPadLength) {\n                    // Edge case: ignore writing a zero-length block when skipping\n                    // bytes at the beginning of the input\n                    if (lastNonPad !== -1) {\n                        /// Add the previous block to the result memMap\n                        memMap.set(firstNonPad, bytes.subarray(firstNonPad, lastNonPad+1));\n                    }\n\n                    skippingBytes = true;\n                }\n            } else {\n                if (skippingBytes) {\n                    skippingBytes = false;\n                    firstNonPad = addr;\n                }\n                lastNonPad = addr;\n                consecutivePads = 0;\n            }\n        }\n\n        // At EOF, add the last block if not skipping bytes already (and input not empty)\n        if (!skippingBytes && lastNonPad !== -1) {\n            memMap.set(firstNonPad, bytes.subarray(firstNonPad, l));\n        }\n\n        return memMap;\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>.\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice|Array.prototype.slice},\n     * in that the return value is a portion of the current {@linkcode MemoryMap}.\n     *\n     * <br/>\n     * The returned {@linkcode MemoryMap} might be empty.\n     *\n     * <br/>\n     * Internally, this uses <tt>subarray</tt>, so new memory is not allocated.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @return {MemoryMap}\n     */\n    slice(address, length = Infinity){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n\n        const sliced = new MemoryMap();\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    sliced.set(sliceStart, block.subarray(relativeSliceStart, relativeSliceStart + sliceLength));\n                }\n            }\n        }\n        return sliced;\n    }\n\n    /**\n     * Returns a new instance of {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|Uint8Array}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>. Any byte without a value\n     * in the input {@linkcode MemoryMap} will have a value of <tt>padByte</tt>.\n     *\n     * <br/>\n     * This method allocates new memory.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @return {MemoryMap}\n     */\n    slicePad(address, length, padByte=0xFF){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n        \n        const out = (new Uint8Array(length)).fill(padByte);\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    out.set(block.subarray(relativeSliceStart, relativeSliceStart + sliceLength), sliceStart - address);\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Checks whether the current memory map contains the one given as a parameter.\n     *\n     * <br/>\n     * \"Contains\" means that all the offsets that have a byte value in the given\n     * memory map have a value in the current memory map, and that the byte values\n     * are the same.\n     *\n     * <br/>\n     * An empty memory map is always contained in any other memory map.\n     *\n     * <br/>\n     * Returns boolean <tt>true</tt> if the memory map is contained, <tt>false</tt>\n     * otherwise.\n     *\n     * @param {MemoryMap} memMap The memory map to check\n     * @return {Boolean}\n     */\n    contains(memMap) {\n        for (let [blockAddr, block] of memMap) {\n\n            const blockLength = block.length;\n\n            const slice = this.slice(blockAddr, blockLength).join().get(blockAddr);\n\n            if ((!slice) || slice.length !== blockLength ) {\n                return false;\n            }\n\n            for (const i in block) {\n                if (block[i] !== slice[i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\n\nexport default MemoryMap;\n\n","import { Z80 } from './z80';\n// @ts-ignore: Module '\"nrf-intel-hex\"' has no default export\nimport MemoryMap from 'nrf-intel-hex';\n\nlet running = false;\nlet active = true;\nlet speed = 30;\n\nlet cycles = 0;\nconst memory = Array(0xFFFF).fill(0xFF);\nconst inPorts = Array(256).fill(0xFF);\nconst outPorts = Array(256).fill(0xFF);\n\nconst cpu = Z80({\n    mem_read: (addr:number) => memory[addr],\n    mem_write: (addr:number, value:number) => memory[addr] = value,\n    io_read: (port:number) => {\n        return inPorts[port & 0xFF];\n    },\n    io_write: (port:number, value:number) => {\n        const port1 = port & 0xFF;\n        outPorts[port1] = value;\n        updateDisplay();\n        postOutPorts(port1, value);\n    },\n});\n\nconst display = Array(6).fill(0);\n\nself.onmessage = event => {\n    if (event.data.type === 'INIT') {\n        // updateMemory(ROM);\n        cpu.reset();\n        running = true;\n        run();\n    }\n    else if (event.data.type === 'PAUSE') {\n        if (active) {\n            active = false;\n            running = false;\n        }\n        else {\n            active = true;\n            running = true;\n            run();\n        }\n    }\n    else if (event.data.type === 'RESUME') {\n    }\n    else if (event.data.type === 'RESET') {\n        console.log('resetting');\n        cpu.reset();\n        running = true;\n        run();\n    }\n    else if (event.data.type === 'SET_INPUT_VALUE') {\n        const { port, value } = event.data;\n        inPorts[port] = value;\n    }\n    else if (event.data.type === 'SET_SPEED') {\n        speed = Number(event.data.value)/100;\n        console.log('set speed', speed);\n    }\n    else if (event.data.type === 'NMI') {\n        cpu.interrupt(true, 0);\n    }\n    else if (event.data.type === 'UPDATE_MEMORY') {\n        updateMemory(event.data.value);\n        cpu.reset();\n    }\n    else if (event.data.type === 'READ_MEMORY') {\n        readMemory(event.data.from, event.data.size);\n    }\n    else if (event.data.type === 'HIDDEN') {\n        let hidden = event.data.value;\n        if (hidden) {\n            running = false;\n        }\n        else if (active) {\n            running = true;\n            run();\n        }\n        else {\n            console.log('not active');\n        }\n    }\n};\n\nfunction* runGen () {\n    while (true){\n        for (let i = 0; i < 1000 ; i++) {\n            const count = cpu.run_instruction();\n            cycles += count;\n        }\n        yield cycles;\n    }\n}\n\nlet pending = false;\nconst iter = runGen();\nfunction run() {\n    if (pending) return;\n    if (!running) return;\n    iter.next();\n    const delay = Math.floor((1 - Number(speed)) * 30);\n    if (running) {\n        pending = true;\n        setTimeout(function(){\n            pending = false;\n            run();\n        }, delay)\n    };\n}\n\nfunction updateDisplay() {\n    const digits = outPorts[1];\n    const segments = outPorts[2];\n    let mask = 0x01;\n    for (let i = 0; i < 6; i++) {\n        if (digits & mask){\n            display[i] = segments;\n        }\n        mask = mask << 1;\n    }\n}\n\nfunction getPortsBuffer(){\n    var buffer = new ArrayBuffer(4);\n    var view = new Uint8Array(buffer);\n    view[0] = outPorts[0];\n    view[1] = outPorts[1];\n    view[2] = outPorts[2];\n    return buffer;\n}\n\nfunction getDisplayBuffer(){\n    var buffer = new ArrayBuffer(6);\n    var view = new Uint8Array(buffer);\n    for (let i = 0; i < 6; i++) {\n        view[i] = display[i];\n    }\n    return buffer;\n}\n\nlet speaker = 1;\nlet wavelength = 0;\nfunction postOutPorts(port:number, value:number) {\n    const buffer = getPortsBuffer();\n    const display = getDisplayBuffer();\n\n    if (port === 1 && (value === 0x7F || value === 0xFF)) {\n        const speaker1 = value >> 7;\n        if (speaker1 === 1 && speaker === 0) {\n            wavelength = cycles;\n            cycles = 0;\n        }\n        speaker = speaker1;\n    }\n    if (cycles > 10000) wavelength = 0;\n\n    self.postMessage({\n        type: 'POST_OUTPORTS',\n        buffer,\n        display,\n        speaker,\n        wavelength,\n    // @ts-ignore: Type 'ArrayBuffer' is not assignable to type 'string' bug in type definition\n    }, [buffer, display]);\n}\n\nfunction updateMemory(rom:string) {\n    const blocks = MemoryMap.fromHex(rom);\n    for (let address of blocks.keys()) {\n        const block = blocks.get(address);\n        for (let i = address; i < address + block.length; i++) {\n            memory[i] = block[i];\n        }\n    }\n}\n\nfunction readMemory(from:number, size:number) {\n    let buffer = new ArrayBuffer(size);\n    let bytes = new Uint8Array(buffer);\n    for (let i = 0; i < size; i++) {\n        bytes[i] = memory[i + from]\n    }\n    self.postMessage({\n        type: 'POST_MEMORY',\n        from,\n        size,\n        buffer,\n    // @ts-ignore: Type 'ArrayBuffer' is not assignable to type 'string' bug in type definition\n    }, [buffer]);\n}\n"]}