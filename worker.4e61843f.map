{"version":3,"sources":["src/worker/z80.ts","intel-hex.js","src/worker/worker.ts"],"names":["const","let","i","l","blockAddr","blocks","block"],"mappings":"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EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAC/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAG/C,GAAkB,CAClB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAC9C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAC9C,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI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","file":"worker.4e61843f.map","sourceRoot":"..","sourcesContent":["///////////////////////////////////////////////////////////////////////////////\n/// @file Z80.js\n///\n/// @brief Emulator for the Zilog Z80 microprocessor\n///\n/// @author Matthew Howell\n///\n/// @remarks\n///  This module is a simple, straightforward instruction interpreter.\n///   There is no fancy dynamic recompilation or cycle-accurate emulation.\n///   The author believes that this should be sufficient for any emulator that\n///   would be feasible to write in JavaScript anyway.\n///  The code and the comments in this file assume that the reader is familiar\n///   with the Z80 architecture. If you're not, here are some references I use:\n///  http://clrhome.org/table/ - Z80 instruction set tables\n///  http://www.zilog.com/docs/z80/um0080.pdf - The official manual\n///  http://www.myquest.nl/z80undocumented/z80-documented-v0.91.pdf\n///   - The Undocumented Z80, Documented\n///\n/// @copyright (c) 2013 Matthew Howell\n///  This code is released under the MIT license,\n///  a copy of which is available in the associated README.md file,\n///  or at http://opensource.org/licenses/MIT\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n/// We'll begin with the object constructor and the public API functions.\n///////////////////////////////////////////////////////////////////////////////\n\ninterface CoreParameter {\n    mem_read: (addr: number) => any;\n    mem_write: (addr: number, value: number) => number;\n    io_read: (port: number) => any;\n    io_write: (port: number, value: number) => void;\n}\n\ninterface Z80State {\n    b:number;\n    a:number;\n    c:number;\n    d:number;\n    e:number;\n    h:number;\n    l:number;\n    a_prime:number;\n    b_prime:number;\n    c_prime:number;\n    d_prime:number;\n    e_prime:number;\n    h_prime:number;\n    l_prime:number;\n    ix:number;\n    iy:number;\n    i:number;\n    r:number;\n    sp:number;\n    pc:number;\n    flags: {\n        S:number;\n        Z:number;\n        Y:number;\n        H:number;\n        X:number;\n        P:number;\n        N:number;\n        C:number;\n    }\n    flags_prime: {\n        S:number;\n        Z:number;\n        Y:number;\n        H:number;\n        X:number;\n        P:number;\n        N:number;\n        C:number;\n    }\n    imode: number;\n    iff1: number;\n    iff2: number;\n    halted: boolean;\n    do_delayed_di: boolean;\n    do_delayed_ei: boolean;\n    cycle_counter: number;\n}\n\nexport function Z80(coreParameter: CoreParameter) {\n    // Obviously we'll be needing the core object's functions again.\n    let core = coreParameter;\n\n    // The argument to this constructor should be an object containing 4 functions:\n    // mem_read(address) should return the byte at the given memory address,\n    // mem_write(address, value) should write the given value to the given memory address,\n    // io_read(port) should read a return a byte read from the given I/O port,\n    // io_write(port, value) should write the given byte to the given I/O port.\n    // If any of those functions is missing, this module cannot run.\n    if (!core || (typeof core.mem_read !== \"function\") || (typeof core.mem_write !== \"function\") ||\n        (typeof core.io_read !== \"function\") || (typeof core.io_write !== \"function\"))\n        throw (\"Z80: Core object is missing required functions.\");\n\n    // All right, let's initialize the registers.\n    // First, the standard 8080 registers.\n    let a = 0x00;\n    let b = 0x00;\n    let c = 0x00;\n    let d = 0x00;\n    let e = 0x00;\n    let h = 0x00;\n    let l = 0x00;\n    // Now the special Z80 copies of the 8080 registers\n    //  (the ones used for the SWAP instruction and such).\n    let a_prime = 0x00;\n    let b_prime = 0x00;\n    let c_prime = 0x00;\n    let d_prime = 0x00;\n    let e_prime = 0x00;\n    let h_prime = 0x00;\n    let l_prime = 0x00;\n    // And now the Z80 index registers.\n    let ix = 0x0000;\n    let iy = 0x0000;\n    // Then the \"utility\" registers: the interrupt vector,\n    //  the memory refresh, the stack pointer, and the program counter.\n    let i = 0x00;\n    let r = 0x00;\n    let sp = 0xdff0;\n    let pc = 0x0000;\n    // We don't keep an F register for the flags,\n    //  because most of the time we're only accessing a single flag,\n    //  so we optimize for that case and use utility functions\n    //  for the rarer occasions when we need to access the whole register.\n    let flags = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };\n    let flags_prime = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };\n    // And finally we have the interrupt mode and flip-flop registers.\n    let imode = 0;\n    let iff1 = 0;\n    let iff2 = 0;\n\n    // These are all specific to this implementation, not Z80 features.\n    // Keep track of whether we've had a HALT instruction called.\n    let halted = false;\n    // EI and DI wait one instruction before they take effect;\n    //  these flags tell us when we're in that wait state.\n    let do_delayed_di = false;\n    let do_delayed_ei = false;\n    // This tracks the number of cycles spent in a single instruction run,\n    //  including processing any prefixes and handling interrupts.\n    let cycle_counter = 0;\n\n    function getState():Z80State {\n        return {\n            b: b,\n            a: a,\n            c: c,\n            d: d,\n            e: e,\n            h: h,\n            l: l,\n            a_prime: a_prime,\n            b_prime: b_prime,\n            c_prime: c_prime,\n            d_prime: d_prime,\n            e_prime: e_prime,\n            h_prime: h_prime,\n            l_prime: l_prime,\n            ix: ix,\n            iy: iy,\n            i: i,\n            r: r,\n            sp: sp,\n            pc: pc,\n            flags: {\n                S: flags.S,\n                Z: flags.Z,\n                Y: flags.Y,\n                H: flags.H,\n                X: flags.X,\n                P: flags.P,\n                N: flags.N,\n                C: flags.C\n            },\n            flags_prime: {\n                S: flags_prime.S,\n                Z: flags_prime.Z,\n                Y: flags_prime.Y,\n                H: flags_prime.H,\n                X: flags_prime.X,\n                P: flags_prime.P,\n                N: flags_prime.N,\n                C: flags_prime.C\n            },\n            imode: imode,\n            iff1: iff1,\n            iff2: iff2,\n            halted: halted,\n            do_delayed_di: do_delayed_di,\n            do_delayed_ei: do_delayed_ei,\n            cycle_counter: cycle_counter\n        };\n    }\n\n    function setState(state:Z80State) {\n        b = state.b;\n        a = state.a;\n        c = state.c;\n        d = state.d;\n        e = state.e;\n        h = state.h;\n        l = state.l;\n        a_prime = state.a_prime;\n        b_prime = state.b_prime;\n        c_prime = state.c_prime;\n        d_prime = state.d_prime;\n        e_prime = state.e_prime;\n        h_prime = state.h_prime;\n        l_prime = state.l_prime;\n        ix = state.ix;\n        iy = state.iy;\n        i = state.i;\n        r = state.r;\n        sp = state.sp;\n        pc = state.pc;\n        flags.S = state.flags.S;\n        flags.Z = state.flags.Z;\n        flags.Y = state.flags.Y;\n        flags.H = state.flags.H;\n        flags.X = state.flags.X;\n        flags.P = state.flags.P;\n        flags.N = state.flags.N;\n        flags.C = state.flags.C;\n        flags_prime.S = state.flags_prime.S;\n        flags_prime.Z = state.flags_prime.Z;\n        flags_prime.Y = state.flags_prime.Y;\n        flags_prime.H = state.flags_prime.H;\n        flags_prime.X = state.flags_prime.X;\n        flags_prime.P = state.flags_prime.P;\n        flags_prime.N = state.flags_prime.N;\n        flags_prime.C = state.flags_prime.C;\n        imode = state.imode;\n        iff1 = state.iff1;\n        iff2 = state.iff2;\n        halted = state.halted;\n        do_delayed_di = state.do_delayed_di;\n        do_delayed_ei = state.do_delayed_ei;\n        cycle_counter = state.cycle_counter;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public reset\n    ///\n    /// @brief Re-initialize the processor as if a reset or power on had occured\n    ///////////////////////////////////////////////////////////////////////////////\n    let reset = function () {\n        // These registers are the ones that have predictable states\n        //  immediately following a power-on or a reset.\n        // The others are left alone, because their states are unpredictable.\n        sp = 0xdff0;\n        pc = 0x0000;\n        a = 0x00;\n        r = 0x00;\n        set_flags_register(0);\n        // Start up with interrupts disabled.\n        imode = 0;\n        iff1 = 0;\n        iff2 = 0;\n        // Don't start halted or in a delayed DI or EI.\n        halted = false;\n        do_delayed_di = false;\n        do_delayed_ei = false;\n        // Obviously we've not used any cycles yet.\n        cycle_counter = 0;\n    };\n\n    let reset1 = function () {\n        sp = 0xdff0;\n        pc = 0x0000;\n        halted = false;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public run_instruction\n    ///\n    /// @brief Runs a single instruction\n    ///\n    /// @return The number of T cycles the instruction took to run,\n    ///          plus any time that went into handling interrupts that fired\n    ///          while this instruction was executing\n    ///////////////////////////////////////////////////////////////////////////////\n    let run_instruction = function () {\n        if (!halted) {\n            // If the previous instruction was a DI or an EI,\n            //  we'll need to disable or enable interrupts\n            //  after whatever instruction we're about to run is finished.\n            var doing_delayed_di = false, doing_delayed_ei = false;\n            if (do_delayed_di) {\n                do_delayed_di = false;\n                doing_delayed_di = true;\n            }\n            else if (do_delayed_ei) {\n                do_delayed_ei = false;\n                doing_delayed_ei = true;\n            }\n\n            // R is incremented at the start of every instruction cycle,\n            //  before the instruction actually runs.\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n            // Read the byte at the PC and run the instruction it encodes.\n            var opcode = core.mem_read(pc);\n            try {\n                decode_instruction(opcode);\n            }\n            catch (e) {\n                console.log(`Illegal opcode ${opcode} at ${pc}`, e);\n                halted = true;\n            }\n            pc = (pc + 1) & 0xffff;\n\n            // Actually do the delayed interrupt disable/enable if we have one.\n            if (doing_delayed_di) {\n                iff1 = 0;\n                iff2 = 0;\n            }\n            else if (doing_delayed_ei) {\n                iff1 = 1;\n                iff2 = 1;\n            }\n\n            // And finally clear out the cycle counter for the next instruction\n            //  before returning it to the emulator core.\n            var retval = cycle_counter;\n            cycle_counter = 0;\n            return retval;\n        }\n        else {\n            // While we're halted, claim that we spent a cycle doing nothing,\n            //  so that the rest of the emulator can still proceed.\n            return 1;\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// @public interrupt\n    ///\n    /// @brief Simulates pulsing the processor's INT (or NMI) pin\n    ///\n    /// @param non_maskable - true if this is a non-maskable interrupt\n    /// @param data - the value to be placed on the data bus, if needed\n    ///////////////////////////////////////////////////////////////////////////////\n    let interrupt = function (non_maskable:boolean, data:number) {\n        if (non_maskable) {\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n            // Non-maskable interrupts are always handled the same way;\n            //  clear IFF1 and then do a CALL 0x0066.\n            // Also, all interrupts reset the HALT state.\n            halted = false;\n            iff2 = iff1;\n            iff1 = 0;\n            push_word(pc);\n            pc = 0x66;\n            cycle_counter += 11;\n        }\n        else if (iff1) {\n            // The high bit of R is not affected by this increment,\n            //  it can only be changed using the LD R, A instruction.\n            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n            halted = false;\n            iff1 = 0;\n            iff2 = 0;\n\n            if (imode === 0) {\n                // In the 8080-compatible interrupt mode,\n                //  decode the content of the data bus as an instruction and run it.\n                decode_instruction(data);\n                cycle_counter += 2;\n            }\n            else if (imode === 1) {\n                // Mode 1 is always just RST 0x38.\n                push_word(pc);\n                pc = 0x38;\n                cycle_counter += 13;\n            }\n            else if (imode === 2) {\n                // Mode 2 uses the value on the data bus as in index\n                //  into the vector table pointer to by the I register.\n                push_word(pc);\n                // The Z80 manual says that this address must be 2-byte aligned,\n                //  but it doesn't appear that this is actually the case on the hardware,\n                //  so we don't attempt to enforce that here.\n                var vector_address = ((i << 8) | data);\n                pc = core.mem_read(vector_address) |\n                    (core.mem_read((vector_address + 1) & 0xffff) << 8);\n\n                cycle_counter += 19;\n            }\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// The public API functions end here.\n    ///\n    /// What begins here are just general utility functions, used variously.\n    ///////////////////////////////////////////////////////////////////////////////\n    let decode_instruction = function (opcode:number) {\n        // The register-to-register loads and ALU instructions\n        //  are all so uniform that we can decode them directly\n        //  instead of going into the instruction array for them.\n        // This function gets the operand for all of these instructions.\n        var get_operand = function (opcode:number) {\n            return ((opcode & 0x07) === 0) ? b :\n                ((opcode & 0x07) === 1) ? c :\n                    ((opcode & 0x07) === 2) ? d :\n                        ((opcode & 0x07) === 3) ? e :\n                            ((opcode & 0x07) === 4) ? h :\n                                ((opcode & 0x07) === 5) ? l :\n                                    ((opcode & 0x07) === 6) ? core.mem_read(l | (h << 8)) : a;\n        };\n\n        // Handle HALT right up front, because it fouls up our LD decoding\n        //  by falling where LD (HL), (HL) ought to be.\n        if (opcode === 0x76) {\n            halted = true;\n        }\n        else if ((opcode >= 0x40) && (opcode < 0x80)) {\n            // This entire range is all 8-bit register loads.\n            // Get the operand and assign it to the correct destination.\n            var operand = get_operand(opcode);\n\n            if (((opcode & 0x38) >>> 3) === 0)\n                b = operand;\n            else if (((opcode & 0x38) >>> 3) === 1)\n                c = operand;\n            else if (((opcode & 0x38) >>> 3) === 2)\n                d = operand;\n            else if (((opcode & 0x38) >>> 3) === 3)\n                e = operand;\n            else if (((opcode & 0x38) >>> 3) === 4)\n                h = operand;\n            else if (((opcode & 0x38) >>> 3) === 5)\n                l = operand;\n            else if (((opcode & 0x38) >>> 3) === 6)\n                core.mem_write(l | (h << 8), operand);\n            else if (((opcode & 0x38) >>> 3) === 7)\n                a = operand;\n        }\n        else if ((opcode >= 0x80) && (opcode < 0xc0)) {\n            // These are the 8-bit register ALU instructions.\n            // We'll get the operand and then use this \"jump table\"\n            //  to call the correct utility function for the instruction.\n            var operand = get_operand(opcode),\n                op_array = [do_add, do_adc, do_sub, do_sbc,\n                    do_and, do_xor, do_or, do_cp];\n\n            op_array[(opcode & 0x38) >>> 3](operand);\n        }\n        else {\n            // This is one of the less formulaic instructions;\n            //  we'll get the specific function for it from our array.\n            var func = instructions[opcode];\n            func();\n        }\n\n        // Update the cycle counter with however many cycles\n        //  the base instruction took.\n        // If this was a prefixed instruction, then\n        //  the prefix handler has added its extra cycles already.\n        cycle_counter += cycle_counts[opcode];\n    };\n\n    let get_signed_offset_byte = function (value:number) {\n        // This function requires some explanation.\n        // We just use JavaScript Number variables for our registers,\n        //  not like a typed array or anything.\n        // That means that, when we have a byte value that's supposed\n        //  to represent a signed offset, the value we actually see\n        //  isn't signed at all, it's just a small integer.\n        // So, this function converts that byte into something JavaScript\n        //  will recognize as signed, so we can easily do arithmetic with it.\n        // First, we clamp the value to a single byte, just in case.\n        value &= 0xff;\n        // We don't have to do anything if the value is positive.\n        if (value & 0x80) {\n            // But if the value is negative, we need to manually un-two's-compliment it.\n            // I'm going to assume you can figure out what I meant by that,\n            //  because I don't know how else to explain it.\n            // We could also just do value |= 0xffffff00, but I prefer\n            //  not caring how many bits are in the integer representation\n            //  of a JavaScript number in the currently running browser.\n            value = -((0xff & ~value) + 1);\n        }\n        return value;\n    };\n\n    let get_flags_register = function () {\n        // We need the whole F register for some reason.\n        //  probably a PUSH AF instruction,\n        //  so make the F register out of our separate flags.\n        return (flags.S << 7) |\n            (flags.Z << 6) |\n            (flags.Y << 5) |\n            (flags.H << 4) |\n            (flags.X << 3) |\n            (flags.P << 2) |\n            (flags.N << 1) |\n            (flags.C);\n    };\n\n    let get_flags_prime = function () {\n        // This is the same as the above for the F' register.\n        return (flags_prime.S << 7) |\n            (flags_prime.Z << 6) |\n            (flags_prime.Y << 5) |\n            (flags_prime.H << 4) |\n            (flags_prime.X << 3) |\n            (flags_prime.P << 2) |\n            (flags_prime.N << 1) |\n            (flags_prime.C);\n    };\n\n    let set_flags_register = function (operand:number) {\n        // We need to set the F register, probably for a POP AF,\n        //  so break out the given value into our separate flags.\n        flags.S = (operand & 0x80) >>> 7;\n        flags.Z = (operand & 0x40) >>> 6;\n        flags.Y = (operand & 0x20) >>> 5;\n        flags.H = (operand & 0x10) >>> 4;\n        flags.X = (operand & 0x08) >>> 3;\n        flags.P = (operand & 0x04) >>> 2;\n        flags.N = (operand & 0x02) >>> 1;\n        flags.C = (operand & 0x01);\n    };\n\n    let set_flags_prime = function (operand:number) {\n        // Again, this is the same as the above for F'.\n        flags_prime.S = (operand & 0x80) >>> 7;\n        flags_prime.Z = (operand & 0x40) >>> 6;\n        flags_prime.Y = (operand & 0x20) >>> 5;\n        flags_prime.H = (operand & 0x10) >>> 4;\n        flags_prime.X = (operand & 0x08) >>> 3;\n        flags_prime.P = (operand & 0x04) >>> 2;\n        flags_prime.N = (operand & 0x02) >>> 1;\n        flags_prime.C = (operand & 0x01);\n    };\n\n    let update_xy_flags = function (result:number) {\n        // Most of the time, the undocumented flags\n        //  (sometimes called X and Y, or 3 and 5),\n        //  take their values from the corresponding bits\n        //  of the result of the instruction,\n        //  or from some other related value.\n        // This is a utility function to set those flags based on those bits.\n        flags.Y = (result & 0x20) >>> 5;\n        flags.X = (result & 0x08) >>> 3;\n    };\n\n    let get_parity = function (value:number) {\n        // We could try to actually calculate the parity every time,\n        //  but why calculate what you can pre-calculate?\n        var parity_bits = [\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n            1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1\n        ];\n        return parity_bits[value];\n    };\n\n    let push_word = function (operand:number) {\n        // Pretty obvious what this function does; given a 16-bit value,\n        //  decrement the stack pointer, write the high byte to the new\n        //  stack pointer location, then repeat for the low byte.\n        sp = (sp - 1) & 0xffff;\n        core.mem_write(sp, (operand & 0xff00) >>> 8);\n        sp = (sp - 1) & 0xffff;\n        core.mem_write(sp, operand & 0x00ff);\n    };\n\n    let pop_word = function () {\n        // Again, not complicated; read a byte off the top of the stack,\n        //  increment the stack pointer, rinse and repeat.\n        var retval = core.mem_read(sp) & 0xff;\n        sp = (sp + 1) & 0xffff;\n        retval |= core.mem_read(sp) << 8;\n        sp = (sp + 1) & 0xffff;\n        return retval;\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// Now, the way most instructions work in this emulator is that they set up\n    ///  their operands according to their addressing mode, and then they call a\n    ///  utility function that handles all variations of that instruction.\n    /// Those utility functions begin here.\n    ///////////////////////////////////////////////////////////////////////////////\n    let do_conditional_absolute_jump = function (condition:boolean) {\n        // This function implements the JP [condition],nn instructions.\n        if (condition) {\n            // We're taking this jump, so write the new PC,\n            //  and then decrement the thing we just wrote,\n            //  because the instruction decoder increments the PC\n            //  unconditionally at the end of every instruction\n            //  and we need to counteract that so we end up at the jump target.\n            pc = core.mem_read((pc + 1) & 0xffff) |\n                (core.mem_read((pc + 2) & 0xffff) << 8);\n            pc = (pc - 1) & 0xffff;\n        }\n        else {\n            // We're not taking this jump, just move the PC past the operand.\n            pc = (pc + 2) & 0xffff;\n        }\n    };\n\n    let do_conditional_relative_jump = function (condition:boolean) {\n        // This function implements the JR [condition],n instructions.\n        if (condition) {\n            // We need a few more cycles to actually take the jump.\n            cycle_counter += 5;\n            // Calculate the offset specified by our operand.\n            var offset = get_signed_offset_byte(core.mem_read((pc + 1) & 0xffff));\n            // Add the offset to the PC, also skipping past this instruction.\n            pc = (pc + offset + 1) & 0xffff;\n        }\n        else {\n            // No jump happening, just skip the operand.\n            pc = (pc + 1) & 0xffff;\n        }\n    };\n\n    let do_conditional_call = function (condition:boolean) {\n        // This function is the CALL [condition],nn instructions.\n        // If you've seen the previous functions, you know this drill.\n        if (condition) {\n            cycle_counter += 7;\n            push_word((pc + 3) & 0xffff);\n            pc = core.mem_read((pc + 1) & 0xffff) |\n                (core.mem_read((pc + 2) & 0xffff) << 8);\n            pc = (pc - 1) & 0xffff;\n        }\n        else {\n            pc = (pc + 2) & 0xffff;\n        }\n    };\n\n    let do_conditional_return = function (condition:boolean) {\n        if (condition) {\n            cycle_counter += 6;\n            pc = (pop_word() - 1) & 0xffff;\n        }\n    };\n\n    let do_reset = function (address:number) {\n        // The RST [address] instructions go through here.\n        push_word((pc + 1) & 0xffff);\n        pc = (address - 1) & 0xffff;\n    };\n\n    let do_add = function (operand:number) {\n        // This is the ADD A, [operand] instructions.\n        // We'll do the literal addition, which includes any overflow,\n        //  so that we can more easily figure out whether we had\n        //  an overflow or a carry and set the flags accordingly.\n        var result = a + operand;\n\n        // The great majority of the work for the arithmetic instructions\n        //  turns out to be setting the flags rather than the actual operation.\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((operand & 0x0f) + (a & 0x0f)) & 0x10) ? 1 : 0;\n        // An overflow has happened if the sign bits of the accumulator and the operand\n        //  don't match the sign bit of the result value.\n        flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_adc = function (operand:number) {\n        var result = a + operand + flags.C;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((operand & 0x0f) + (a & 0x0f) + flags.C) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_sub = function (operand:number) {\n        var result = a - operand;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((a & 0x0f) - (operand & 0x0f)) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_sbc = function (operand:number) {\n        var result = a - operand - flags.C;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = (((a & 0x0f) - (operand & 0x0f) - flags.C) & 0x10) ? 1 : 0;\n        flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x100) ? 1 : 0;\n\n        a = result & 0xff;\n        update_xy_flags(a);\n    };\n\n    let do_cp = function (operand:number) {\n        // A compare instruction is just a subtraction that doesn't save the value,\n        //  so we implement it as... a subtraction that doesn't save the value.\n        var temp = a;\n        do_sub(operand);\n        a = temp;\n        // Since this instruction has no \"result\" value, the undocumented flags\n        //  are set based on the operand instead.\n        update_xy_flags(operand);\n    };\n\n    let do_and = function (operand:number) {\n        // The logic instructions are all pretty straightforward.\n        a &= operand & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 1;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_or = function (operand:number) {\n        a = (operand | a) & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 0;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_xor = function (operand:number) {\n        a = (operand ^ a) & 0xff;\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = 0;\n        flags.P = get_parity(a);\n        flags.N = 0;\n        flags.C = 0;\n        update_xy_flags(a);\n    };\n\n    let do_inc = function (operand:number) {\n        var result = operand + 1;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = ((operand & 0x0f) === 0x0f) ? 1 : 0;\n        // It's a good deal easier to detect overflow for an increment/decrement.\n        flags.P = (operand === 0x7f) ? 1 : 0;\n        flags.N = 0;\n\n        result &= 0xff;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_dec = function (operand:number) {\n        var result = operand - 1;\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = !(result & 0xff) ? 1 : 0;\n        flags.H = ((operand & 0x0f) === 0x00) ? 1 : 0;\n        flags.P = (operand === 0x80) ? 1 : 0;\n        flags.N = 1;\n\n        result &= 0xff;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_hl_add = function (operand:number) {\n        // The HL arithmetic instructions are the same as the A ones,\n        //  just with twice as many bits happening.\n        var hl = l | (h << 8), result = hl + operand;\n\n        flags.N = 0;\n        flags.C = (result & 0x10000) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        update_xy_flags(h);\n    };\n\n    let do_hl_adc = function (operand:number) {\n        operand += flags.C;\n        var hl = l | (h << 8), result = hl + operand;\n\n        flags.S = (result & 0x8000) ? 1 : 0;\n        flags.Z = !(result & 0xffff) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n        flags.P = ((hl & 0x8000) === (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;\n        flags.N = 0;\n        flags.C = (result & 0x10000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result >>> 8) & 0xff;\n\n        update_xy_flags(h);\n    };\n\n    let do_hl_sbc = function (operand:number) {\n        operand += flags.C;\n        var hl = l | (h << 8), result = hl - operand;\n\n        flags.S = (result & 0x8000) ? 1 : 0;\n        flags.Z = !(result & 0xffff) ? 1 : 0;\n        flags.H = (((hl & 0x0fff) - (operand & 0x0fff)) & 0x1000) ? 1 : 0;\n        flags.P = ((hl & 0x8000) !== (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;\n        flags.N = 1;\n        flags.C = (result & 0x10000) ? 1 : 0;\n\n        l = result & 0xff;\n        h = (result >>> 8) & 0xff;\n\n        update_xy_flags(h);\n    };\n\n    let do_in = function (port:number) {\n        var result = core.io_read(port);\n\n        flags.S = (result & 0x80) ? 1 : 0;\n        flags.Z = result ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(result) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(result);\n\n        return result;\n    };\n\n    let do_neg = function () {\n        // This instruction is defined to not alter the register if it === 0x80.\n        if (a !== 0x80) {\n            // This is a signed operation, so convert A to a signed value.\n            a = get_signed_offset_byte(a);\n\n            a = (-a) & 0xff;\n        }\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = !a ? 1 : 0;\n        flags.H = (((-a) & 0x0f) > 0) ? 1 : 0;\n        flags.P = (a === 0x80) ? 1 : 0;\n        flags.N = 1;\n        flags.C = a ? 1 : 0;\n        update_xy_flags(a);\n    };\n\n    let do_ldi = function () {\n        // Copy the value that we're supposed to copy.\n        var read_value = core.mem_read(l | (h << 8));\n        core.mem_write(e | (d << 8), read_value);\n\n        // Increment DE and HL, and decrement BC.\n        var result = (e | (d << 8)) + 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n        result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.H = 0;\n        flags.P = (c || b) ? 1 : 0;\n        flags.N = 0;\n        flags.Y = ((a + read_value) & 0x02) >>> 1;\n        flags.X = ((a + read_value) & 0x08) >>> 3;\n    };\n\n    let do_cpi = function () {\n        var temp_carry = flags.C;\n        var read_value = core.mem_read(l | (h << 8))\n        do_cp(read_value);\n        flags.C = temp_carry;\n        flags.Y = ((a - read_value - flags.H) & 0x02) >>> 1;\n        flags.X = ((a - read_value - flags.H) & 0x08) >>> 3;\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = result ? 1 : 0;\n    };\n\n    let do_ini = function () {\n        b = do_dec(b);\n\n        core.mem_write(l | (h << 8), core.io_read((b << 8) | c));\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        flags.N = 1;\n    };\n\n    let do_outi = function () {\n        core.io_write((b << 8) | c, core.mem_read(l | (h << 8)));\n\n        var result = (l | (h << 8)) + 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        b = do_dec(b);\n        flags.N = 1;\n    };\n\n    let do_ldd = function () {\n        flags.N = 0;\n        flags.H = 0;\n\n        var read_value = core.mem_read(l | (h << 8));\n        core.mem_write(e | (d << 8), read_value);\n\n        var result = (e | (d << 8)) - 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n        result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = (c || b) ? 1 : 0;\n        flags.Y = ((a + read_value) & 0x02) >>> 1;\n        flags.X = ((a + read_value) & 0x08) >>> 3;\n    };\n\n    let do_cpd = function () {\n        var temp_carry = flags.C\n        var read_value = core.mem_read(l | (h << 8))\n        do_cp(read_value);\n        flags.C = temp_carry;\n        flags.Y = ((a - read_value - flags.H) & 0x02) >>> 1;\n        flags.X = ((a - read_value - flags.H) & 0x08) >>> 3;\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n        result = (c | (b << 8)) - 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n\n        flags.P = result ? 1 : 0;\n    };\n\n    let do_ind = function () {\n        b = do_dec(b);\n\n        core.mem_write(l | (h << 8), core.io_read((b << 8) | c));\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        flags.N = 1;\n    };\n\n    let do_outd = function () {\n        core.io_write((b << 8) | c, core.mem_read(l | (h << 8)));\n\n        var result = (l | (h << 8)) - 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n\n        b = do_dec(b);\n        flags.N = 1;\n    };\n\n    let do_rlc = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) | flags.C) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_rrc = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (flags.C << 7);\n\n        flags.Z = !(operand & 0xff) ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand & 0xff;\n    };\n\n    let do_rl = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        var temp = flags.C;\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) | temp) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_rr = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        var temp = flags.C;\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (temp << 7);\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sla = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = (operand << 1) & 0xff;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sra = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = ((operand >>> 1) & 0x7f) | (operand & 0x80);\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_sll = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = (operand & 0x80) >>> 7;\n        operand = ((operand << 1) & 0xff) | 1;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = (operand & 0x80) ? 1 : 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_srl = function (operand:number) {\n        flags.N = 0;\n        flags.H = 0;\n\n        flags.C = operand & 1;\n        operand = (operand >>> 1) & 0x7f;\n\n        flags.Z = !operand ? 1 : 0;\n        flags.P = get_parity(operand);\n        flags.S = 0;\n        update_xy_flags(operand);\n\n        return operand;\n    };\n\n    let do_ix_add = function (operand:number) {\n        flags.N = 0;\n\n        var result = ix + operand;\n\n        flags.C = (result & 0x10000) ? 1 : 0;\n        flags.H = (((ix & 0xfff) + (operand & 0xfff)) & 0x1000) ? 1 : 0;\n        update_xy_flags((result & 0xff00) >>> 8);\n\n        ix = result;\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// This table contains the implementations for the instructions that weren't\n    ///  implemented directly in the decoder function (everything but the 8-bit\n    ///  register loads and the accumulator ALU instructions, in other words).\n    /// Similar tables for the ED and DD/FD prefixes follow this one.\n    ///////////////////////////////////////////////////////////////////////////////\n    let instructions:any[] = [];\n\n    // 0x00 : NOP\n    instructions[0x00] = function () { };\n    // 0x01 : LD BC, nn\n    instructions[0x01] = function () {\n        pc = (pc + 1) & 0xffff;\n        c = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        b = core.mem_read(pc);\n    };\n    // 0x02 : LD (BC), A\n    instructions[0x02] = function () {\n        core.mem_write(c | (b << 8), a);\n    };\n    // 0x03 : INC BC\n    instructions[0x03] = function () {\n        var result = (c | (b << 8));\n        result += 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0x04 : INC B\n    instructions[0x04] = function () {\n        b = do_inc(b);\n    };\n    // 0x05 : DEC B\n    instructions[0x05] = function () {\n        b = do_dec(b);\n    };\n    // 0x06 : LD B, n\n    instructions[0x06] = function () {\n        pc = (pc + 1) & 0xffff;\n        b = core.mem_read(pc);\n    };\n    // 0x07 : RLCA\n    instructions[0x07] = function () {\n        // This instruction is implemented as a special case of the\n        //  more general Z80-specific RLC instruction.\n        // Specifially, RLCA is a version of RLC A that affects fewer flags.\n        // The same applies to RRCA, RLA, and RRA.\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rlc(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x08 : EX AF, AF'\n    instructions[0x08] = function () {\n        var temp = a;\n        a = a_prime;\n        a_prime = temp;\n\n        temp = get_flags_register();\n        set_flags_register(get_flags_prime());\n        set_flags_prime(temp);\n    };\n    // 0x09 : ADD HL, BC\n    instructions[0x09] = function () {\n        do_hl_add(c | (b << 8));\n    };\n    // 0x0a : LD A, (BC)\n    instructions[0x0a] = function () {\n        a = core.mem_read(c | (b << 8));\n    };\n    // 0x0b : DEC BC\n    instructions[0x0b] = function () {\n        var result = (c | (b << 8));\n        result -= 1;\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0x0c : INC C\n    instructions[0x0c] = function () {\n        c = do_inc(c);\n    };\n    // 0x0d : DEC C\n    instructions[0x0d] = function () {\n        c = do_dec(c);\n    };\n    // 0x0e : LD C, n\n    instructions[0x0e] = function () {\n        pc = (pc + 1) & 0xffff;\n        c = core.mem_read(pc);\n    };\n    // 0x0f : RRCA\n    instructions[0x0f] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rrc(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x10 : DJNZ nn\n    instructions[0x10] = function () {\n        b = (b - 1) & 0xff;\n        do_conditional_relative_jump(b !== 0);\n    };\n    // 0x11 : LD DE, nn\n    instructions[0x11] = function () {\n        pc = (pc + 1) & 0xffff;\n        e = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        d = core.mem_read(pc);\n    };\n    // 0x12 : LD (DE), A\n    instructions[0x12] = function () {\n        core.mem_write(e | (d << 8), a);\n    };\n    // 0x13 : INC DE\n    instructions[0x13] = function () {\n        var result = (e | (d << 8));\n        result += 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0x14 : INC D\n    instructions[0x14] = function () {\n        d = do_inc(d);\n    };\n    // 0x15 : DEC D\n    instructions[0x15] = function () {\n        d = do_dec(d);\n    };\n    // 0x16 : LD D, n\n    instructions[0x16] = function () {\n        pc = (pc + 1) & 0xffff;\n        d = core.mem_read(pc);\n    };\n    // 0x17 : RLA\n    instructions[0x17] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rl(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x18 : JR n\n    instructions[0x18] = function () {\n        var offset = get_signed_offset_byte(core.mem_read((pc + 1) & 0xffff));\n        pc = (pc + offset + 1) & 0xffff;\n    };\n    // 0x19 : ADD HL, DE\n    instructions[0x19] = function () {\n        do_hl_add(e | (d << 8));\n    };\n    // 0x1a : LD A, (DE)\n    instructions[0x1a] = function () {\n        a = core.mem_read(e | (d << 8));\n    };\n    // 0x1b : DEC DE\n    instructions[0x1b] = function () {\n        var result = (e | (d << 8));\n        result -= 1;\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0x1c : INC E\n    instructions[0x1c] = function () {\n        e = do_inc(e);\n    };\n    // 0x1d : DEC E\n    instructions[0x1d] = function () {\n        e = do_dec(e);\n    };\n    // 0x1e : LD E, n\n    instructions[0x1e] = function () {\n        pc = (pc + 1) & 0xffff;\n        e = core.mem_read(pc);\n    };\n    // 0x1f : RRA\n    instructions[0x1f] = function () {\n        var temp_s = flags.S, temp_z = flags.Z, temp_p = flags.P;\n        a = do_rr(a);\n        flags.S = temp_s;\n        flags.Z = temp_z;\n        flags.P = temp_p;\n    };\n    // 0x20 : JR NZ, n\n    instructions[0x20] = function () {\n        do_conditional_relative_jump(!flags.Z);\n    };\n    // 0x21 : LD HL, nn\n    instructions[0x21] = function () {\n        pc = (pc + 1) & 0xffff;\n        l = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        h = core.mem_read(pc);\n    };\n    // 0x22 : LD (nn), HL\n    instructions[0x22] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, l);\n        core.mem_write((address + 1) & 0xffff, h);\n    };\n    // 0x23 : INC HL\n    instructions[0x23] = function () {\n        var result = (l | (h << 8));\n        result += 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0x24 : INC H\n    instructions[0x24] = function () {\n        h = do_inc(h);\n    };\n    // 0x25 : DEC H\n    instructions[0x25] = function () {\n        h = do_dec(h);\n    };\n    // 0x26 : LD H, n\n    instructions[0x26] = function () {\n        pc = (pc + 1) & 0xffff;\n        h = core.mem_read(pc);\n    };\n    // 0x27 : DAA\n    instructions[0x27] = function () {\n        var temp = a;\n        if (!flags.N) {\n            if (flags.H || ((a & 0x0f) > 9))\n                temp += 0x06;\n            if (flags.C || (a > 0x99))\n                temp += 0x60;\n        }\n        else {\n            if (flags.H || ((a & 0x0f) > 9))\n                temp -= 0x06;\n            if (flags.C || (a > 0x99))\n                temp -= 0x60;\n        }\n\n        flags.S = (temp & 0x80) ? 1 : 0;\n        flags.Z = !(temp & 0xff) ? 1 : 0;\n        flags.H = ((a & 0x10) ^ (temp & 0x10)) ? 1 : 0;\n        flags.P = get_parity(temp & 0xff);\n        // DAA never clears the carry flag if it was already set,\n        //  but it is able to set the carry flag if it was clear.\n        // Don't ask me, I don't know.\n        // Note also that we check for a BCD carry, instead of the usual.\n        flags.C = (flags.C || (a > 0x99)) ? 1 : 0;\n\n        a = temp & 0xff;\n\n        update_xy_flags(a);\n    };\n    // 0x28 : JR Z, n\n    instructions[0x28] = function () {\n        do_conditional_relative_jump(!!flags.Z);\n    };\n    // 0x29 : ADD HL, HL\n    instructions[0x29] = function () {\n        do_hl_add(l | (h << 8));\n    };\n    // 0x2a : LD HL, (nn)\n    instructions[0x2a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        l = core.mem_read(address);\n        h = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x2b : DEC HL\n    instructions[0x2b] = function () {\n        var result = (l | (h << 8));\n        result -= 1;\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0x2c : INC L\n    instructions[0x2c] = function () {\n        l = do_inc(l);\n    };\n    // 0x2d : DEC L\n    instructions[0x2d] = function () {\n        l = do_dec(l);\n    };\n    // 0x2e : LD L, n\n    instructions[0x2e] = function () {\n        pc = (pc + 1) & 0xffff;\n        l = core.mem_read(pc);\n    };\n    // 0x2f : CPL\n    instructions[0x2f] = function () {\n        a = (~a) & 0xff;\n        flags.N = 1;\n        flags.H = 1;\n        update_xy_flags(a);\n    };\n    // 0x30 : JR NC, n\n    instructions[0x30] = function () {\n        do_conditional_relative_jump(!flags.C);\n    };\n    // 0x31 : LD SP, nn\n    instructions[0x31] = function () {\n        sp = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc + 2) & 0xffff;\n    };\n    // 0x32 : LD (nn), A\n    instructions[0x32] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, a);\n    };\n    // 0x33 : INC SP\n    instructions[0x33] = function () {\n        sp = (sp + 1) & 0xffff;\n    };\n    // 0x34 : INC (HL)\n    instructions[0x34] = function () {\n        var address = l | (h << 8);\n        core.mem_write(address, do_inc(core.mem_read(address)));\n    };\n    // 0x35 : DEC (HL)\n    instructions[0x35] = function () {\n        var address = l | (h << 8);\n        core.mem_write(address, do_dec(core.mem_read(address)));\n    };\n    // 0x36 : LD (HL), n\n    instructions[0x36] = function () {\n        pc = (pc + 1) & 0xffff;\n        core.mem_write(l | (h << 8), core.mem_read(pc));\n    };\n    // 0x37 : SCF\n    instructions[0x37] = function () {\n        flags.N = 0;\n        flags.H = 0;\n        flags.C = 1;\n        update_xy_flags(a);\n    };\n    // 0x38 : JR C, n\n    instructions[0x38] = function () {\n        do_conditional_relative_jump(!!flags.C);\n    };\n    // 0x39 : ADD HL, SP\n    instructions[0x39] = function () {\n        do_hl_add(sp);\n    };\n    // 0x3a : LD A, (nn)\n    instructions[0x3a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        a = core.mem_read(address);\n    };\n    // 0x3b : DEC SP\n    instructions[0x3b] = function () {\n        sp = (sp - 1) & 0xffff;\n    };\n    // 0x3c : INC A\n    instructions[0x3c] = function () {\n        a = do_inc(a);\n    };\n    // 0x3d : DEC A\n    instructions[0x3d] = function () {\n        a = do_dec(a);\n    };\n    // 0x3e : LD A, n\n    instructions[0x3e] = function () {\n        a = core.mem_read((pc + 1) & 0xffff);\n        pc = (pc + 1) & 0xffff;\n    };\n    // 0x3f : CCF\n    instructions[0x3f] = function () {\n        flags.N = 0;\n        flags.H = flags.C;\n        flags.C = flags.C ? 0 : 1;\n        update_xy_flags(a);\n    };\n    // 0xc0 : RET NZ\n    instructions[0xc0] = function () {\n        do_conditional_return(!flags.Z);\n    };\n    // 0xc1 : POP BC\n    instructions[0xc1] = function () {\n        var result = pop_word();\n        c = result & 0xff;\n        b = (result & 0xff00) >>> 8;\n    };\n    // 0xc2 : JP NZ, nn\n    instructions[0xc2] = function () {\n        do_conditional_absolute_jump(!flags.Z);\n    };\n    // 0xc3 : JP nn\n    instructions[0xc3] = function () {\n        pc = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xc4 : CALL NZ, nn\n    instructions[0xc4] = function () {\n        do_conditional_call(!flags.Z);\n    };\n    // 0xc5 : PUSH BC\n    instructions[0xc5] = function () {\n        push_word(c | (b << 8));\n    };\n    // 0xc6 : ADD A, n\n    instructions[0xc6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_add(core.mem_read(pc));\n    };\n    // 0xc7 : RST 00h\n    instructions[0xc7] = function () {\n        do_reset(0x00);\n    };\n    // 0xc8 : RET Z\n    instructions[0xc8] = function () {\n        do_conditional_return(!!flags.Z);\n    };\n    // 0xc9 : RET\n    instructions[0xc9] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n    };\n    // 0xca : JP Z, nn\n    instructions[0xca] = function () {\n        do_conditional_absolute_jump(!!flags.Z);\n    };\n    // 0xcb : CB Prefix\n    instructions[0xcb] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        // We don't have a table for this prefix,\n        //  the instructions are all so uniform that we can directly decode them.\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            bit_number = (opcode & 0x38) >>> 3,\n            reg_code = opcode & 0x07;\n\n        if (opcode < 0x40) {\n            // Shift/rotate instructions\n            var op_array = [do_rlc, do_rrc, do_rl, do_rr,\n                do_sla, do_sra, do_sll, do_srl];\n\n            if (reg_code === 0)\n                b = op_array[bit_number](b);\n            else if (reg_code === 1)\n                c = op_array[bit_number](c);\n            else if (reg_code === 2)\n                d = op_array[bit_number](d);\n            else if (reg_code === 3)\n                e = op_array[bit_number](e);\n            else if (reg_code === 4)\n                h = op_array[bit_number](h);\n            else if (reg_code === 5)\n                l = op_array[bit_number](l);\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    op_array[bit_number](core.mem_read(l | (h << 8))));\n            else if (reg_code === 7)\n                a = op_array[bit_number](a);\n        }\n        else if (opcode < 0x80) {\n            // BIT instructions\n            if (reg_code === 0)\n                flags.Z = !(b & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 1)\n                flags.Z = !(c & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 2)\n                flags.Z = !(d & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 3)\n                flags.Z = !(e & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 4)\n                flags.Z = !(h & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 5)\n                flags.Z = !(l & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 6)\n                flags.Z = !((core.mem_read(l | (h << 8))) & (1 << bit_number)) ? 1 : 0;\n            else if (reg_code === 7)\n                flags.Z = !(a & (1 << bit_number)) ? 1 : 0;\n\n            flags.N = 0;\n            flags.H = 1;\n            flags.P = flags.Z;\n            flags.S = ((bit_number === 7) && !flags.Z) ? 1 : 0;\n            // For the BIT n, (HL) instruction, the X and Y flags are obtained\n            //  from what is apparently an internal temporary register used for\n            //  some of the 16-bit arithmetic instructions.\n            // I haven't implemented that register here,\n            //  so for now we'll set X and Y the same way for every BIT opcode,\n            //  which means that they will usually be wrong for BIT n, (HL).\n            flags.Y = ((bit_number === 5) && !flags.Z) ? 1 : 0;\n            flags.X = ((bit_number === 3) && !flags.Z) ? 1 : 0;\n        }\n        else if (opcode < 0xc0) {\n            // RES instructions\n            if (reg_code === 0)\n                b &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 1)\n                c &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 2)\n                d &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 3)\n                e &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 4)\n                h &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 5)\n                l &= (0xff & ~(1 << bit_number));\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    core.mem_read(l | (h << 8)) & ~(1 << bit_number));\n            else if (reg_code === 7)\n                a &= (0xff & ~(1 << bit_number));\n        }\n        else {\n            // SET instructions\n            if (reg_code === 0)\n                b |= (1 << bit_number);\n            else if (reg_code === 1)\n                c |= (1 << bit_number);\n            else if (reg_code === 2)\n                d |= (1 << bit_number);\n            else if (reg_code === 3)\n                e |= (1 << bit_number);\n            else if (reg_code === 4)\n                h |= (1 << bit_number);\n            else if (reg_code === 5)\n                l |= (1 << bit_number);\n            else if (reg_code === 6)\n                core.mem_write(l | (h << 8),\n                    core.mem_read(l | (h << 8)) | (1 << bit_number));\n            else if (reg_code === 7)\n                a |= (1 << bit_number);\n        }\n\n        cycle_counter += cycle_counts_cb[opcode];\n    };\n    // 0xcc : CALL Z, nn\n    instructions[0xcc] = function () {\n        do_conditional_call(!!flags.Z);\n    };\n    // 0xcd : CALL nn\n    instructions[0xcd] = function () {\n        push_word((pc + 3) & 0xffff);\n        pc = core.mem_read((pc + 1) & 0xffff) |\n            (core.mem_read((pc + 2) & 0xffff) << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xce : ADC A, n\n    instructions[0xce] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_adc(core.mem_read(pc));\n    };\n    // 0xcf : RST 08h\n    instructions[0xcf] = function () {\n        do_reset(0x08);\n    };\n    // 0xd0 : RET NC\n    instructions[0xd0] = function () {\n        do_conditional_return(!flags.C);\n    };\n    // 0xd1 : POP DE\n    instructions[0xd1] = function () {\n        var result = pop_word();\n        e = result & 0xff;\n        d = (result & 0xff00) >>> 8;\n    };\n    // 0xd2 : JP NC, nn\n    instructions[0xd2] = function () {\n        do_conditional_absolute_jump(!flags.C);\n    };\n    // 0xd3 : OUT (n), A\n    instructions[0xd3] = function () {\n        pc = (pc + 1) & 0xffff;\n        core.io_write((a << 8) | core.mem_read(pc), a);\n    };\n    // 0xd4 : CALL NC, nn\n    instructions[0xd4] = function () {\n        do_conditional_call(!flags.C);\n    };\n    // 0xd5 : PUSH DE\n    instructions[0xd5] = function () {\n        push_word(e | (d << 8));\n    };\n    // 0xd6 : SUB n\n    instructions[0xd6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_sub(core.mem_read(pc));\n    };\n    // 0xd7 : RST 10h\n    instructions[0xd7] = function () {\n        do_reset(0x10);\n    };\n    // 0xd8 : RET C\n    instructions[0xd8] = function () {\n        do_conditional_return(!!flags.C);\n    };\n    // 0xd9 : EXX\n    instructions[0xd9] = function () {\n        var temp = b;\n        b = b_prime;\n        b_prime = temp;\n        temp = c;\n        c = c_prime;\n        c_prime = temp;\n        temp = d;\n        d = d_prime;\n        d_prime = temp;\n        temp = e;\n        e = e_prime;\n        e_prime = temp;\n        temp = h;\n        h = h_prime;\n        h_prime = temp;\n        temp = l;\n        l = l_prime;\n        l_prime = temp;\n    };\n    // 0xda : JP C, nn\n    instructions[0xda] = function () {\n        do_conditional_absolute_jump(!!flags.C);\n    };\n    // 0xdb : IN A, (n)\n    instructions[0xdb] = function () {\n        pc = (pc + 1) & 0xffff;\n        a = core.io_read((a << 8) | core.mem_read(pc));\n    };\n    // 0xdc : CALL C, nn\n    instructions[0xdc] = function () {\n        do_conditional_call(!!flags.C);\n    };\n    // 0xdd : DD Prefix (IX instructions)\n    instructions[0xdd] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = dd_instructions[opcode];\n\n        if (func) {\n            //func = func.bind(this);\n            func();\n            cycle_counter += cycle_counts_dd[opcode];\n        }\n        else {\n            // Apparently if a DD opcode doesn't exist,\n            //  it gets treated as an unprefixed opcode.\n            // What we'll do to handle that is just back up the\n            //  program counter, so that this byte gets decoded\n            //  as a normal instruction.\n            pc = (pc - 1) & 0xffff;\n            // And we'll add in the cycle count for a NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xde : SBC n\n    instructions[0xde] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_sbc(core.mem_read(pc));\n    };\n    // 0xdf : RST 18h\n    instructions[0xdf] = function () {\n        do_reset(0x18);\n    };\n    // 0xe0 : RET PO\n    instructions[0xe0] = function () {\n        do_conditional_return(!flags.P);\n    };\n    // 0xe1 : POP HL\n    instructions[0xe1] = function () {\n        var result = pop_word();\n        l = result & 0xff;\n        h = (result & 0xff00) >>> 8;\n    };\n    // 0xe2 : JP PO, (nn)\n    instructions[0xe2] = function () {\n        do_conditional_absolute_jump(!flags.P);\n    };\n    // 0xe3 : EX (SP), HL\n    instructions[0xe3] = function () {\n        var temp = core.mem_read(sp);\n        core.mem_write(sp, l);\n        l = temp;\n        temp = core.mem_read((sp + 1) & 0xffff);\n        core.mem_write((sp + 1) & 0xffff, h);\n        h = temp;\n    };\n    // 0xe4 : CALL PO, nn\n    instructions[0xe4] = function () {\n        do_conditional_call(!flags.P);\n    };\n    // 0xe5 : PUSH HL\n    instructions[0xe5] = function () {\n        push_word(l | (h << 8));\n    };\n    // 0xe6 : AND n\n    instructions[0xe6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_and(core.mem_read(pc));\n    };\n    // 0xe7 : RST 20h\n    instructions[0xe7] = function () {\n        do_reset(0x20);\n    };\n    // 0xe8 : RET PE\n    instructions[0xe8] = function () {\n        do_conditional_return(!!flags.P);\n    };\n    // 0xe9 : JP (HL)\n    instructions[0xe9] = function () {\n        pc = l | (h << 8);\n        pc = (pc - 1) & 0xffff;\n    };\n    // 0xea : JP PE, nn\n    instructions[0xea] = function () {\n        do_conditional_absolute_jump(!!flags.P);\n    };\n    // 0xeb : EX DE, HL\n    instructions[0xeb] = function () {\n        var temp = d;\n        d = h;\n        h = temp;\n        temp = e;\n        e = l;\n        l = temp;\n    };\n    // 0xec : CALL PE, nn\n    instructions[0xec] = function () {\n        do_conditional_call(!!flags.P);\n    };\n    // 0xed : ED Prefix\n    instructions[0xed] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = ed_instructions[opcode];\n\n        if (func) {\n            //func = func.bind(this);\n            func();\n            cycle_counter += cycle_counts_ed[opcode];\n        }\n        else {\n            // If the opcode didn't exist, the whole thing is a two-byte NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xee : XOR n\n    instructions[0xee] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_xor(core.mem_read(pc));\n    };\n    // 0xef : RST 28h\n    instructions[0xef] = function () {\n        do_reset(0x28);\n    };\n    // 0xf0 : RET P\n    instructions[0xf0] = function () {\n        do_conditional_return(!flags.S);\n    };\n    // 0xf1 : POP AF\n    instructions[0xf1] = function () {\n        var result = pop_word();\n        set_flags_register(result & 0xff);\n        a = (result & 0xff00) >>> 8;\n    };\n    // 0xf2 : JP P, nn\n    instructions[0xf2] = function () {\n        do_conditional_absolute_jump(!flags.S);\n    };\n    // 0xf3 : DI\n    instructions[0xf3] = function () {\n        // DI doesn't actually take effect until after the next instruction.\n        do_delayed_di = true;\n    };\n    // 0xf4 : CALL P, nn\n    instructions[0xf4] = function () {\n        do_conditional_call(!flags.S);\n    };\n    // 0xf5 : PUSH AF\n    instructions[0xf5] = function () {\n        push_word(get_flags_register() | (a << 8));\n    };\n    // 0xf6 : OR n\n    instructions[0xf6] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_or(core.mem_read(pc));\n    };\n    // 0xf7 : RST 30h\n    instructions[0xf7] = function () {\n        do_reset(0x30);\n    };\n    // 0xf8 : RET M\n    instructions[0xf8] = function () {\n        do_conditional_return(!!flags.S);\n    };\n    // 0xf9 : LD SP, HL\n    instructions[0xf9] = function () {\n        sp = l | (h << 8);\n    };\n    // 0xfa : JP M, nn\n    instructions[0xfa] = function () {\n        do_conditional_absolute_jump(!!flags.S);\n    };\n    // 0xfb : EI\n    instructions[0xfb] = function () {\n        // EI doesn't actually take effect until after the next instruction.\n        do_delayed_ei = true;\n    };\n    // 0xfc : CALL M, nn\n    instructions[0xfc] = function () {\n        do_conditional_call(!!flags.S);\n    };\n    // 0xfd : FD Prefix (IY instructions)\n    instructions[0xfd] = function () {\n        // R is incremented at the start of the second instruction cycle,\n        //  before the instruction actually runs.\n        // The high bit of R is not affected by this increment,\n        //  it can only be changed using the LD R, A instruction.\n        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);\n\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc),\n            func = dd_instructions[opcode];\n\n        if (func) {\n            // Rather than copy and paste all the IX instructions into IY instructions,\n            //  what we'll do is sneakily copy IY into IX, run the IX instruction,\n            //  and then copy the result into IY and restore the old IX.\n            var temp = ix;\n            ix = iy;\n            //func = func.bind(this);\n            func();\n            iy = ix;\n            ix = temp;\n\n            cycle_counter += cycle_counts_dd[opcode];\n        }\n        else {\n            // Apparently if an FD opcode doesn't exist,\n            //  it gets treated as an unprefixed opcode.\n            // What we'll do to handle that is just back up the\n            //  program counter, so that this byte gets decoded\n            //  as a normal instruction.\n            pc = (pc - 1) & 0xffff;\n            // And we'll add in the cycle count for a NOP.\n            cycle_counter += cycle_counts[0];\n        }\n    };\n    // 0xfe : CP n\n    instructions[0xfe] = function () {\n        pc = (pc + 1) & 0xffff;\n        do_cp(core.mem_read(pc));\n    };\n    // 0xff : RST 38h\n    instructions[0xff] = function () {\n        do_reset(0x38);\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// This table of ED opcodes is pretty sparse;\n    ///  there are not very many valid ED-prefixed opcodes in the Z80,\n    ///  and many of the ones that are valid are not documented.\n    ///////////////////////////////////////////////////////////////////////////////\n    let ed_instructions:any[] = [];\n    // 0x40 : IN B, (C)\n    ed_instructions[0x40] = function () {\n        b = do_in((b << 8) | c);\n    };\n    // 0x41 : OUT (C), B\n    ed_instructions[0x41] = function () {\n        core.io_write((b << 8) | c, b);\n    };\n    // 0x42 : SBC HL, BC\n    ed_instructions[0x42] = function () {\n        do_hl_sbc(c | (b << 8));\n    };\n    // 0x43 : LD (nn), BC\n    ed_instructions[0x43] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, c);\n        core.mem_write((address + 1) & 0xffff, b);\n    };\n    // 0x44 : NEG\n    ed_instructions[0x44] = function () {\n        do_neg();\n    };\n    // 0x45 : RETN\n    ed_instructions[0x45] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x46 : IM 0\n    ed_instructions[0x46] = function () {\n        imode = 0;\n    };\n    // 0x47 : LD I, A\n    ed_instructions[0x47] = function () {\n        i = a\n    };\n    // 0x48 : IN C, (C)\n    ed_instructions[0x48] = function () {\n        c = do_in((b << 8) | c);\n    };\n    // 0x49 : OUT (C), C\n    ed_instructions[0x49] = function () {\n        core.io_write((b << 8) | c, c);\n    };\n    // 0x4a : ADC HL, BC\n    ed_instructions[0x4a] = function () {\n        do_hl_adc(c | (b << 8));\n    };\n    // 0x4b : LD BC, (nn)\n    ed_instructions[0x4b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        c = core.mem_read(address);\n        b = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x4c : NEG (Undocumented)\n    ed_instructions[0x4c] = function () {\n        do_neg();\n    };\n    // 0x4d : RETI\n    ed_instructions[0x4d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n    };\n    // 0x4e : IM 0 (Undocumented)\n    ed_instructions[0x4e] = function () {\n        imode = 0;\n    };\n    // 0x4f : LD R, A\n    ed_instructions[0x4f] = function () {\n        r = a;\n    };\n    // 0x50 : IN D, (C)\n    ed_instructions[0x50] = function () {\n        d = do_in((b << 8) | c);\n    };\n    // 0x51 : OUT (C), D\n    ed_instructions[0x51] = function () {\n        core.io_write((b << 8) | c, d);\n    };\n    // 0x52 : SBC HL, DE\n    ed_instructions[0x52] = function () {\n        do_hl_sbc(e | (d << 8));\n    };\n    // 0x53 : LD (nn), DE\n    ed_instructions[0x53] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, e);\n        core.mem_write((address + 1) & 0xffff, d);\n    };\n    // 0x54 : NEG (Undocumented)\n    ed_instructions[0x54] = function () {\n        do_neg();\n    };\n    // 0x55 : RETN\n    ed_instructions[0x55] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x56 : IM 1\n    ed_instructions[0x56] = function () {\n        imode = 1;\n    };\n    // 0x57 : LD A, I\n    ed_instructions[0x57] = function () {\n        a = i;\n        flags.S = i & 0x80 ? 1 : 0;\n        flags.Z = i ? 0 : 1;\n        flags.H = 0;\n        flags.P = iff2;\n        flags.N = 0;\n    };\n    // 0x58 : IN E, (C)\n    ed_instructions[0x58] = function () {\n        e = do_in((b << 8) | c);\n    };\n    // 0x59 : OUT (C), E\n    ed_instructions[0x59] = function () {\n        core.io_write((b << 8) | c, e);\n    };\n    // 0x5a : ADC HL, DE\n    ed_instructions[0x5a] = function () {\n        do_hl_adc(e | (d << 8));\n    };\n    // 0x5b : LD DE, (nn)\n    ed_instructions[0x5b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        e = core.mem_read(address);\n        d = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x5c : NEG (Undocumented)\n    ed_instructions[0x5c] = function () {\n        do_neg();\n    };\n    // 0x5d : RETN\n    ed_instructions[0x5d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x5e : IM 2\n    ed_instructions[0x5e] = function () {\n        imode = 2;\n    };\n    // 0x5f : LD A, R\n    ed_instructions[0x5f] = function () {\n        a = r;\n        flags.P = iff2;\n    };\n    // 0x60 : IN H, (C)\n    ed_instructions[0x60] = function () {\n        h = do_in((b << 8) | c);\n    };\n    // 0x61 : OUT (C), H\n    ed_instructions[0x61] = function () {\n        core.io_write((b << 8) | c, h);\n    };\n    // 0x62 : SBC HL, HL\n    ed_instructions[0x62] = function () {\n        do_hl_sbc(l | (h << 8));\n    };\n    // 0x63 : LD (nn), HL (Undocumented)\n    ed_instructions[0x63] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, l);\n        core.mem_write((address + 1) & 0xffff, h);\n    };\n    // 0x64 : NEG (Undocumented)\n    ed_instructions[0x64] = function () {\n        do_neg();\n    };\n    // 0x65 : RETN\n    ed_instructions[0x65] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x66 : IM 0\n    ed_instructions[0x66] = function () {\n        imode = 0;\n    };\n    // 0x67 : RRD\n    ed_instructions[0x67] = function () {\n        var hl_value = core.mem_read(l | (h << 8));\n        var temp1 = hl_value & 0x0f, temp2 = a & 0x0f;\n        hl_value = ((hl_value & 0xf0) >>> 4) | (temp2 << 4);\n        a = (a & 0xf0) | temp1;\n        core.mem_write(l | (h << 8), hl_value);\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = a ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(a) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(a);\n    };\n    // 0x68 : IN L, (C)\n    ed_instructions[0x68] = function () {\n        l = do_in((b << 8) | c);\n    };\n    // 0x69 : OUT (C), L\n    ed_instructions[0x69] = function () {\n        core.io_write((b << 8) | c, l);\n    };\n    // 0x6a : ADC HL, HL\n    ed_instructions[0x6a] = function () {\n        do_hl_adc(l | (h << 8));\n    };\n    // 0x6b : LD HL, (nn) (Undocumented)\n    ed_instructions[0x6b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        l = core.mem_read(address);\n        h = core.mem_read((address + 1) & 0xffff);\n    };\n    // 0x6c : NEG (Undocumented)\n    ed_instructions[0x6c] = function () {\n        do_neg();\n    };\n    // 0x6d : RETN\n    ed_instructions[0x6d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x6e : IM 0 (Undocumented)\n    ed_instructions[0x6e] = function () {\n        imode = 0;\n    };\n    // 0x6f : RLD\n    ed_instructions[0x6f] = function () {\n        var hl_value = core.mem_read(l | (h << 8));\n        var temp1 = hl_value & 0xf0, temp2 = a & 0x0f;\n        hl_value = ((hl_value & 0x0f) << 4) | temp2;\n        a = (a & 0xf0) | (temp1 >>> 4);\n        core.mem_write(l | (h << 8), hl_value);\n\n        flags.S = (a & 0x80) ? 1 : 0;\n        flags.Z = a ? 0 : 1;\n        flags.H = 0;\n        flags.P = get_parity(a) ? 1 : 0;\n        flags.N = 0;\n        update_xy_flags(a);\n    };\n    // 0x70 : IN (C) (Undocumented)\n    ed_instructions[0x70] = function () {\n        do_in((b << 8) | c);\n    };\n    // 0x71 : OUT (C), 0 (Undocumented)\n    ed_instructions[0x71] = function () {\n        core.io_write((b << 8) | c, 0);\n    };\n    // 0x72 : SBC HL, SP\n    ed_instructions[0x72] = function () {\n        do_hl_sbc(sp);\n    };\n    // 0x73 : LD (nn), SP\n    ed_instructions[0x73] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        core.mem_write(address, sp & 0xff);\n        core.mem_write((address + 1) & 0xffff, (sp >>> 8) & 0xff);\n    };\n    // 0x74 : NEG (Undocumented)\n    ed_instructions[0x74] = function () {\n        do_neg();\n    };\n    // 0x75 : RETN\n    ed_instructions[0x75] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x76 : IM 1\n    ed_instructions[0x76] = function () {\n        imode = 1;\n    };\n    // 0x78 : IN A, (C)\n    ed_instructions[0x78] = function () {\n        a = do_in((b << 8) | c);\n    };\n    // 0x79 : OUT (C), A\n    ed_instructions[0x79] = function () {\n        core.io_write((b << 8) | c, a);\n    };\n    // 0x7a : ADC HL, SP\n    ed_instructions[0x7a] = function () {\n        do_hl_adc(sp);\n    };\n    // 0x7b : LD SP, (nn)\n    ed_instructions[0x7b] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= core.mem_read(pc) << 8;\n\n        sp = core.mem_read(address);\n        sp |= core.mem_read((address + 1) & 0xffff) << 8;\n    };\n    // 0x7c : NEG (Undocumented)\n    ed_instructions[0x7c] = function () {\n        do_neg();\n    };\n    // 0x7d : RETN\n    ed_instructions[0x7d] = function () {\n        pc = (pop_word() - 1) & 0xffff;\n        iff1 = iff2;\n    };\n    // 0x7e : IM 2\n    ed_instructions[0x7e] = function () {\n        imode = 2;\n    };\n    // 0xa0 : LDI\n    ed_instructions[0xa0] = function () {\n        do_ldi();\n    };\n    // 0xa1 : CPI\n    ed_instructions[0xa1] = function () {\n        do_cpi();\n    };\n    // 0xa2 : INI\n    ed_instructions[0xa2] = function () {\n        do_ini();\n    };\n    // 0xa3 : OUTI\n    ed_instructions[0xa3] = function () {\n        do_outi();\n    };\n    // 0xa8 : LDD\n    ed_instructions[0xa8] = function () {\n        do_ldd();\n    };\n    // 0xa9 : CPD\n    ed_instructions[0xa9] = function () {\n        do_cpd();\n    };\n    // 0xaa : IND\n    ed_instructions[0xaa] = function () {\n        do_ind();\n    };\n    // 0xab : OUTD\n    ed_instructions[0xab] = function () {\n        do_outd();\n    };\n    // 0xb0 : LDIR\n    ed_instructions[0xb0] = function () {\n        do_ldi();\n        if (b || c) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb1 : CPIR\n    ed_instructions[0xb1] = function () {\n        do_cpi();\n        if (!flags.Z && (b || c)) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb2 : INIR\n    ed_instructions[0xb2] = function () {\n        do_ini();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb3 : OTIR\n    ed_instructions[0xb3] = function () {\n        do_outi();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb8 : LDDR\n    ed_instructions[0xb8] = function () {\n        do_ldd();\n        if (b || c) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xb9 : CPDR\n    ed_instructions[0xb9] = function () {\n        do_cpd();\n        if (!flags.Z && (b || c)) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xba : INDR\n    ed_instructions[0xba] = function () {\n        do_ind();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n    // 0xbb : OTDR\n    ed_instructions[0xbb] = function () {\n        do_outd();\n        if (b) {\n            cycle_counter += 5;\n            pc = (pc - 2) & 0xffff;\n        }\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// Like ED, this table is quite sparse,\n    ///  and many of the opcodes here are also undocumented.\n    /// The undocumented instructions here are those that deal with only one byte\n    ///  of the two-byte IX register; the bytes are designed IXH and IXL here.\n    ///////////////////////////////////////////////////////////////////////////////\n    let dd_instructions: (() => void)[] = [];\n    // 0x09 : ADD IX, BC\n    dd_instructions[0x09] = function () {\n        do_ix_add(c | (b << 8));\n    };\n    // 0x19 : ADD IX, DE\n    dd_instructions[0x19] = function () {\n        do_ix_add(e | (d << 8));\n    };\n    // 0x21 : LD IX, nn\n    dd_instructions[0x21] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        ix |= (core.mem_read(pc) << 8);\n    };\n    // 0x22 : LD (nn), IX\n    dd_instructions[0x22] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= (core.mem_read(pc) << 8);\n\n        core.mem_write(address, ix & 0xff);\n        core.mem_write((address + 1) & 0xffff, (ix >>> 8) & 0xff);\n    };\n    // 0x23 : INC IX\n    dd_instructions[0x23] = function () {\n        ix = (ix + 1) & 0xffff;\n    };\n    // 0x24 : INC IXH (Undocumented)\n    dd_instructions[0x24] = function () {\n        ix = (do_inc(ix >>> 8) << 8) | (ix & 0xff);\n    };\n    // 0x25 : DEC IXH (Undocumented)\n    dd_instructions[0x25] = function () {\n        ix = (do_dec(ix >>> 8) << 8) | (ix & 0xff);\n    };\n    // 0x26 : LD IXH, n (Undocumented)\n    dd_instructions[0x26] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = (core.mem_read(pc) << 8) | (ix & 0xff);\n    };\n    // 0x29 : ADD IX, IX\n    dd_instructions[0x29] = function () {\n        do_ix_add(ix);\n    };\n    // 0x2a : LD IX, (nn)\n    dd_instructions[0x2a] = function () {\n        pc = (pc + 1) & 0xffff;\n        var address = core.mem_read(pc);\n        pc = (pc + 1) & 0xffff;\n        address |= (core.mem_read(pc) << 8);\n\n        ix = core.mem_read(address);\n        ix |= (core.mem_read((address + 1) & 0xffff) << 8);\n    };\n    // 0x2b : DEC IX\n    dd_instructions[0x2b] = function () {\n        ix = (ix - 1) & 0xffff;\n    };\n    // 0x2c : INC IXL (Undocumented)\n    dd_instructions[0x2c] = function () {\n        ix = do_inc(ix & 0xff) | (ix & 0xff00);\n    };\n    // 0x2d : DEC IXL (Undocumented)\n    dd_instructions[0x2d] = function () {\n        ix = do_dec(ix & 0xff) | (ix & 0xff00);\n    };\n    // 0x2e : LD IXL, n (Undocumented)\n    dd_instructions[0x2e] = function () {\n        pc = (pc + 1) & 0xffff;\n        ix = (core.mem_read(pc) & 0xff) | (ix & 0xff00);\n    };\n    // 0x34 : INC (IX+n)\n    dd_instructions[0x34] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc)),\n            value = core.mem_read((offset + ix) & 0xffff);\n        core.mem_write((offset + ix) & 0xffff, do_inc(value));\n    };\n    // 0x35 : DEC (IX+n)\n    dd_instructions[0x35] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc)),\n            value = core.mem_read((offset + ix) & 0xffff);\n        core.mem_write((offset + ix) & 0xffff, do_dec(value));\n    };\n    // 0x36 : LD (IX+n), n\n    dd_instructions[0x36] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        pc = (pc + 1) & 0xffff;\n        core.mem_write((ix + offset) & 0xffff, core.mem_read(pc));\n    };\n    // 0x39 : ADD IX, SP\n    dd_instructions[0x39] = function () {\n        do_ix_add(sp);\n    };\n    // 0x44 : LD B, IXH (Undocumented)\n    dd_instructions[0x44] = function () {\n        b = (ix >>> 8) & 0xff;\n    };\n    // 0x45 : LD B, IXL (Undocumented)\n    dd_instructions[0x45] = function () {\n        b = ix & 0xff;\n    };\n    // 0x46 : LD B, (IX+n)\n    dd_instructions[0x46] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        b = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x4c : LD C, IXH (Undocumented)\n    dd_instructions[0x4c] = function () {\n        c = (ix >>> 8) & 0xff;\n    };\n    // 0x4d : LD C, IXL (Undocumented)\n    dd_instructions[0x4d] = function () {\n        c = ix & 0xff;\n    };\n    // 0x4e : LD C, (IX+n)\n    dd_instructions[0x4e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        c = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x54 : LD D, IXH (Undocumented)\n    dd_instructions[0x54] = function () {\n        d = (ix >>> 8) & 0xff;\n    };\n    // 0x55 : LD D, IXL (Undocumented)\n    dd_instructions[0x55] = function () {\n        d = ix & 0xff;\n    };\n    // 0x56 : LD D, (IX+n)\n    dd_instructions[0x56] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        d = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x5c : LD E, IXH (Undocumented)\n    dd_instructions[0x5c] = function () {\n        e = (ix >>> 8) & 0xff;\n    };\n    // 0x5d : LD E, IXL (Undocumented)\n    dd_instructions[0x5d] = function () {\n        e = ix & 0xff;\n    };\n    // 0x5e : LD E, (IX+n)\n    dd_instructions[0x5e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        e = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x60 : LD IXH, B (Undocumented)\n    dd_instructions[0x60] = function () {\n        ix = (ix & 0xff) | (b << 8);\n    };\n    // 0x61 : LD IXH, C (Undocumented)\n    dd_instructions[0x61] = function () {\n        ix = (ix & 0xff) | (c << 8);\n    };\n    // 0x62 : LD IXH, D (Undocumented)\n    dd_instructions[0x62] = function () {\n        ix = (ix & 0xff) | (d << 8);\n    };\n    // 0x63 : LD IXH, E (Undocumented)\n    dd_instructions[0x63] = function () {\n        ix = (ix & 0xff) | (e << 8);\n    };\n    // 0x64 : LD IXH, IXH (Undocumented)\n    dd_instructions[0x64] = function () {\n        // No-op.\n    };\n    // 0x65 : LD IXH, IXL (Undocumented)\n    dd_instructions[0x65] = function () {\n        ix = (ix & 0xff) | ((ix & 0xff) << 8);\n    };\n    // 0x66 : LD H, (IX+n)\n    dd_instructions[0x66] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        h = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x67 : LD IXH, A (Undocumented)\n    dd_instructions[0x67] = function () {\n        ix = (ix & 0xff) | (a << 8);\n    };\n    // 0x68 : LD IXL, B (Undocumented)\n    dd_instructions[0x68] = function () {\n        ix = (ix & 0xff00) | b;\n    };\n    // 0x69 : LD IXL, C (Undocumented)\n    dd_instructions[0x69] = function () {\n        ix = (ix & 0xff00) | c;\n    };\n    // 0x6a : LD IXL, D (Undocumented)\n    dd_instructions[0x6a] = function () {\n        ix = (ix & 0xff00) | d;\n    };\n    // 0x6b : LD IXL, E (Undocumented)\n    dd_instructions[0x6b] = function () {\n        ix = (ix & 0xff00) | e;\n    };\n    // 0x6c : LD IXL, IXH (Undocumented)\n    dd_instructions[0x6c] = function () {\n        ix = (ix & 0xff00) | (ix >>> 8);\n    };\n    // 0x6d : LD IXL, IXL (Undocumented)\n    dd_instructions[0x6d] = function () {\n        // No-op.\n    };\n    // 0x6e : LD L, (IX+n)\n    dd_instructions[0x6e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        l = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x6f : LD IXL, A (Undocumented)\n    dd_instructions[0x6f] = function () {\n        ix = (ix & 0xff00) | a;\n    };\n    // 0x70 : LD (IX+n), B\n    dd_instructions[0x70] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, b);\n    };\n    // 0x71 : LD (IX+n), C\n    dd_instructions[0x71] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, c);\n    };\n    // 0x72 : LD (IX+n), D\n    dd_instructions[0x72] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, d);\n    };\n    // 0x73 : LD (IX+n), E\n    dd_instructions[0x73] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, e);\n    };\n    // 0x74 : LD (IX+n), H\n    dd_instructions[0x74] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, h);\n    };\n    // 0x75 : LD (IX+n), L\n    dd_instructions[0x75] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, l);\n    };\n    // 0x77 : LD (IX+n), A\n    dd_instructions[0x77] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        core.mem_write((ix + offset) & 0xffff, a);\n    };\n    // 0x7c : LD A, IXH (Undocumented)\n    dd_instructions[0x7c] = function () {\n        a = (ix >>> 8) & 0xff;\n    };\n    // 0x7d : LD A, IXL (Undocumented)\n    dd_instructions[0x7d] = function () {\n        a = ix & 0xff;\n    };\n    // 0x7e : LD A, (IX+n)\n    dd_instructions[0x7e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        a = core.mem_read((ix + offset) & 0xffff);\n    };\n    // 0x84 : ADD A, IXH (Undocumented)\n    dd_instructions[0x84] = function () {\n        do_add((ix >>> 8) & 0xff);\n    };\n    // 0x85 : ADD A, IXL (Undocumented)\n    dd_instructions[0x85] = function () {\n        do_add(ix & 0xff);\n    };\n    // 0x86 : ADD A, (IX+n)\n    dd_instructions[0x86] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_add(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x8c : ADC A, IXH (Undocumented)\n    dd_instructions[0x8c] = function () {\n        do_adc((ix >>> 8) & 0xff);\n    };\n    // 0x8d : ADC A, IXL (Undocumented)\n    dd_instructions[0x8d] = function () {\n        do_adc(ix & 0xff);\n    };\n    // 0x8e : ADC A, (IX+n)\n    dd_instructions[0x8e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_adc(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x94 : SUB IXH (Undocumented)\n    dd_instructions[0x94] = function () {\n        do_sub((ix >>> 8) & 0xff);\n    };\n    // 0x95 : SUB IXL (Undocumented)\n    dd_instructions[0x95] = function () {\n        do_sub(ix & 0xff);\n    };\n    // 0x96 : SUB A, (IX+n)\n    dd_instructions[0x96] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_sub(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0x9c : SBC IXH (Undocumented)\n    dd_instructions[0x9c] = function () {\n        do_sbc((ix >>> 8) & 0xff);\n    };\n    // 0x9d : SBC IXL (Undocumented)\n    dd_instructions[0x9d] = function () {\n        do_sbc(ix & 0xff);\n    };\n    // 0x9e : SBC A, (IX+n)\n    dd_instructions[0x9e] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_sbc(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xa4 : AND IXH (Undocumented)\n    dd_instructions[0xa4] = function () {\n        do_and((ix >>> 8) & 0xff);\n    };\n    // 0xa5 : AND IXL (Undocumented)\n    dd_instructions[0xa5] = function () {\n        do_and(ix & 0xff);\n    };\n    // 0xa6 : AND A, (IX+n)\n    dd_instructions[0xa6] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_and(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xac : XOR IXH (Undocumented)\n    dd_instructions[0xac] = function () {\n        do_xor((ix >>> 8) & 0xff);\n    };\n    // 0xad : XOR IXL (Undocumented)\n    dd_instructions[0xad] = function () {\n        do_xor(ix & 0xff);\n    };\n    // 0xae : XOR A, (IX+n)\n    dd_instructions[0xae] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_xor(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xb4 : OR IXH (Undocumented)\n    dd_instructions[0xb4] = function () {\n        do_or((ix >>> 8) & 0xff);\n    };\n    // 0xb5 : OR IXL (Undocumented)\n    dd_instructions[0xb5] = function () {\n        do_or(ix & 0xff);\n    };\n    // 0xb6 : OR A, (IX+n)\n    dd_instructions[0xb6] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_or(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xbc : CP IXH (Undocumented)\n    dd_instructions[0xbc] = function () {\n        do_cp((ix >>> 8) & 0xff);\n    };\n    // 0xbd : CP IXL (Undocumented)\n    dd_instructions[0xbd] = function () {\n        do_cp(ix & 0xff);\n    };\n    // 0xbe : CP A, (IX+n)\n    dd_instructions[0xbe] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        do_cp(core.mem_read((ix + offset) & 0xffff));\n    };\n    // 0xcb : CB Prefix (IX bit instructions)\n    dd_instructions[0xcb] = function () {\n        pc = (pc + 1) & 0xffff;\n        var offset = get_signed_offset_byte(core.mem_read(pc));\n        pc = (pc + 1) & 0xffff;\n        var opcode = core.mem_read(pc), value;\n\n        // As with the \"normal\" CB prefix, we implement the DDCB prefix\n        //  by decoding the opcode directly, rather than using a table.\n        if (opcode < 0x40) {\n            // Shift and rotate instructions.\n            var ddcb_functions = [do_rlc, do_rrc, do_rl, do_rr,\n                do_sla, do_sra, do_sll, do_srl];\n\n            // Most of the opcodes in this range are not valid,\n            //  so we map this opcode onto one of the ones that is.\n            var func = ddcb_functions[(opcode & 0x38) >>> 3];\n            value = func(core.mem_read((ix + offset) & 0xffff));\n\n            core.mem_write((ix + offset) & 0xffff, value);\n        }\n        else {\n            var bit_number = (opcode & 0x38) >>> 3;\n\n            if (opcode < 0x80) {\n                // BIT\n                flags.N = 0;\n                flags.H = 1;\n                flags.Z = !(core.mem_read((ix + offset) & 0xffff) & (1 << bit_number)) ? 1 : 0;\n                flags.P = flags.Z;\n                flags.S = ((bit_number === 7) && !flags.Z) ? 1 : 0;\n            }\n            else if (opcode < 0xc0) {\n                // RES\n                value = core.mem_read((ix + offset) & 0xffff) & ~(1 << bit_number) & 0xff;\n                core.mem_write((ix + offset) & 0xffff, value);\n            }\n            else {\n                // SET\n                value = core.mem_read((ix + offset) & 0xffff) | (1 << bit_number);\n                core.mem_write((ix + offset) & 0xffff, value);\n            }\n        }\n\n        // This implements the undocumented shift, RES, and SET opcodes,\n        //  which write their result to memory and also to an 8080 register.\n        if (value !== undefined) {\n            if ((opcode & 0x07) === 0)\n                b = value;\n            else if ((opcode & 0x07) === 1)\n                c = value;\n            else if ((opcode & 0x07) === 2)\n                d = value;\n            else if ((opcode & 0x07) === 3)\n                e = value;\n            else if ((opcode & 0x07) === 4)\n                h = value;\n            else if ((opcode & 0x07) === 5)\n                l = value;\n            // 6 is the documented opcode, which doesn't set a register.\n            else if ((opcode & 0x07) === 7)\n                a = value;\n        }\n\n        cycle_counter += cycle_counts_cb[opcode] + 8;\n    };\n    // 0xe1 : POP IX\n    dd_instructions[0xe1] = function () {\n        ix = pop_word();\n    };\n    // 0xe3 : EX (SP), IX\n    dd_instructions[0xe3] = function () {\n        var temp = ix;\n        ix = core.mem_read(sp);\n        ix |= core.mem_read((sp + 1) & 0xffff) << 8;\n        core.mem_write(sp, temp & 0xff);\n        core.mem_write((sp + 1) & 0xffff, (temp >>> 8) & 0xff);\n    };\n    // 0xe5 : PUSH IX\n    dd_instructions[0xe5] = function () {\n        push_word(ix);\n    };\n    // 0xe9 : JP (IX)\n    dd_instructions[0xe9] = function () {\n        pc = (ix - 1) & 0xffff;\n    };\n    // 0xf9 : LD SP, IX\n    dd_instructions[0xf9] = function () {\n        sp = ix;\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    /// These tables contain the number of T cycles used for each instruction.\n    /// In a few special cases, such as conditional control flow instructions,\n    ///  additional cycles might be added to these values.\n    /// The total number of cycles is the return value of run_instruction().\n    ///////////////////////////////////////////////////////////////////////////////\n    let cycle_counts = [\n        4, 10, 7, 6, 4, 4, 7, 4, 4, 11, 7, 6, 4, 4, 7, 4,\n        8, 10, 7, 6, 4, 4, 7, 4, 12, 11, 7, 6, 4, 4, 7, 4,\n        7, 10, 16, 6, 4, 4, 7, 4, 7, 11, 16, 6, 4, 4, 7, 4,\n        7, 10, 13, 6, 11, 11, 10, 4, 7, 11, 13, 6, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        7, 7, 7, 7, 7, 7, 4, 7, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,\n        5, 10, 10, 10, 10, 11, 7, 11, 5, 10, 10, 0, 10, 17, 7, 11,\n        5, 10, 10, 11, 10, 11, 7, 11, 5, 4, 10, 11, 10, 0, 7, 11,\n        5, 10, 10, 19, 10, 11, 7, 11, 5, 4, 10, 4, 10, 0, 7, 11,\n        5, 10, 10, 4, 10, 11, 7, 11, 5, 6, 10, 4, 10, 0, 7, 11\n    ];\n\n    let cycle_counts_ed = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,\n        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,\n        12, 12, 15, 20, 8, 14, 8, 18, 12, 12, 15, 20, 8, 14, 8, 18,\n        12, 12, 15, 20, 8, 14, 8, 0, 12, 12, 15, 20, 8, 14, 8, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,\n        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n\n    let cycle_counts_cb = [\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,\n        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8\n    ];\n\n    let cycle_counts_dd = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 14, 20, 10, 8, 8, 11, 0, 0, 15, 20, 10, 8, 8, 11, 0,\n        0, 0, 0, 0, 23, 23, 19, 0, 0, 15, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        8, 8, 8, 8, 8, 8, 19, 8, 8, 8, 8, 8, 8, 8, 19, 8,\n        19, 19, 19, 19, 19, 19, 0, 19, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 14, 0, 23, 0, 15, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0\n    ];\n\n    // There's tons of stuff in this object,\n    //  but only these three functions are the public API.\n    return {\n        getState,\n        setState,\n        reset,\n        reset1,\n        run_instruction,\n        interrupt,\n    };\n}","\n/**\n * Parser/writer for the \"Intel hex\" format.\n */\n\n/*\n * A regexp that matches lines in a .hex file.\n *\n * One hexadecimal character is matched by \"[0-9A-Fa-f]\".\n * Two hex characters are matched by \"[0-9A-Fa-f]{2}\"\n * Eight or more hex characters are matched by \"[0-9A-Fa-f]{8,}\"\n * A capture group of two hex characters is \"([0-9A-Fa-f]{2})\"\n *\n * Record mark         :\n * 8 or more hex chars  ([0-9A-Fa-f]{8,})\n * Checksum                              ([0-9A-Fa-f]{2})\n * Optional newline                                      (?:\\r\\n|\\r|\\n|)\n */\nconst hexLineRegexp = /:([0-9A-Fa-f]{8,})([0-9A-Fa-f]{2})(?:\\r\\n|\\r|\\n|)/g;\n\n\n// Takes a Uint8Array as input,\n// Returns an integer in the 0-255 range.\nfunction checksum(bytes) {\n    return (-bytes.reduce((sum, v)=>sum + v, 0)) & 0xFF;\n}\n\n// Takes two Uint8Arrays as input,\n// Returns an integer in the 0-255 range.\nfunction checksumTwo(array1, array2) {\n    const partial1 = array1.reduce((sum, v)=>sum + v, 0);\n    const partial2 = array2.reduce((sum, v)=>sum + v, 0);\n    return -( partial1 + partial2 ) & 0xFF;\n}\n\n\n// Trivial utility. Converts a number to hex and pads with zeroes up to 2 characters.\nfunction hexpad(number) {\n    return number.toString(16).toUpperCase().padStart(2, '0');\n}\n\n\n// Polyfill as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\nNumber.isInteger = Number.isInteger || function(value) {\n    return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\n/**\n * @class MemoryMap\n *\n * Represents the contents of a memory layout, with main focus into (possibly sparse) blocks of data.\n *<br/>\n * A {@linkcode MemoryMap} acts as a subclass of\n * {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|Map}.\n * In every entry of it, the key is the starting address of a data block (an integer number),\n * and the value is the <tt>Uint8Array</tt> with the data for that block.\n *<br/>\n * The main rationale for this is that a .hex file can contain a single block of contiguous\n * data starting at memory address 0 (and it's the common case for simple .hex files),\n * but complex files with several non-contiguous data blocks are also possible, thus\n * the need for a data structure on top of the <tt>Uint8Array</tt>s.\n *<br/>\n * In order to parse <tt>.hex</tt> files, use the {@linkcode MemoryMap.fromHex} <em>static</em> factory\n * method. In order to write <tt>.hex</tt> files, create a new {@linkcode MemoryMap} and call\n * its {@linkcode MemoryMap.asHexString} method.\n *\n * @extends Map\n * @example\n * import MemoryMap from 'nrf-intel-hex';\n *\n * let memMap1 = new MemoryMap();\n * let memMap2 = new MemoryMap([[0, new Uint8Array(1,2,3,4)]]);\n * let memMap3 = new MemoryMap({0: new Uint8Array(1,2,3,4)});\n * let memMap4 = new MemoryMap({0xCF0: new Uint8Array(1,2,3,4)});\n */\nclass MemoryMap {\n    /**\n     * @param {Iterable} blocks The initial value for the memory blocks inside this\n     * <tt>MemoryMap</tt>. All keys must be numeric, and all values must be instances of\n     * <tt>Uint8Array</tt>. Optionally it can also be a plain <tt>Object</tt> with\n     * only numeric keys.\n     */\n    constructor(blocks) {\n        this._blocks = new Map();\n\n        if (blocks && typeof blocks[Symbol.iterator] === 'function') {\n            for (const tuple of blocks) {\n                if (!(tuple instanceof Array) || tuple.length !== 2) {\n                    throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n                }\n                this.set(tuple[0], tuple[1]);\n            }\n        } else if (typeof blocks === 'object') {\n            // Try iterating through the object's keys\n            const addrs = Object.keys(blocks);\n            for (const addr of addrs) {\n                this.set(parseInt(addr), blocks[addr]);\n            }\n\n        } else if (blocks !== undefined && blocks !== null) {\n            throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n        }\n    }\n\n    set(addr, value) {\n        if (!Number.isInteger(addr)) {\n            throw new Error('Address passed to MemoryMap is not an integer');\n        }\n        if (addr < 0) {\n            throw new Error('Address passed to MemoryMap is negative');\n        }\n        if (!(value instanceof Uint8Array)) {\n            throw new Error('Bytes passed to MemoryMap are not an Uint8Array');\n        }\n        return this._blocks.set(addr, value);\n    }\n    // Delegate the following to the 'this._blocks' Map:\n    get(addr)    { return this._blocks.get(addr);    }\n    clear()      { return this._blocks.clear();      }\n    delete(addr) { return this._blocks.delete(addr); }\n    entries()    { return this._blocks.entries();    }\n    forEach(callback, that) { return this._blocks.forEach(callback, that); }\n    has(addr)    { return this._blocks.has(addr);    }\n    keys()       { return this._blocks.keys();       }\n    values()     { return this._blocks.values();     }\n    get size()   { return this._blocks.size;         }\n    [Symbol.iterator]() { return this._blocks[Symbol.iterator](); }\n\n\n    /**\n     * Parses a string containing data formatted in \"Intel HEX\" format, and\n     * returns an instance of {@linkcode MemoryMap}.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * The parser has an opinionated behaviour, and will throw a descriptive error if it\n     * encounters some malformed input. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, any contiguous data block larger than that will\n     * be split in several blocks.\n     *\n     * @param {String} hexText The contents of a .hex file.\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the returned <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let intelHexString =\n     *     \":100000000102030405060708090A0B0C0D0E0F1068\\n\" +\n     *     \":00000001FF\";\n     *\n     * let memMap = MemoryMap.fromHex(intelHexString);\n     *\n     * for (let [address, dataBlock] of memMap) {\n     *     console.log('Data block at ', address, ', bytes: ', dataBlock);\n     * }\n     */\n    static fromHex(hexText, maxBlockSize = Infinity) {\n        const blocks = new MemoryMap();\n\n        let lastCharacterParsed = 0;\n        let matchResult;\n        let recordCount = 0;\n\n        // Upper Linear Base Address, the 16 most significant bits (2 bytes) of\n        // the current 32-bit (4-byte) address\n        // In practice this is a offset that is summed to the \"load offset\" of the\n        // data records\n        let ulba = 0;\n\n        hexLineRegexp.lastIndex = 0; // Reset the regexp, if not it would skip content when called twice\n\n        while ((matchResult = hexLineRegexp.exec(hexText)) !== null) {\n            recordCount++;\n\n            // By default, a regexp loop ignores gaps between matches, but\n            // we want to be aware of them.\n            if (lastCharacterParsed !== matchResult.index) {\n                throw new Error(\n                    'Malformed hex file: Could not parse between characters ' +\n                    lastCharacterParsed +\n                    ' and ' +\n                    matchResult.index +\n                    ' (\"' +\n                    hexText.substring(lastCharacterParsed, Math.min(matchResult.index, lastCharacterParsed + 16)).trim() +\n                    '\")');\n            }\n            lastCharacterParsed = hexLineRegexp.lastIndex;\n\n            // Give pretty names to the match's capture groups\n            const [, recordStr, recordChecksum] = matchResult;\n\n            // String to Uint8Array - https://stackoverflow.com/questions/43131242/how-to-convert-a-hexademical-string-of-data-to-an-arraybuffer-in-javascript\n            const recordBytes = new Uint8Array(recordStr.match(/[\\da-f]{2}/gi).map((h)=>parseInt(h, 16)));\n\n            const recordLength = recordBytes[0];\n            if (recordLength + 4 !== recordBytes.length) {\n                throw new Error('Mismatched record length at record ' + recordCount + ' (' + matchResult[0].trim() + '), expected ' + (recordLength) + ' data bytes but actual length is ' + (recordBytes.length - 4));\n            }\n\n            const cs = checksum(recordBytes);\n            if (parseInt(recordChecksum, 16) !== cs) {\n                throw new Error('Checksum failed at record ' + recordCount + ' (' + matchResult[0].trim() + '), should be ' + cs.toString(16) );\n            }\n\n            const offset = (recordBytes[1] << 8) + recordBytes[2];\n            const recordType = recordBytes[3];\n            const data = recordBytes.subarray(4);\n\n            if (recordType === 0) {\n                // Data record, contains data\n                // Create a new block, at (upper linear base address + offset)\n                if (blocks.has(ulba + offset)) {\n                    throw new Error('Duplicated data at record ' + recordCount + ' (' + matchResult[0].trim() + ')');\n                }\n                if (offset + data.length > 0x10000) {\n                    throw new Error(\n                        'Data at record ' +\n                        recordCount +\n                        ' (' +\n                        matchResult[0].trim() +\n                        ') wraps over 0xFFFF. This would trigger ambiguous behaviour. Please restructure your data so that for every record the data offset plus the data length do not exceed 0xFFFF.');\n                }\n\n                blocks.set( ulba + offset, data );\n\n            } else {\n\n                // All non-data records must have a data offset of zero\n                if (offset !== 0) {\n                    throw new Error('Record ' + recordCount + ' (' + matchResult[0].trim() + ') must have 0000 as data offset.');\n                }\n\n                switch (recordType) {\n                case 1: // EOF\n                    if (lastCharacterParsed !== hexText.length) {\n                        // This record should be at the very end of the string\n                        throw new Error('There is data after an EOF record at record ' + recordCount);\n                    }\n\n                    return blocks.join(maxBlockSize);\n\n                case 2: // Extended Segment Address Record\n                    // Sets the 16 most significant bits of the 20-bit Segment Base\n                    // Address for the subsequent data.\n                    ulba = ((data[0] << 8) + data[1]) << 4;\n                    break;\n\n                case 3: // Start Segment Address Record\n                    // Do nothing. Record type 3 only applies to 16-bit Intel CPUs,\n                    // where it should reset the program counter (CS+IP CPU registers)\n                    break;\n\n                case 4: // Extended Linear Address Record\n                    // Sets the 16 most significant (upper) bits of the 32-bit Linear Address\n                    // for the subsequent data\n                    ulba = ((data[0] << 8) + data[1]) << 16;\n                    break;\n\n                case 5: // Start Linear Address Record\n                    // Do nothing. Record type 5 only applies to 32-bit Intel CPUs,\n                    // where it should reset the program counter (EIP CPU register)\n                    // It might have meaning for other CPU architectures\n                    // (see http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka9903.html )\n                    // but will be ignored nonetheless.\n                    break;\n                default:\n                    throw new Error('Invalid record type 0x' + hexpad(recordType) + ' at record ' + recordCount + ' (should be between 0x00 and 0x05)');\n                }\n            }\n        }\n\n        if (recordCount) {\n            throw new Error('No EOF record at end of file');\n        } else {\n            throw new Error('Malformed .hex file, could not parse any registers');\n        }\n    }\n\n\n    /**\n     * Returns a <strong>new</strong> instance of {@linkcode MemoryMap}, containing\n     * the same data, but concatenating together those memory blocks that are adjacent.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, blocks will be concatenated together only\n     * until the joined block reaches this size in bytes. This means that the output\n     * {@linkcode MemoryMap} might have more entries than the input one.\n     *<br/>\n     * If there is any overlap between blocks, an error will be thrown.\n     *<br/>\n     * The returned {@linkcode MemoryMap} will use newly allocated memory.\n     *\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the <tt>Uint8Array</tt>s in the\n     * returned {@linkcode MemoryMap}.\n     *\n     * @return {MemoryMap}\n     */\n    join(maxBlockSize = Infinity) {\n\n        // First pass, create a Map of address→length of contiguous blocks\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        const blockSizes = new Map();\n        let lastBlockAddr = -1;\n        let lastBlockEndAddr = -1;\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const blockLength = this.get(sortedKeys[i]).length;\n\n            if (lastBlockEndAddr === blockAddr && (lastBlockEndAddr - lastBlockAddr) < maxBlockSize) {\n                // Grow when the previous end address equals the current,\n                // and we don't go over the maximum block size.\n                blockSizes.set(lastBlockAddr, blockSizes.get(lastBlockAddr) + blockLength);\n                lastBlockEndAddr += blockLength;\n            } else if (lastBlockEndAddr <= blockAddr) {\n                // Else mark a new block.\n                blockSizes.set(blockAddr, blockLength);\n                lastBlockAddr = blockAddr;\n                lastBlockEndAddr = blockAddr + blockLength;\n            } else {\n                throw new Error('Overlapping data around address 0x' + blockAddr.toString(16));\n            }\n        }\n\n        // Second pass: allocate memory for the contiguous blocks and copy data around.\n        const mergedBlocks = new MemoryMap();\n        let mergingBlock;\n        let mergingBlockAddr = -1;\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            if (blockSizes.has(blockAddr)) {\n                mergingBlock = new Uint8Array(blockSizes.get(blockAddr));\n                mergedBlocks.set(blockAddr, mergingBlock);\n                mergingBlockAddr = blockAddr;\n            }\n            mergingBlock.set(this.get(blockAddr), blockAddr - mergingBlockAddr);\n        }\n\n        return mergedBlocks;\n    }\n\n    /**\n     * Given a {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|<tt>Map</tt>}\n     * of {@linkcode MemoryMap}s, indexed by a alphanumeric ID,\n     * returns a <tt>Map</tt> of address to tuples (<tt>Arrays</tt>s of length 2) of the form\n     * <tt>(id, Uint8Array)</tt>s.\n     *<br/>\n     * The scenario for using this is having several {@linkcode MemoryMap}s, from several calls to\n     * {@link module:nrf-intel-hex~hexToArrays|hexToArrays}, each having a different identifier.\n     * This function locates where those memory block sets overlap, and returns a <tt>Map</tt>\n     * containing addresses as keys, and arrays as values. Each array will contain 1 or more\n     * <tt>(id, Uint8Array)</tt> tuples: the identifier of the memory block set that has\n     * data in that region, and the data itself. When memory block sets overlap, there will\n     * be more than one tuple.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output are\n     * {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray|subarrays}\n     * of the input data; new memory is <strong>not</strong> allocated for them.\n     *<br/>\n     * The insertion order of keys in the output <tt>Map</tt> is guaranteed to be strictly\n     * ascending. In other words, when iterating through the <tt>Map</tt>, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * When two blocks overlap, the corresponding array of tuples will have the tuples ordered\n     * in the insertion order of the input <tt>Map</tt> of block sets.\n     *<br/>\n     *\n     * @param {Map.MemoryMap} memoryMaps The input memory block sets\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap1 = MemoryMap.fromHex( hexdata1 );\n     * let memMap2 = MemoryMap.fromHex( hexdata2 );\n     * let memMap3 = MemoryMap.fromHex( hexdata3 );\n     *\n     * let maps = new Map([\n     *  ['file A', blocks1],\n     *  ['file B', blocks2],\n     *  ['file C', blocks3]\n     * ]);\n     *\n     * let overlappings = MemoryMap.overlapMemoryMaps(maps);\n     *\n     * for (let [address, tuples] of overlappings) {\n     *     // if 'tuples' has length > 1, there is an overlap starting at 'address'\n     *\n     *     for (let [address, tuples] of overlappings) {\n     *         let [id, bytes] = tuple;\n     *         // 'id' in this example is either 'file A', 'file B' or 'file C'\n     *     }\n     * }\n     * @return {Map.Array<mixed,Uint8Array>} The map of possibly overlapping memory blocks\n     */\n    static overlapMemoryMaps(memoryMaps) {\n        // First pass: create a list of addresses where any block starts or ends.\n        const cuts = new Set();\n        for (const [, blocks] of memoryMaps) {\n            for (const [address, block] of blocks) {\n                cuts.add(address);\n                cuts.add(address + block.length);\n            }\n        }\n\n        const orderedCuts = Array.from(cuts.values()).sort((a,b)=>a-b);\n        const overlaps = new Map();\n\n        // Second pass: iterate through the cuts, get slices of every intersecting blockset\n        for (let i=0, l=orderedCuts.length-1; i<l; i++) {\n            const cut = orderedCuts[i];\n            const nextCut = orderedCuts[i+1];\n            const tuples = [];\n\n            for (const [setId, blocks] of memoryMaps) {\n                // Find the block with the highest address that is equal or lower to\n                // the current cut (if any)\n                const blockAddr = Array.from(blocks.keys()).reduce((acc, val)=>{\n                    if (val > cut) {\n                        return acc;\n                    }\n                    return Math.max( acc, val );\n                }, -1);\n\n                if (blockAddr !== -1) {\n                    const block = blocks.get(blockAddr);\n                    const subBlockStart = cut - blockAddr;\n                    const subBlockEnd = nextCut - blockAddr;\n\n                    if (subBlockStart < block.length) {\n                        tuples.push([ setId, block.subarray(subBlockStart, subBlockEnd) ]);\n                    }\n                }\n            }\n\n            if (tuples.length) {\n                overlaps.set(cut, tuples);\n            }\n        }\n\n        return overlaps;\n    }\n\n\n    /**\n     * Given the output of the {@linkcode MemoryMap.overlapMemoryMaps|overlapMemoryMaps}\n     * (a <tt>Map</tt> of address to an <tt>Array</tt> of <tt>(id, Uint8Array)</tt> tuples),\n     * returns a {@linkcode MemoryMap}. This discards the IDs in the process.\n     *<br/>\n     * The output <tt>Map</tt> contains as many entries as the input one (using the same addresses\n     * as keys), but the value for each entry will be the <tt>Uint8Array</tt> of the <b>last</b>\n     * tuple for each address in the input data.\n     *<br/>\n     * The scenario is wanting to join together several parsed .hex files, not worrying about\n     * their overlaps.\n     *<br/>\n     *\n     * @param {Map.Array<mixed,Uint8Array>} overlaps The (possibly overlapping) input memory blocks\n     * @return {MemoryMap} The flattened memory blocks\n     */\n    static flattenOverlaps(overlaps) {\n        return new MemoryMap(\n            Array.from(overlaps.entries()).map(([address, tuples]) => {\n                return [address, tuples[tuples.length - 1][1] ];\n            })\n        );\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, where:\n     *\n     * <ul>\n     *  <li>Each key (the start address of each <tt>Uint8Array</tt>) is a multiple of\n     *    <tt>pageSize</tt></li>\n     *  <li>The size of each <tt>Uint8Array</tt> is exactly <tt>pageSize</tt></li>\n     *  <li>Bytes from the input map to bytes in the output</li>\n     *  <li>Bytes not in the input are replaced by a padding value</li>\n     * </ul>\n     *<br/>\n     * The scenario is wanting to prepare pages of bytes for a write operation, where the write\n     * operation affects a whole page/sector at once.\n     *<br/>\n     * The insertion order of keys in the output {@linkcode MemoryMap} is guaranteed\n     * to be strictly ascending. In other words, when iterating through the\n     * {@linkcode MemoryMap}, the addresses will be ordered in ascending order.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output will be newly allocated.\n     *<br/>\n     *\n     * @param {Number} [pageSize=1024] The size of the output pages, in bytes\n     * @param {Number} [pad=0xFF] The byte value to use for padding\n     * @return {MemoryMap}\n     */\n    paginate( pageSize=1024, pad=0xFF) {\n        if (pageSize <= 0) {\n            throw new Error('Page size must be greater than zero');\n        }\n        const outPages = new MemoryMap();\n        let page;\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            for (let pageAddr = blockAddr - (blockAddr % pageSize); pageAddr < blockEnd; pageAddr += pageSize) {\n                page = outPages.get(pageAddr);\n                if (!page) {\n                    page = new Uint8Array(pageSize);\n                    page.fill(pad);\n                    outPages.set(pageAddr, page);\n                }\n\n                const offset = pageAddr - blockAddr;\n                let subBlock;\n                if (offset <= 0) {\n                    // First page which intersects the block\n                    subBlock = block.subarray(0, Math.min(pageSize + offset, blockLength));\n                    page.set(subBlock, -offset);\n                } else {\n                    // Any other page which intersects the block\n                    subBlock = block.subarray(offset, offset + Math.min(pageSize, blockLength - offset));\n                    page.set(subBlock, 0);\n                }\n            }\n        }\n\n        return outPages;\n    }\n\n\n    /**\n     * Locates the <tt>Uint8Array</tt> which contains the given offset,\n     * and returns the four bytes held at that offset, as a 32-bit unsigned integer.\n     *\n     *<br/>\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|DataView.prototype.getUint32},\n     * except that this operates over a {@linkcode MemoryMap} instead of\n     * over an <tt>ArrayBuffer</tt>, and that this may return <tt>undefined</tt> if\n     * the address is not <em>entirely</em> contained within one of the <tt>Uint8Array</tt>s.\n     *<br/>\n     *\n     * @param {Number} offset The memory offset to read the data\n     * @param {Boolean} [littleEndian=false] Whether to fetch the 4 bytes as a little- or big-endian integer\n     * @return {Number|undefined} An unsigned 32-bit integer number\n     */\n    getUint32(offset, littleEndian) {\n        const keys = Array.from(this.keys());\n\n        for (let i=0,l=keys.length; i<l; i++) {\n            const blockAddr = keys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            if (blockAddr <= offset && (offset+4) <= blockEnd) {\n                return (new DataView(block.buffer, offset - blockAddr, 4)).getUint32(0, littleEndian);\n            }\n        }\n        return;\n    }\n\n\n    /**\n     * Returns a <tt>String</tt> of text representing a .hex file.\n     * <br/>\n     * The writer has an opinionated behaviour. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *\n     * @param {Number} [lineSize=16] Maximum number of bytes to be encoded in each data record.\n     * Must have a value between 1 and 255, as per the specification.\n     *\n     * @return {String} String of text with the .hex representation of the input binary data\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap = new MemoryMap();\n     * let bytes = new Uint8Array(....);\n     * memMap.set(0x0FF80000, bytes); // The block with 'bytes' will start at offset 0x0FF80000\n     *\n     * let string = memMap.asHexString();\n     */\n    asHexString(lineSize = 16) {\n        let lowAddress  = 0;    // 16 least significant bits of the current addr\n        let highAddress = -1 << 16; // 16 most significant bits of the current addr\n        const records = [];\n        if (lineSize <=0) {\n            throw new Error('Size of record must be greater than zero');\n        } else if (lineSize > 255) {\n            throw new Error('Size of record must be less than 256');\n        }\n\n        // Placeholders\n        const offsetRecord = new Uint8Array(6);\n        const recordHeader = new Uint8Array(4);\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n\n            // Sanity checks\n            if (!(block instanceof Uint8Array)) {\n                throw new Error('Block at offset ' + blockAddr + ' is not an Uint8Array');\n            }\n            if (blockAddr < 0) {\n                throw new Error('Block at offset ' + blockAddr + ' has a negative thus invalid address');\n            }\n            const blockSize = block.length;\n            if (!blockSize) { continue; }   // Skip zero-length blocks\n\n\n            if (blockAddr > (highAddress + 0xFFFF)) {\n                // Insert a new 0x04 record to jump to a new 64KiB block\n\n                // Round up the least significant 16 bits - no bitmasks because they trigger\n                // base-2 negative numbers, whereas subtracting the modulo maintains precision\n                highAddress = blockAddr - blockAddr % 0x10000;\n                lowAddress = 0;\n\n                offsetRecord[0] = 2;    // Length\n                offsetRecord[1] = 0;    // Load offset, high byte\n                offsetRecord[2] = 0;    // Load offset, low byte\n                offsetRecord[3] = 4;    // Record type\n                offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                records.push(\n                    ':' +\n                    Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                    hexpad(checksum(offsetRecord))\n                );\n            }\n\n            if (blockAddr < (highAddress + lowAddress)) {\n                throw new Error(\n                    'Block starting at 0x' +\n                    blockAddr.toString(16) +\n                    ' overlaps with a previous block.');\n            }\n\n            lowAddress = blockAddr % 0x10000;\n            let blockOffset = 0;\n            const blockEnd = blockAddr + blockSize;\n            if (blockEnd > 0xFFFFFFFF) {\n                throw new Error('Data cannot be over 0xFFFFFFFF');\n            }\n\n            // Loop for every 64KiB memory segment that spans this block\n            while (highAddress + lowAddress < blockEnd) {\n\n                if (lowAddress > 0xFFFF) {\n                    // Insert a new 0x04 record to jump to a new 64KiB block\n                    highAddress += 1 << 16; // Increase by one\n                    lowAddress = 0;\n\n                    offsetRecord[0] = 2;    // Length\n                    offsetRecord[1] = 0;    // Load offset, high byte\n                    offsetRecord[2] = 0;    // Load offset, low byte\n                    offsetRecord[3] = 4;    // Record type\n                    offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                    offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                    records.push(\n                        ':' +\n                        Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                        hexpad(checksum(offsetRecord))\n                    );\n                }\n\n                let recordSize = -1;\n                // Loop for every record for that spans the current 64KiB memory segment\n                while (lowAddress < 0x10000 && recordSize) {\n                    recordSize = Math.min(\n                        lineSize,                            // Normal case\n                        blockEnd - highAddress - lowAddress, // End of block\n                        0x10000 - lowAddress                 // End of low addresses\n                    );\n\n                    if (recordSize) {\n\n                        recordHeader[0] = recordSize;   // Length\n                        recordHeader[1] = lowAddress >> 8;    // Load offset, high byte\n                        recordHeader[2] = lowAddress;    // Load offset, low byte\n                        recordHeader[3] = 0;    // Record type\n\n                        const subBlock = block.subarray(blockOffset, blockOffset + recordSize);   // Data bytes for this record\n\n                        records.push(\n                            ':' +\n                            Array.prototype.map.call(recordHeader, hexpad).join('') +\n                            Array.prototype.map.call(subBlock, hexpad).join('') +\n                            hexpad(checksumTwo(recordHeader, subBlock))\n                        );\n\n                        blockOffset += recordSize;\n                        lowAddress += recordSize;\n                    }\n                }\n            }\n        }\n\n        records.push(':00000001FF');    // EOF record\n\n        return records.join('\\n');\n    }\n\n\n    /**\n     * Performs a deep copy of the current {@linkcode MemoryMap}, returning a new one\n     * with exactly the same contents, but allocating new memory for each of its\n     * <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     */\n    clone() {\n        const cloned = new MemoryMap();\n\n        for (let [addr, value] of this) {\n            cloned.set(addr, new Uint8Array(value));\n        }\n\n        return cloned;\n    }\n\n\n    /**\n     * Given one <tt>Uint8Array</tt>, looks through its contents and returns a new\n     * {@linkcode MemoryMap}, stripping away those regions where there are only\n     * padding bytes.\n     * <br/>\n     * The start of the input <tt>Uint8Array</tt> is assumed to be offset zero for the output.\n     * <br/>\n     * The use case here is dumping memory from a working device and try to see the\n     * \"interesting\" memory regions it has. This assumes that there is a constant,\n     * predefined padding byte value being used in the \"non-interesting\" regions.\n     * In other words: this will work as long as the dump comes from a flash memory\n     * which has been previously erased (thus <tt>0xFF</tt>s for padding), or from a\n     * previously blanked HDD (thus <tt>0x00</tt>s for padding).\n     * <br/>\n     * This method uses <tt>subarray</tt> on the input data, and thus does not allocate memory\n     * for the <tt>Uint8Array</tt>s.\n     *\n     * @param {Uint8Array} bytes The input data\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @param {Number} [minPadLength=64] The minimum number of consecutive pad bytes to\n     * be considered actual padding\n     *\n     * @return {MemoryMap}\n     */\n    static fromPaddedUint8Array(bytes, padByte=0xFF, minPadLength=64) {\n\n        if (!(bytes instanceof Uint8Array)) {\n            throw new Error('Bytes passed to fromPaddedUint8Array are not an Uint8Array');\n        }\n\n        // The algorithm used is naïve and checks every byte.\n        // An obvious optimization would be to implement Boyer-Moore\n        // (see https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm )\n        // or otherwise start skipping up to minPadLength bytes when going through a non-pad\n        // byte.\n        // Anyway, we could expect a lot of cases where there is a majority of pad bytes,\n        // and the algorithm should check most of them anyway, so the perf gain is questionable.\n\n        const memMap = new MemoryMap();\n        let consecutivePads = 0;\n        let lastNonPad = -1;\n        let firstNonPad = 0;\n        let skippingBytes = false;\n        const l = bytes.length;\n\n        for (let addr = 0; addr < l; addr++) {\n            const byte = bytes[addr];\n\n            if (byte === padByte) {\n                consecutivePads++;\n                if (consecutivePads >= minPadLength) {\n                    // Edge case: ignore writing a zero-length block when skipping\n                    // bytes at the beginning of the input\n                    if (lastNonPad !== -1) {\n                        /// Add the previous block to the result memMap\n                        memMap.set(firstNonPad, bytes.subarray(firstNonPad, lastNonPad+1));\n                    }\n\n                    skippingBytes = true;\n                }\n            } else {\n                if (skippingBytes) {\n                    skippingBytes = false;\n                    firstNonPad = addr;\n                }\n                lastNonPad = addr;\n                consecutivePads = 0;\n            }\n        }\n\n        // At EOF, add the last block if not skipping bytes already (and input not empty)\n        if (!skippingBytes && lastNonPad !== -1) {\n            memMap.set(firstNonPad, bytes.subarray(firstNonPad, l));\n        }\n\n        return memMap;\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>.\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice|Array.prototype.slice},\n     * in that the return value is a portion of the current {@linkcode MemoryMap}.\n     *\n     * <br/>\n     * The returned {@linkcode MemoryMap} might be empty.\n     *\n     * <br/>\n     * Internally, this uses <tt>subarray</tt>, so new memory is not allocated.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @return {MemoryMap}\n     */\n    slice(address, length = Infinity){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n\n        const sliced = new MemoryMap();\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    sliced.set(sliceStart, block.subarray(relativeSliceStart, relativeSliceStart + sliceLength));\n                }\n            }\n        }\n        return sliced;\n    }\n\n    /**\n     * Returns a new instance of {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|Uint8Array}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>. Any byte without a value\n     * in the input {@linkcode MemoryMap} will have a value of <tt>padByte</tt>.\n     *\n     * <br/>\n     * This method allocates new memory.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @return {MemoryMap}\n     */\n    slicePad(address, length, padByte=0xFF){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n        \n        const out = (new Uint8Array(length)).fill(padByte);\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    out.set(block.subarray(relativeSliceStart, relativeSliceStart + sliceLength), sliceStart - address);\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Checks whether the current memory map contains the one given as a parameter.\n     *\n     * <br/>\n     * \"Contains\" means that all the offsets that have a byte value in the given\n     * memory map have a value in the current memory map, and that the byte values\n     * are the same.\n     *\n     * <br/>\n     * An empty memory map is always contained in any other memory map.\n     *\n     * <br/>\n     * Returns boolean <tt>true</tt> if the memory map is contained, <tt>false</tt>\n     * otherwise.\n     *\n     * @param {MemoryMap} memMap The memory map to check\n     * @return {Boolean}\n     */\n    contains(memMap) {\n        for (let [blockAddr, block] of memMap) {\n\n            const blockLength = block.length;\n\n            const slice = this.slice(blockAddr, blockLength).join().get(blockAddr);\n\n            if ((!slice) || slice.length !== blockLength ) {\n                return false;\n            }\n\n            for (const i in block) {\n                if (block[i] !== slice[i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\n\nexport default MemoryMap;\n\n","import { Z80 } from './z80';\n// @ts-ignore: Module '\"nrf-intel-hex\"' has no default export\nimport MemoryMap from 'nrf-intel-hex';\n\nlet running = false;\nlet active = true;\nlet speed = 30;\n\nlet cycles = 0;\nconst memory = Array(0xFFFF).fill(0xFF);\nconst inPorts = Array(256).fill(0xFF);\nconst outPorts = Array(256).fill(0xFF);\n\nconst cpu = Z80({\n    mem_read: (addr:number) => memory[addr],\n    mem_write: (addr:number, value:number) => memory[addr] = value,\n    io_read: (port:number) => {\n        return inPorts[port & 0xFF];\n    },\n    io_write: (port:number, value:number) => {\n        const port1 = port & 0xFF;\n        outPorts[port1] = value;\n        updateDisplay();\n        postOutPorts(port1, value);\n    },\n});\n\nconst display = Array(6).fill(0);\n\nself.onmessage = event => {\n    if (event.data.type === 'INIT') {\n        // updateMemory(ROM);\n        cpu.reset();\n        running = true;\n        run();\n    }\n    else if (event.data.type === 'PAUSE') {\n        if (active) {\n            active = false;\n            running = false;\n        }\n        else {\n            active = true;\n            running = true;\n            run();\n        }\n    }\n    else if (event.data.type === 'RESUME') {\n    }\n    else if (event.data.type === 'RESET') {\n        console.log('resetting');\n        cpu.reset();\n        running = true;\n        run();\n    }\n    else if (event.data.type === 'SET_INPUT_VALUE') {\n        const { port, value } = event.data;\n        inPorts[port] = value;\n    }\n    else if (event.data.type === 'SET_SPEED') {\n        speed = Number(event.data.value)/100;\n        console.log('set speed', speed);\n    }\n    else if (event.data.type === 'NMI') {\n        cpu.interrupt(true, 0);\n    }\n    else if (event.data.type === 'UPDATE_MEMORY') {\n        updateMemory(event.data.value);\n        cpu.reset();\n    }\n    else if (event.data.type === 'READ_MEMORY') {\n        readMemory(event.data.from, event.data.size);\n    }\n    else if (event.data.type === 'HIDDEN') {\n        let hidden = event.data.value;\n        if (hidden) {\n            running = false;\n        }\n        else if (active) {\n            running = true;\n            run();\n        }\n        else {\n            console.log('not active');\n        }\n    }\n};\n\nfunction* runGen () {\n    while (true){\n        for (let i = 0; i < 1000 ; i++) {\n            const count = cpu.run_instruction();\n            cycles += count;\n        }\n        yield cycles;\n    }\n}\n\nlet pending = false;\nconst iter = runGen();\nfunction run() {\n    if (pending) return;\n    if (!running) return;\n    iter.next();\n    const delay = Math.floor((1 - Number(speed)) * 30);\n    if (running) {\n        pending = true;\n        setTimeout(function(){\n            pending = false;\n            run();\n        }, delay)\n    };\n}\n\nfunction updateDisplay() {\n    const digits = outPorts[1];\n    const segments = outPorts[2];\n    let mask = 0x01;\n    for (let i = 0; i < 6; i++) {\n        if (digits & mask){\n            display[i] = segments;\n        }\n        mask = mask << 1;\n    }\n}\n\nfunction getPortsBuffer(){\n    var buffer = new ArrayBuffer(4);\n    var view = new Uint8Array(buffer);\n    view[0] = outPorts[0];\n    view[1] = outPorts[1];\n    view[2] = outPorts[2];\n    return buffer;\n}\n\nfunction getDisplayBuffer(){\n    var buffer = new ArrayBuffer(6);\n    var view = new Uint8Array(buffer);\n    for (let i = 0; i < 6; i++) {\n        view[i] = display[i];\n    }\n    return buffer;\n}\n\nlet speaker = 1;\nlet wavelength = 0;\nfunction postOutPorts(port:number, value:number) {\n    const buffer = getPortsBuffer();\n    const display = getDisplayBuffer();\n\n    if (port === 1 && (value === 0x7F || value === 0xFF)) {\n        const speaker1 = value >> 7;\n        if (speaker1 === 1 && speaker === 0) {\n            wavelength = cycles;\n            cycles = 0;\n        }\n        speaker = speaker1;\n    }\n    if (cycles > 10000) wavelength = 0;\n\n    self.postMessage({\n        type: 'POST_OUTPORTS',\n        buffer,\n        display,\n        speaker,\n        wavelength,\n    // @ts-ignore: Type 'ArrayBuffer' is not assignable to type 'string' bug in type definition\n    }, [buffer, display]);\n}\n\nfunction updateMemory(rom:string) {\n    const blocks = MemoryMap.fromHex(rom);\n    for (let address of blocks.keys()) {\n        const block = blocks.get(address);\n        for (let i = 0; i < block.length; i++) {\n            memory[i + address] = block[i];\n        }\n    }\n}\n\nfunction readMemory(from:number, size:number) {\n    let buffer = new ArrayBuffer(size);\n    let bytes = new Uint8Array(buffer);\n    for (let i = 0; i < size; i++) {\n        bytes[i] = memory[i + from]\n    }\n    self.postMessage({\n        type: 'POST_MEMORY',\n        from,\n        size,\n        buffer,\n    // @ts-ignore: Type 'ArrayBuffer' is not assignable to type 'string' bug in type definition\n    }, [buffer]);\n}\n"]}