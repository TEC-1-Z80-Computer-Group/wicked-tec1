///////////////////////////////////////////////////////////////////////////////
/// @file Z80.js
///
/// @brief Emulator for the Zilog Z80 microprocessor
///
/// @author Matthew Howell
///
/// @remarks
///  This module is a simple, straightforward instruction interpreter.
///   There is no fancy dynamic recompilation or cycle-accurate emulation.
///   The author believes that this should be sufficient for any emulator that
///   would be feasible to write in JavaScript anyway.
///  The code and the comments in this file assume that the reader is familiar
///   with the Z80 architecture. If you're not, here are some references I use:
///  http://clrhome.org/table/ - Z80 instruction set tables
///  http://www.zilog.com/docs/z80/um0080.pdf - The official manual
///  http://www.myquest.nl/z80undocumented/z80-documented-v0.91.pdf
///   - The Undocumented Z80, Documented
///
/// @copyright (c) 2013 Matthew Howell
///  This code is released under the MIT license,
///  a copy of which is available in the associated README.md file,
///  or at http://opensource.org/licenses/MIT
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// We'll begin with the object constructor and the public API functions.
///////////////////////////////////////////////////////////////////////////////

interface CoreParameter {
    memRead: (addr: number) => any;
    memWrite: (addr: number, value: number) => number;
    ioRead: (port: number) => any;
    ioWrite: (port: number, value: number) => void;
}

interface Z80State {
    b: number;
    a: number;
    c: number;
    d: number;
    e: number;
    h: number;
    l: number;
    aPrime: number;
    bPrime: number;
    cPrime: number;
    dPrime: number;
    ePrime: number;
    hPrime: number;
    lPrime: number;
    ix: number;
    iy: number;
    i: number;
    r: number;
    sp: number;
    pc: number;
    flags: {
        S: number;
        Z: number;
        Y: number;
        H: number;
        X: number;
        P: number;
        N: number;
        C: number;
    };
    flagsPrime: {
        S: number;
        Z: number;
        Y: number;
        H: number;
        X: number;
        P: number;
        N: number;
        C: number;
    };
    imode: number;
    iff1: number;
    iff2: number;
    halted: boolean;
    doDelayedDI: boolean;
    doDelayedEI: boolean;
    cycleCounter: number;
}

export function Z80(coreParameter: CoreParameter) {

        // Obviously we'll be needing the core object's functions again.
        const core = coreParameter;

        // The argument to this constructor should be an object containing 4 functions:
        // mem_read(address) should return the byte at the given memory address,
        // mem_write(address, value) should write the given value to the given memory address,
        // io_read(port) should read a return a byte read from the given I/O port,
        // io_write(port, value) should write the given byte to the given I/O port.
        // If any of those functions is missing, this module cannot run.
        if (!core || (typeof core.memRead !== "function") || (typeof core.memWrite !== "function") ||
            (typeof core.ioRead !== "function") || (typeof core.ioWrite !== "function"))
            throw ("Z80: Core object is missing required functions.");

        // All right, let's initialize the registers.
        // First, the standard 8080 registers.
        let a = 0x00;
        let b = 0x00;
        let c = 0x00;
        let d = 0x00;
        let e = 0x00;
        let h = 0x00;
        let l = 0x00;
        // Now the special Z80 copies of the 8080 registers
        //  (the ones used for the SWAP instruction and such).
        let aPrime = 0x00;
        let bPrime = 0x00;
        let cPrime = 0x00;
        let dPrime = 0x00;
        let ePrime = 0x00;
        let hPrime = 0x00;
        let lPrime = 0x00;
        // And now the Z80 index registers.
        let ix = 0x0000;
        let iy = 0x0000;
        // Then the "utility" registers: the interrupt vector,
        //  the memory refresh, the stack pointer, and the program counter.
        let i = 0x00;
        let r = 0x00;
        let sp = 0xdff0;
        let pc = 0x0000;
        // We don't keep an F register for the flags,
        //  because most of the time we're only accessing a single flag,
        //  so we optimize for that case and use utility functions
        //  for the rarer occasions when we need to access the whole register.
        const flags = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };
        const flagsPrime = { S: 0, Z: 0, Y: 0, H: 0, X: 0, P: 0, N: 0, C: 0 };
        // And finally we have the interrupt mode and flip-flop registers.
        let imode = 0;
        let iff1 = 0;
        let iff2 = 0;

        // These are all specific to this implementation, not Z80 features.
        // Keep track of whether we've had a HALT instruction called.
        let halted = false;
        // EI and DI wait one instruction before they take effect;
        //  these flags tell us when we're in that wait state.
        let doDelayedDI = false;
        let doDelayedEI = false;
        // This tracks the number of cycles spent in a single instruction run,
        //  including processing any prefixes and handling interrupts.
        let cycleCounter = 0;

    ///////////////////////////////////////////////////////////////////////////////
    /// These tables contain the number of T cycles used for each instruction.
    /// In a few special cases, such as conditional control flow instructions,
    ///  additional cycles might be added to these values.
    /// The total number of cycles is the return value of run_instruction().
    ///////////////////////////////////////////////////////////////////////////////
    const cycleCounts = [
        4, 10, 7, 6, 4, 4, 7, 4, 4, 11, 7, 6, 4, 4, 7, 4,
        8, 10, 7, 6, 4, 4, 7, 4, 12, 11, 7, 6, 4, 4, 7, 4,
        7, 10, 16, 6, 4, 4, 7, 4, 7, 11, 16, 6, 4, 4, 7, 4,
        7, 10, 13, 6, 11, 11, 10, 4, 7, 11, 13, 6, 4, 4, 7, 4,
        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
        7, 7, 7, 7, 7, 7, 4, 7, 4, 4, 4, 4, 4, 4, 7, 4,
        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
        4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
        5, 10, 10, 10, 10, 11, 7, 11, 5, 10, 10, 0, 10, 17, 7, 11,
        5, 10, 10, 11, 10, 11, 7, 11, 5, 4, 10, 11, 10, 0, 7, 11,
        5, 10, 10, 19, 10, 11, 7, 11, 5, 4, 10, 4, 10, 0, 7, 11,
        5, 10, 10, 4, 10, 11, 7, 11, 5, 6, 10, 4, 10, 0, 7, 11
    ];

    const cycleCountsED = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,
        12, 12, 15, 20, 8, 14, 8, 9, 12, 12, 15, 20, 8, 14, 8, 9,
        12, 12, 15, 20, 8, 14, 8, 18, 12, 12, 15, 20, 8, 14, 8, 18,
        12, 12, 15, 20, 8, 14, 8, 0, 12, 12, 15, 20, 8, 14, 8, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,
        16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ];

    const cycleCountsCB = [
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,
        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,
        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,
        8, 8, 8, 8, 8, 8, 12, 8, 8, 8, 8, 8, 8, 8, 12, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8,
        8, 8, 8, 8, 8, 8, 15, 8, 8, 8, 8, 8, 8, 8, 15, 8
    ];

    const cycleCountsDD = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0,
        0, 14, 20, 10, 8, 8, 11, 0, 0, 15, 20, 10, 8, 8, 11, 0,
        0, 0, 0, 0, 23, 23, 19, 0, 0, 15, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,
        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,
        8, 8, 8, 8, 8, 8, 19, 8, 8, 8, 8, 8, 8, 8, 19, 8,
        19, 19, 19, 19, 19, 19, 0, 19, 0, 0, 0, 0, 8, 8, 19, 0,
        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,
        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,
        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,
        0, 0, 0, 0, 8, 8, 19, 0, 0, 0, 0, 0, 8, 8, 19, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 14, 0, 23, 0, 15, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0
    ];

        const getSignedOffsetByte = function (value: number) {
            // This function requires some explanation.
            // We just use JavaScript Number constiables for our registers,
            //  not like a typed array or anything.
            // That means that, when we have a byte value that's supposed
            //  to represent a signed offset, the value we actually see
            //  isn't signed at all, it's just a small integer.
            // So, this function converts that byte into something JavaScript
            //  will recognize as signed, so we can easily do arithmetic with it.
            // First, we clamp the value to a single byte, just in case.
            value &= 0xff;
            // We don't have to do anything if the value is positive.
            if (value & 0x80) {
                // But if the value is negative, we need to manually un-two's-compliment it.
                // I'm going to assume you can figure out what I meant by that,
                //  because I don't know how else to explain it.
                // We could also just do value |= 0xffffff00, but I prefer
                //  not caring how many bits are in the integer representation
                //  of a JavaScript number in the currently running browser.
                value = -((0xff & ~value) + 1);
            }
            return value;
        };

        const getFlagsRegister = function () {
            // We need the whole F register for some reason.
            //  probably a PUSH AF instruction,
            //  so make the F register out of our separate flags.
            return (flags.S << 7) |
                (flags.Z << 6) |
                (flags.Y << 5) |
                (flags.H << 4) |
                (flags.X << 3) |
                (flags.P << 2) |
                (flags.N << 1) |
                (flags.C);
        };

        const getFlagsPrime = function () {
            // This is the same as the above for the F' register.
            return (flagsPrime.S << 7) |
                (flagsPrime.Z << 6) |
                (flagsPrime.Y << 5) |
                (flagsPrime.H << 4) |
                (flagsPrime.X << 3) |
                (flagsPrime.P << 2) |
                (flagsPrime.N << 1) |
                (flagsPrime.C);
        };

        const setFlagsRegister = function (operand: number) {
            // We need to set the F register, probably for a POP AF,
            //  so break out the given value into our separate flags.
            flags.S = (operand & 0x80) >>> 7;
            flags.Z = (operand & 0x40) >>> 6;
            flags.Y = (operand & 0x20) >>> 5;
            flags.H = (operand & 0x10) >>> 4;
            flags.X = (operand & 0x08) >>> 3;
            flags.P = (operand & 0x04) >>> 2;
            flags.N = (operand & 0x02) >>> 1;
            flags.C = (operand & 0x01);
        };

        const setFlagsPrime = function (operand: number) {
            // Again, this is the same as the above for F'.
            flagsPrime.S = (operand & 0x80) >>> 7;
            flagsPrime.Z = (operand & 0x40) >>> 6;
            flagsPrime.Y = (operand & 0x20) >>> 5;
            flagsPrime.H = (operand & 0x10) >>> 4;
            flagsPrime.X = (operand & 0x08) >>> 3;
            flagsPrime.P = (operand & 0x04) >>> 2;
            flagsPrime.N = (operand & 0x02) >>> 1;
            flagsPrime.C = (operand & 0x01);
        };

        const updateXYFlags = function (result: number) {
            // Most of the time, the undocumented flags
            //  (sometimes called X and Y, or 3 and 5),
            //  take their values from the corresponding bits
            //  of the result of the instruction,
            //  or from some other related value.
            // This is a utility function to set those flags based on those bits.
            flags.Y = (result & 0x20) >>> 5;
            flags.X = (result & 0x08) >>> 3;
        };

        const getParity = function (value: number) {
            // We could try to actually calculate the parity every time,
            //  but why calculate what you can pre-calculate?
            const parityBits = [
                1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
                0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
                0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
                1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
                0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
                1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
                1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
                0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
                0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
                1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
                1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
                0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
                1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
                0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
                0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
                1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1
            ];
            return parityBits[value];
        };

        const pushWord = function (operand: number) {
            // Pretty obvious what this function does; given a 16-bit value,
            //  decrement the stack pointer, write the high byte to the new
            //  stack pointer location, then repeat for the low byte.
            sp = (sp - 1) & 0xffff;
            core.memWrite(sp, (operand & 0xff00) >>> 8);
            sp = (sp - 1) & 0xffff;
            core.memWrite(sp, operand & 0x00ff);
        };

        const popWord = function () {
            // Again, not complicated; read a byte off the top of the stack,
            //  increment the stack pointer, rinse and repeat.
            let retval = core.memRead(sp) & 0xff;
            sp = (sp + 1) & 0xffff;
            retval |= core.memRead(sp) << 8;
            sp = (sp + 1) & 0xffff;
            return retval;
        };

        ///////////////////////////////////////////////////////////////////////////////
        /// Now, the way most instructions work in this emulator is that they set up
        ///  their operands according to their addressing mode, and then they call a
        ///  utility function that handles all constiations of that instruction.
        /// Those utility functions begin here.
        ///////////////////////////////////////////////////////////////////////////////
        const doConditionalAbsoluteJump = function (condition: boolean) {
            // This function implements the JP [condition],nn instructions.
            if (condition) {
                // We're taking this jump, so write the new PC,
                //  and then decrement the thing we just wrote,
                //  because the instruction decoder increments the PC
                //  unconditionally at the end of every instruction
                //  and we need to counteract that so we end up at the jump target.
                pc = core.memRead((pc + 1) & 0xffff) |
                    (core.memRead((pc + 2) & 0xffff) << 8);
                pc = (pc - 1) & 0xffff;
            }
            else {
                // We're not taking this jump, just move the PC past the operand.
                pc = (pc + 2) & 0xffff;
            }
        };

        const doConditionalRelativeJump = function (condition: boolean) {
            // This function implements the JR [condition],n instructions.
            if (condition) {
                // We need a few more cycles to actually take the jump.
                cycleCounter += 5;
                // Calculate the offset specified by our operand.
                const offset = getSignedOffsetByte(core.memRead((pc + 1) & 0xffff));
                // Add the offset to the PC, also skipping past this instruction.
                pc = (pc + offset + 1) & 0xffff;
            }
            else {
                // No jump happening, just skip the operand.
                pc = (pc + 1) & 0xffff;
            }
        };

        const doconditionalCall = function (condition: boolean) {
            // This function is the CALL [condition],nn instructions.
            // If you've seen the previous functions, you know this drill.
            if (condition) {
                cycleCounter += 7;
                pushWord((pc + 3) & 0xffff);
                pc = core.memRead((pc + 1) & 0xffff) |
                    (core.memRead((pc + 2) & 0xffff) << 8);
                pc = (pc - 1) & 0xffff;
            }
            else {
                pc = (pc + 2) & 0xffff;
            }
        };

        const doconditionalReturn = function (condition: boolean) {
            if (condition) {
                cycleCounter += 6;
                pc = (popWord() - 1) & 0xffff;
            }
        };

        const doreset = function (address: number) {
            // The RST [address] instructions go through here.
            pushWord((pc + 1) & 0xffff);
            pc = (address - 1) & 0xffff;
        };

        const doadd = function (operand: number) {
            // This is the ADD A, [operand] instructions.
            // We'll do the literal addition, which includes any overflow,
            //  so that we can more easily figure out whether we had
            //  an overflow or a carry and set the flags accordingly.
            const result = a + operand;

            // The great majority of the work for the arithmetic instructions
            //  turns out to be setting the flags rather than the actual operation.
            flags.S = (result & 0x80) ? 1 : 0;
            flags.Z = !(result & 0xff) ? 1 : 0;
            flags.H = (((operand & 0x0f) + (a & 0x0f)) & 0x10) ? 1 : 0;
            // An overflow has happened if the sign bits of the accumulator and the operand
            //  don't match the sign bit of the result value.
            flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;
            flags.N = 0;
            flags.C = (result & 0x100) ? 1 : 0;

            a = result & 0xff;
            updateXYFlags(a);
        };

        const doadc = function (operand: number) {
            const result = a + operand + flags.C;

            flags.S = (result & 0x80) ? 1 : 0;
            flags.Z = !(result & 0xff) ? 1 : 0;
            flags.H = (((operand & 0x0f) + (a & 0x0f) + flags.C) & 0x10) ? 1 : 0;
            flags.P = ((a & 0x80) === (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;
            flags.N = 0;
            flags.C = (result & 0x100) ? 1 : 0;

            a = result & 0xff;
            updateXYFlags(a);
        };

        const dosub = function (operand: number) {
            const result = a - operand;

            flags.S = (result & 0x80) ? 1 : 0;
            flags.Z = !(result & 0xff) ? 1 : 0;
            flags.H = (((a & 0x0f) - (operand & 0x0f)) & 0x10) ? 1 : 0;
            flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;
            flags.N = 1;
            flags.C = (result & 0x100) ? 1 : 0;

            a = result & 0xff;
            updateXYFlags(a);
        };

        const dosbc = function (operand: number) {
            const result = a - operand - flags.C;

            flags.S = (result & 0x80) ? 1 : 0;
            flags.Z = !(result & 0xff) ? 1 : 0;
            flags.H = (((a & 0x0f) - (operand & 0x0f) - flags.C) & 0x10) ? 1 : 0;
            flags.P = ((a & 0x80) !== (operand & 0x80)) && ((a & 0x80) !== (result & 0x80)) ? 1 : 0;
            flags.N = 1;
            flags.C = (result & 0x100) ? 1 : 0;

            a = result & 0xff;
            updateXYFlags(a);
        };

        const docp = function (operand: number) {
            // A compare instruction is just a subtraction that doesn't save the value,
            //  so we implement it as... a subtraction that doesn't save the value.
            const temp = a;
            dosub(operand);
            a = temp;
            // Since this instruction has no "result" value, the undocumented flags
            //  are set based on the operand instead.
            updateXYFlags(operand);
        };

        const doand = function (operand: number) {
            // The logic instructions are all pretty straightforward.
            a &= operand & 0xff;
            flags.S = (a & 0x80) ? 1 : 0;
            flags.Z = !a ? 1 : 0;
            flags.H = 1;
            flags.P = getParity(a);
            flags.N = 0;
            flags.C = 0;
            updateXYFlags(a);
        };

        const door = function (operand: number) {
            a = (operand | a) & 0xff;
            flags.S = (a & 0x80) ? 1 : 0;
            flags.Z = !a ? 1 : 0;
            flags.H = 0;
            flags.P = getParity(a);
            flags.N = 0;
            flags.C = 0;
            updateXYFlags(a);
        };

        const doxor = function (operand: number) {
            a = (operand ^ a) & 0xff;
            flags.S = (a & 0x80) ? 1 : 0;
            flags.Z = !a ? 1 : 0;
            flags.H = 0;
            flags.P = getParity(a);
            flags.N = 0;
            flags.C = 0;
            updateXYFlags(a);
        };

        const doinc = function (operand: number) {
            let result = operand + 1;

            flags.S = (result & 0x80) ? 1 : 0;
            flags.Z = !(result & 0xff) ? 1 : 0;
            flags.H = ((operand & 0x0f) === 0x0f) ? 1 : 0;
            // It's a good deal easier to detect overflow for an increment/decrement.
            flags.P = (operand === 0x7f) ? 1 : 0;
            flags.N = 0;

            result &= 0xff;
            updateXYFlags(result);

            return result;
        };

        const dodec = function (operand: number) {
            let result = operand - 1;

            flags.S = (result & 0x80) ? 1 : 0;
            flags.Z = !(result & 0xff) ? 1 : 0;
            flags.H = ((operand & 0x0f) === 0x00) ? 1 : 0;
            flags.P = (operand === 0x80) ? 1 : 0;
            flags.N = 1;

            result &= 0xff;
            updateXYFlags(result);

            return result;
        };

        const doHLadd = function (operand: number) {
            // The HL arithmetic instructions are the same as the A ones,
            //  just with twice as many bits happening.
            const hl = l | (h << 8), result = hl + operand;

            flags.N = 0;
            flags.C = (result & 0x10000) ? 1 : 0;
            flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;

            l = result & 0xff;
            h = (result & 0xff00) >>> 8;

            updateXYFlags(h);
        };

        const doHLadc = function (operand: number) {
            operand += flags.C;
            const hl = l | (h << 8), result = hl + operand;

            flags.S = (result & 0x8000) ? 1 : 0;
            flags.Z = !(result & 0xffff) ? 1 : 0;
            flags.H = (((hl & 0x0fff) + (operand & 0x0fff)) & 0x1000) ? 1 : 0;
            flags.P = ((hl & 0x8000) === (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;
            flags.N = 0;
            flags.C = (result & 0x10000) ? 1 : 0;

            l = result & 0xff;
            h = (result >>> 8) & 0xff;

            updateXYFlags(h);
        };

        const doHLsbc = function (operand: number) {
            operand += flags.C;
            const hl = l | (h << 8), result = hl - operand;

            flags.S = (result & 0x8000) ? 1 : 0;
            flags.Z = !(result & 0xffff) ? 1 : 0;
            flags.H = (((hl & 0x0fff) - (operand & 0x0fff)) & 0x1000) ? 1 : 0;
            flags.P = ((hl & 0x8000) !== (operand & 0x8000)) && ((result & 0x8000) !== (hl & 0x8000)) ? 1 : 0;
            flags.N = 1;
            flags.C = (result & 0x10000) ? 1 : 0;

            l = result & 0xff;
            h = (result >>> 8) & 0xff;

            updateXYFlags(h);
        };

        const doin = function (port: number) {
            const result = core.ioRead(port);

            flags.S = (result & 0x80) ? 1 : 0;
            flags.Z = result ? 0 : 1;
            flags.H = 0;
            flags.P = getParity(result) ? 1 : 0;
            flags.N = 0;
            updateXYFlags(result);

            return result;
        };

        const doneg = function () {
            // This instruction is defined to not alter the register if it === 0x80.
            if (a !== 0x80) {
                // This is a signed operation, so convert A to a signed value.
                a = getSignedOffsetByte(a);

                a = (-a) & 0xff;
            }

            flags.S = (a & 0x80) ? 1 : 0;
            flags.Z = !a ? 1 : 0;
            flags.H = (((-a) & 0x0f) > 0) ? 1 : 0;
            flags.P = (a === 0x80) ? 1 : 0;
            flags.N = 1;
            flags.C = a ? 1 : 0;
            updateXYFlags(a);
        };

        const doldi = function () {
            // Copy the value that we're supposed to copy.
            const readValue = core.memRead(l | (h << 8));
            core.memWrite(e | (d << 8), readValue);

            // Increment DE and HL, and decrement BC.
            let result = (e | (d << 8)) + 1;
            e = result & 0xff;
            d = (result & 0xff00) >>> 8;
            result = (l | (h << 8)) + 1;
            l = result & 0xff;
            h = (result & 0xff00) >>> 8;
            result = (c | (b << 8)) - 1;
            c = result & 0xff;
            b = (result & 0xff00) >>> 8;

            flags.H = 0;
            flags.P = (c || b) ? 1 : 0;
            flags.N = 0;
            flags.Y = ((a + readValue) & 0x02) >>> 1;
            flags.X = ((a + readValue) & 0x08) >>> 3;
        };

        const docpi = function () {
            const tempcarry = flags.C;
            const ReadValue = core.memRead(l | (h << 8))
            docp(ReadValue);
            flags.C = tempcarry;
            flags.Y = ((a - ReadValue - flags.H) & 0x02) >>> 1;
            flags.X = ((a - ReadValue - flags.H) & 0x08) >>> 3;

            let result = (l | (h << 8)) + 1;
            l = result & 0xff;
            h = (result & 0xff00) >>> 8;
            result = (c | (b << 8)) - 1;
            c = result & 0xff;
            b = (result & 0xff00) >>> 8;

            flags.P = result ? 1 : 0;
        };

        const doini = function () {
            b = dodec(b);

            core.memWrite(l | (h << 8), core.ioRead((b << 8) | c));

            const result = (l | (h << 8)) + 1;
            l = result & 0xff;
            h = (result & 0xff00) >>> 8;

            flags.N = 1;
        };

        const doouti = function () {
            core.ioWrite((b << 8) | c, core.memRead(l | (h << 8)));

            const result = (l | (h << 8)) + 1;
            l = result & 0xff;
            h = (result & 0xff00) >>> 8;

            b = dodec(b);
            flags.N = 1;
        };

        const doldd = function () {
            flags.N = 0;
            flags.H = 0;

            const readValue = core.memRead(l | (h << 8));
            core.memWrite(e | (d << 8), readValue);

            let result = (e | (d << 8)) - 1;
            e = result & 0xff;
            d = (result & 0xff00) >>> 8;
            result = (l | (h << 8)) - 1;
            l = result & 0xff;
            h = (result & 0xff00) >>> 8;
            result = (c | (b << 8)) - 1;
            c = result & 0xff;
            b = (result & 0xff00) >>> 8;

            flags.P = (c || b) ? 1 : 0;
            flags.Y = ((a + readValue) & 0x02) >>> 1;
            flags.X = ((a + readValue) & 0x08) >>> 3;
        };

        const docpd = function () {
            const tempcarry = flags.C
            const readValue = core.memRead(l | (h << 8))
            docp(readValue);
            flags.C = tempcarry;
            flags.Y = ((a - readValue - flags.H) & 0x02) >>> 1;
            flags.X = ((a - readValue - flags.H) & 0x08) >>> 3;

            let result = (l | (h << 8)) - 1;
            l = result & 0xff;
            h = (result & 0xff00) >>> 8;
            result = (c | (b << 8)) - 1;
            c = result & 0xff;
            b = (result & 0xff00) >>> 8;

            flags.P = result ? 1 : 0;
        };

        const doind = function () {
            b = dodec(b);

            core.memWrite(l | (h << 8), core.ioRead((b << 8) | c));

            const result = (l | (h << 8)) - 1;
            l = result & 0xff;
            h = (result & 0xff00) >>> 8;

            flags.N = 1;
        };

        const dooutd = function () {
            core.ioWrite((b << 8) | c, core.memRead(l | (h << 8)));

            const result = (l | (h << 8)) - 1;
            l = result & 0xff;
            h = (result & 0xff00) >>> 8;

            b = dodec(b);
            flags.N = 1;
        };

        const dorlc = function (operand: number) {
            flags.N = 0;
            flags.H = 0;

            flags.C = (operand & 0x80) >>> 7;
            operand = ((operand << 1) | flags.C) & 0xff;

            flags.Z = !operand ? 1 : 0;
            flags.P = getParity(operand);
            flags.S = (operand & 0x80) ? 1 : 0;
            updateXYFlags(operand);

            return operand;
        };

        const dorrc = function (operand: number) {
            flags.N = 0;
            flags.H = 0;

            flags.C = operand & 1;
            operand = ((operand >>> 1) & 0x7f) | (flags.C << 7);

            flags.Z = !(operand & 0xff) ? 1 : 0;
            flags.P = getParity(operand);
            flags.S = (operand & 0x80) ? 1 : 0;
            updateXYFlags(operand);

            return operand & 0xff;
        };

        const dorl = function (operand: number) {
            flags.N = 0;
            flags.H = 0;

            const temp = flags.C;
            flags.C = (operand & 0x80) >>> 7;
            operand = ((operand << 1) | temp) & 0xff;

            flags.Z = !operand ? 1 : 0;
            flags.P = getParity(operand);
            flags.S = (operand & 0x80) ? 1 : 0;
            updateXYFlags(operand);

            return operand;
        };

        const dorr = function (operand: number) {
            flags.N = 0;
            flags.H = 0;

            const temp = flags.C;
            flags.C = operand & 1;
            operand = ((operand >>> 1) & 0x7f) | (temp << 7);

            flags.Z = !operand ? 1 : 0;
            flags.P = getParity(operand);
            flags.S = (operand & 0x80) ? 1 : 0;
            updateXYFlags(operand);

            return operand;
        };

        const dosla = function (operand: number) {
            flags.N = 0;
            flags.H = 0;

            flags.C = (operand & 0x80) >>> 7;
            operand = (operand << 1) & 0xff;

            flags.Z = !operand ? 1 : 0;
            flags.P = getParity(operand);
            flags.S = (operand & 0x80) ? 1 : 0;
            updateXYFlags(operand);

            return operand;
        };

        const dosra = function (operand: number) {
            flags.N = 0;
            flags.H = 0;

            flags.C = operand & 1;
            operand = ((operand >>> 1) & 0x7f) | (operand & 0x80);

            flags.Z = !operand ? 1 : 0;
            flags.P = getParity(operand);
            flags.S = (operand & 0x80) ? 1 : 0;
            updateXYFlags(operand);

            return operand;
        };

        const dosll = function (operand: number) {
            flags.N = 0;
            flags.H = 0;

            flags.C = (operand & 0x80) >>> 7;
            operand = ((operand << 1) & 0xff) | 1;

            flags.Z = !operand ? 1 : 0;
            flags.P = getParity(operand);
            flags.S = (operand & 0x80) ? 1 : 0;
            updateXYFlags(operand);

            return operand;
        };

        const dosrl = function (operand: number) {
            flags.N = 0;
            flags.H = 0;

            flags.C = operand & 1;
            operand = (operand >>> 1) & 0x7f;

            flags.Z = !operand ? 1 : 0;
            flags.P = getParity(operand);
            flags.S = 0;
            updateXYFlags(operand);

            return operand;
        };

        const doIXAdd = function (operand: number) {
            flags.N = 0;

            const result = ix + operand;

            flags.C = (result & 0x10000) ? 1 : 0;
            flags.H = (((ix & 0xfff) + (operand & 0xfff)) & 0x1000) ? 1 : 0;
            updateXYFlags((result & 0xff00) >>> 8);

            ix = result;
        };

    ///////////////////////////////////////////////////////////////////////////////
    /// Like ED, this table is quite sparse,
    ///  and many of the opcodes here are also undocumented.
    /// The undocumented instructions here are those that deal with only one byte
    ///  of the two-byte IX register; the bytes are designed IXH and IXL here.
    ///////////////////////////////////////////////////////////////////////////////
    const ddInstructions: (() => void)[] = [];
    // 0x09 : ADD IX, BC
    ddInstructions[0x09] = function () {
        doIXAdd(c | (b << 8));
    };
    // 0x19 : ADD IX, DE
    ddInstructions[0x19] = function () {
        doIXAdd(e | (d << 8));
    };
    // 0x21 : LD IX, nn
    ddInstructions[0x21] = function () {
        pc = (pc + 1) & 0xffff;
        ix = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        ix |= (core.memRead(pc) << 8);
    };
    // 0x22 : LD (nn), IX
    ddInstructions[0x22] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= (core.memRead(pc) << 8);

        core.memWrite(address, ix & 0xff);
        core.memWrite((address + 1) & 0xffff, (ix >>> 8) & 0xff);
    };
    // 0x23 : INC IX
    ddInstructions[0x23] = function () {
        ix = (ix + 1) & 0xffff;
    };
    // 0x24 : INC IXH (Undocumented)
    ddInstructions[0x24] = function () {
        ix = (doinc(ix >>> 8) << 8) | (ix & 0xff);
    };
    // 0x25 : DEC IXH (Undocumented)
    ddInstructions[0x25] = function () {
        ix = (dodec(ix >>> 8) << 8) | (ix & 0xff);
    };
    // 0x26 : LD IXH, n (Undocumented)
    ddInstructions[0x26] = function () {
        pc = (pc + 1) & 0xffff;
        ix = (core.memRead(pc) << 8) | (ix & 0xff);
    };
    // 0x29 : ADD IX, IX
    ddInstructions[0x29] = function () {
        doIXAdd(ix);
    };
    // 0x2a : LD IX, (nn)
    ddInstructions[0x2a] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= (core.memRead(pc) << 8);

        ix = core.memRead(address);
        ix |= (core.memRead((address + 1) & 0xffff) << 8);
    };
    // 0x2b : DEC IX
    ddInstructions[0x2b] = function () {
        ix = (ix - 1) & 0xffff;
    };
    // 0x2c : INC IXL (Undocumented)
    ddInstructions[0x2c] = function () {
        ix = doinc(ix & 0xff) | (ix & 0xff00);
    };
    // 0x2d : DEC IXL (Undocumented)
    ddInstructions[0x2d] = function () {
        ix = dodec(ix & 0xff) | (ix & 0xff00);
    };
    // 0x2e : LD IXL, n (Undocumented)
    ddInstructions[0x2e] = function () {
        pc = (pc + 1) & 0xffff;
        ix = (core.memRead(pc) & 0xff) | (ix & 0xff00);
    };
    // 0x34 : INC (IX+n)
    ddInstructions[0x34] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc)),
            value = core.memRead((offset + ix) & 0xffff);
        core.memWrite((offset + ix) & 0xffff, doinc(value));
    };
    // 0x35 : DEC (IX+n)
    ddInstructions[0x35] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc)),
            value = core.memRead((offset + ix) & 0xffff);
        core.memWrite((offset + ix) & 0xffff, dodec(value));
    };
    // 0x36 : LD (IX+n), n
    ddInstructions[0x36] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        pc = (pc + 1) & 0xffff;
        core.memWrite((ix + offset) & 0xffff, core.memRead(pc));
    };
    // 0x39 : ADD IX, SP
    ddInstructions[0x39] = function () {
        doIXAdd(sp);
    };
    // 0x44 : LD B, IXH (Undocumented)
    ddInstructions[0x44] = function () {
        b = (ix >>> 8) & 0xff;
    };
    // 0x45 : LD B, IXL (Undocumented)
    ddInstructions[0x45] = function () {
        b = ix & 0xff;
    };
    // 0x46 : LD B, (IX+n)
    ddInstructions[0x46] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        b = core.memRead((ix + offset) & 0xffff);
    };
    // 0x4c : LD C, IXH (Undocumented)
    ddInstructions[0x4c] = function () {
        c = (ix >>> 8) & 0xff;
    };
    // 0x4d : LD C, IXL (Undocumented)
    ddInstructions[0x4d] = function () {
        c = ix & 0xff;
    };
    // 0x4e : LD C, (IX+n)
    ddInstructions[0x4e] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        c = core.memRead((ix + offset) & 0xffff);
    };
    // 0x54 : LD D, IXH (Undocumented)
    ddInstructions[0x54] = function () {
        d = (ix >>> 8) & 0xff;
    };
    // 0x55 : LD D, IXL (Undocumented)
    ddInstructions[0x55] = function () {
        d = ix & 0xff;
    };
    // 0x56 : LD D, (IX+n)
    ddInstructions[0x56] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        d = core.memRead((ix + offset) & 0xffff);
    };
    // 0x5c : LD E, IXH (Undocumented)
    ddInstructions[0x5c] = function () {
        e = (ix >>> 8) & 0xff;
    };
    // 0x5d : LD E, IXL (Undocumented)
    ddInstructions[0x5d] = function () {
        e = ix & 0xff;
    };
    // 0x5e : LD E, (IX+n)
    ddInstructions[0x5e] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        e = core.memRead((ix + offset) & 0xffff);
    };
    // 0x60 : LD IXH, B (Undocumented)
    ddInstructions[0x60] = function () {
        ix = (ix & 0xff) | (b << 8);
    };
    // 0x61 : LD IXH, C (Undocumented)
    ddInstructions[0x61] = function () {
        ix = (ix & 0xff) | (c << 8);
    };
    // 0x62 : LD IXH, D (Undocumented)
    ddInstructions[0x62] = function () {
        ix = (ix & 0xff) | (d << 8);
    };
    // 0x63 : LD IXH, E (Undocumented)
    ddInstructions[0x63] = function () {
        ix = (ix & 0xff) | (e << 8);
    };
    // 0x64 : LD IXH, IXH (Undocumented)
    ddInstructions[0x64] = function () {
        // No-op.
    };
    // 0x65 : LD IXH, IXL (Undocumented)
    ddInstructions[0x65] = function () {
        ix = (ix & 0xff) | ((ix & 0xff) << 8);
    };
    // 0x66 : LD H, (IX+n)
    ddInstructions[0x66] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        h = core.memRead((ix + offset) & 0xffff);
    };
    // 0x67 : LD IXH, A (Undocumented)
    ddInstructions[0x67] = function () {
        ix = (ix & 0xff) | (a << 8);
    };
    // 0x68 : LD IXL, B (Undocumented)
    ddInstructions[0x68] = function () {
        ix = (ix & 0xff00) | b;
    };
    // 0x69 : LD IXL, C (Undocumented)
    ddInstructions[0x69] = function () {
        ix = (ix & 0xff00) | c;
    };
    // 0x6a : LD IXL, D (Undocumented)
    ddInstructions[0x6a] = function () {
        ix = (ix & 0xff00) | d;
    };
    // 0x6b : LD IXL, E (Undocumented)
    ddInstructions[0x6b] = function () {
        ix = (ix & 0xff00) | e;
    };
    // 0x6c : LD IXL, IXH (Undocumented)
    ddInstructions[0x6c] = function () {
        ix = (ix & 0xff00) | (ix >>> 8);
    };
    // 0x6d : LD IXL, IXL (Undocumented)
    ddInstructions[0x6d] = function () {
        // No-op.
    };
    // 0x6e : LD L, (IX+n)
    ddInstructions[0x6e] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        l = core.memRead((ix + offset) & 0xffff);
    };
    // 0x6f : LD IXL, A (Undocumented)
    ddInstructions[0x6f] = function () {
        ix = (ix & 0xff00) | a;
    };
    // 0x70 : LD (IX+n), B
    ddInstructions[0x70] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        core.memWrite((ix + offset) & 0xffff, b);
    };
    // 0x71 : LD (IX+n), C
    ddInstructions[0x71] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        core.memWrite((ix + offset) & 0xffff, c);
    };
    // 0x72 : LD (IX+n), D
    ddInstructions[0x72] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        core.memWrite((ix + offset) & 0xffff, d);
    };
    // 0x73 : LD (IX+n), E
    ddInstructions[0x73] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        core.memWrite((ix + offset) & 0xffff, e);
    };
    // 0x74 : LD (IX+n), H
    ddInstructions[0x74] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        core.memWrite((ix + offset) & 0xffff, h);
    };
    // 0x75 : LD (IX+n), L
    ddInstructions[0x75] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        core.memWrite((ix + offset) & 0xffff, l);
    };
    // 0x77 : LD (IX+n), A
    ddInstructions[0x77] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        core.memWrite((ix + offset) & 0xffff, a);
    };
    // 0x7c : LD A, IXH (Undocumented)
    ddInstructions[0x7c] = function () {
        a = (ix >>> 8) & 0xff;
    };
    // 0x7d : LD A, IXL (Undocumented)
    ddInstructions[0x7d] = function () {
        a = ix & 0xff;
    };
    // 0x7e : LD A, (IX+n)
    ddInstructions[0x7e] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        a = core.memRead((ix + offset) & 0xffff);
    };
    // 0x84 : ADD A, IXH (Undocumented)
    ddInstructions[0x84] = function () {
        doadd((ix >>> 8) & 0xff);
    };
    // 0x85 : ADD A, IXL (Undocumented)
    ddInstructions[0x85] = function () {
        doadd(ix & 0xff);
    };
    // 0x86 : ADD A, (IX+n)
    ddInstructions[0x86] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        doadd(core.memRead((ix + offset) & 0xffff));
    };
    // 0x8c : ADC A, IXH (Undocumented)
    ddInstructions[0x8c] = function () {
        doadc((ix >>> 8) & 0xff);
    };
    // 0x8d : ADC A, IXL (Undocumented)
    ddInstructions[0x8d] = function () {
        doadc(ix & 0xff);
    };
    // 0x8e : ADC A, (IX+n)
    ddInstructions[0x8e] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        doadc(core.memRead((ix + offset) & 0xffff));
    };
    // 0x94 : SUB IXH (Undocumented)
    ddInstructions[0x94] = function () {
        dosub((ix >>> 8) & 0xff);
    };
    // 0x95 : SUB IXL (Undocumented)
    ddInstructions[0x95] = function () {
        dosub(ix & 0xff);
    };
    // 0x96 : SUB A, (IX+n)
    ddInstructions[0x96] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        dosub(core.memRead((ix + offset) & 0xffff));
    };
    // 0x9c : SBC IXH (Undocumented)
    ddInstructions[0x9c] = function () {
        dosbc((ix >>> 8) & 0xff);
    };
    // 0x9d : SBC IXL (Undocumented)
    ddInstructions[0x9d] = function () {
        dosbc(ix & 0xff);
    };
    // 0x9e : SBC A, (IX+n)
    ddInstructions[0x9e] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        dosbc(core.memRead((ix + offset) & 0xffff));
    };
    // 0xa4 : AND IXH (Undocumented)
    ddInstructions[0xa4] = function () {
        doand((ix >>> 8) & 0xff);
    };
    // 0xa5 : AND IXL (Undocumented)
    ddInstructions[0xa5] = function () {
        doand(ix & 0xff);
    };
    // 0xa6 : AND A, (IX+n)
    ddInstructions[0xa6] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        doand(core.memRead((ix + offset) & 0xffff));
    };
    // 0xac : XOR IXH (Undocumented)
    ddInstructions[0xac] = function () {
        doxor((ix >>> 8) & 0xff);
    };
    // 0xad : XOR IXL (Undocumented)
    ddInstructions[0xad] = function () {
        doxor(ix & 0xff);
    };
    // 0xae : XOR A, (IX+n)
    ddInstructions[0xae] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        doxor(core.memRead((ix + offset) & 0xffff));
    };
    // 0xb4 : OR IXH (Undocumented)
    ddInstructions[0xb4] = function () {
        door((ix >>> 8) & 0xff);
    };
    // 0xb5 : OR IXL (Undocumented)
    ddInstructions[0xb5] = function () {
        door(ix & 0xff);
    };
    // 0xb6 : OR A, (IX+n)
    ddInstructions[0xb6] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        door(core.memRead((ix + offset) & 0xffff));
    };
    // 0xbc : CP IXH (Undocumented)
    ddInstructions[0xbc] = function () {
        docp((ix >>> 8) & 0xff);
    };
    // 0xbd : CP IXL (Undocumented)
    ddInstructions[0xbd] = function () {
        docp(ix & 0xff);
    };
    // 0xbe : CP A, (IX+n)
    ddInstructions[0xbe] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        docp(core.memRead((ix + offset) & 0xffff));
    };
    // 0xcb : CB Prefix (IX bit instructions)
    ddInstructions[0xcb] = function () {
        pc = (pc + 1) & 0xffff;
        const offset = getSignedOffsetByte(core.memRead(pc));
        pc = (pc + 1) & 0xffff;
        const opcode = core.memRead(pc);
        let value;

        // As with the "normal" CB prefix, we implement the DDCB prefix
        //  by decoding the opcode directly, rather than using a table.
        if (opcode < 0x40) {
            // Shift and rotate instructions.
            const ddcbFunctions = [dorlc, dorrc, dorl, dorr,
                dosla, dosra, dosll, dosrl];

            // Most of the opcodes in this range are not valid,
            //  so we map this opcode onto one of the ones that is.
            const func = ddcbFunctions[(opcode & 0x38) >>> 3];
            value = func(core.memRead((ix + offset) & 0xffff));

            core.memWrite((ix + offset) & 0xffff, value);
        }
        else {
            const bitNumber = (opcode & 0x38) >>> 3;

            if (opcode < 0x80) {
                // BIT
                flags.N = 0;
                flags.H = 1;
                flags.Z = !(core.memRead((ix + offset) & 0xffff) & (1 << bitNumber)) ? 1 : 0;
                flags.P = flags.Z;
                flags.S = ((bitNumber === 7) && !flags.Z) ? 1 : 0;
            }
            else if (opcode < 0xc0) {
                // RES
                value = core.memRead((ix + offset) & 0xffff) & ~(1 << bitNumber) & 0xff;
                core.memWrite((ix + offset) & 0xffff, value);
            }
            else {
                // SET
                value = core.memRead((ix + offset) & 0xffff) | (1 << bitNumber);
                core.memWrite((ix + offset) & 0xffff, value);
            }
        }

        // This implements the undocumented shift, RES, and SET opcodes,
        //  which write their result to memory and also to an 8080 register.
        if (value !== undefined) {
            if ((opcode & 0x07) === 0)
                b = value;
            else if ((opcode & 0x07) === 1)
                c = value;
            else if ((opcode & 0x07) === 2)
                d = value;
            else if ((opcode & 0x07) === 3)
                e = value;
            else if ((opcode & 0x07) === 4)
                h = value;
            else if ((opcode & 0x07) === 5)
                l = value;
            // 6 is the documented opcode, which doesn't set a register.
            else if ((opcode & 0x07) === 7)
                a = value;
        }

        cycleCounter += cycleCountsCB[opcode] + 8;
    };
    // 0xe1 : POP IX
    ddInstructions[0xe1] = function () {
        ix = popWord();
    };
    // 0xe3 : EX (SP), IX
    ddInstructions[0xe3] = function () {
        const temp = ix;
        ix = core.memRead(sp);
        ix |= core.memRead((sp + 1) & 0xffff) << 8;
        core.memWrite(sp, temp & 0xff);
        core.memWrite((sp + 1) & 0xffff, (temp >>> 8) & 0xff);
    };
    // 0xe5 : PUSH IX
    ddInstructions[0xe5] = function () {
        pushWord(ix);
    };
    // 0xe9 : JP (IX)
    ddInstructions[0xe9] = function () {
        pc = (ix - 1) & 0xffff;
    };
    // 0xf9 : LD SP, IX
    ddInstructions[0xf9] = function () {
        sp = ix;
    };

    ///////////////////////////////////////////////////////////////////////////////
    /// This table of ED opcodes is pretty sparse;
    ///  there are not very many valid ED-prefixed opcodes in the Z80,
    ///  and many of the ones that are valid are not documented.
    ///////////////////////////////////////////////////////////////////////////////
    const edInstructions: any[] = [];
    // 0x40 : IN B, (C)
    edInstructions[0x40] = function () {
        b = doin((b << 8) | c);
    };
    // 0x41 : OUT (C), B
    edInstructions[0x41] = function () {
        core.ioWrite((b << 8) | c, b);
    };
    // 0x42 : SBC HL, BC
    edInstructions[0x42] = function () {
        doHLsbc(c | (b << 8));
    };
    // 0x43 : LD (nn), BC
    edInstructions[0x43] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        core.memWrite(address, c);
        core.memWrite((address + 1) & 0xffff, b);
    };
    // 0x44 : NEG
    edInstructions[0x44] = function () {
        doneg();
    };
    // 0x45 : RETN
    edInstructions[0x45] = function () {
        pc = (popWord() - 1) & 0xffff;
        iff1 = iff2;
    };
    // 0x46 : IM 0
    edInstructions[0x46] = function () {
        imode = 0;
    };
    // 0x47 : LD I, A
    edInstructions[0x47] = function () {
        i = a
    };
    // 0x48 : IN C, (C)
    edInstructions[0x48] = function () {
        c = doin((b << 8) | c);
    };
    // 0x49 : OUT (C), C
    edInstructions[0x49] = function () {
        core.ioWrite((b << 8) | c, c);
    };
    // 0x4a : ADC HL, BC
    edInstructions[0x4a] = function () {
        doHLadc(c | (b << 8));
    };
    // 0x4b : LD BC, (nn)
    edInstructions[0x4b] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        c = core.memRead(address);
        b = core.memRead((address + 1) & 0xffff);
    };
    // 0x4c : NEG (Undocumented)
    edInstructions[0x4c] = function () {
        doneg();
    };
    // 0x4d : RETI
    edInstructions[0x4d] = function () {
        pc = (popWord() - 1) & 0xffff;
    };
    // 0x4e : IM 0 (Undocumented)
    edInstructions[0x4e] = function () {
        imode = 0;
    };
    // 0x4f : LD R, A
    edInstructions[0x4f] = function () {
        r = a;
    };
    // 0x50 : IN D, (C)
    edInstructions[0x50] = function () {
        d = doin((b << 8) | c);
    };
    // 0x51 : OUT (C), D
    edInstructions[0x51] = function () {
        core.ioWrite((b << 8) | c, d);
    };
    // 0x52 : SBC HL, DE
    edInstructions[0x52] = function () {
        doHLsbc(e | (d << 8));
    };
    // 0x53 : LD (nn), DE
    edInstructions[0x53] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        core.memWrite(address, e);
        core.memWrite((address + 1) & 0xffff, d);
    };
    // 0x54 : NEG (Undocumented)
    edInstructions[0x54] = function () {
        doneg();
    };
    // 0x55 : RETN
    edInstructions[0x55] = function () {
        pc = (popWord() - 1) & 0xffff;
        iff1 = iff2;
    };
    // 0x56 : IM 1
    edInstructions[0x56] = function () {
        imode = 1;
    };
    // 0x57 : LD A, I
    edInstructions[0x57] = function () {
        a = i;
        flags.S = i & 0x80 ? 1 : 0;
        flags.Z = i ? 0 : 1;
        flags.H = 0;
        flags.P = iff2;
        flags.N = 0;
    };
    // 0x58 : IN E, (C)
    edInstructions[0x58] = function () {
        e = doin((b << 8) | c);
    };
    // 0x59 : OUT (C), E
    edInstructions[0x59] = function () {
        core.ioWrite((b << 8) | c, e);
    };
    // 0x5a : ADC HL, DE
    edInstructions[0x5a] = function () {
        doHLadc(e | (d << 8));
    };
    // 0x5b : LD DE, (nn)
    edInstructions[0x5b] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        e = core.memRead(address);
        d = core.memRead((address + 1) & 0xffff);
    };
    // 0x5c : NEG (Undocumented)
    edInstructions[0x5c] = function () {
        doneg();
    };
    // 0x5d : RETN
    edInstructions[0x5d] = function () {
        pc = (popWord() - 1) & 0xffff;
        iff1 = iff2;
    };
    // 0x5e : IM 2
    edInstructions[0x5e] = function () {
        imode = 2;
    };
    // 0x5f : LD A, R
    edInstructions[0x5f] = function () {
        a = r;
        flags.P = iff2;
    };
    // 0x60 : IN H, (C)
    edInstructions[0x60] = function () {
        h = doin((b << 8) | c);
    };
    // 0x61 : OUT (C), H
    edInstructions[0x61] = function () {
        core.ioWrite((b << 8) | c, h);
    };
    // 0x62 : SBC HL, HL
    edInstructions[0x62] = function () {
        doHLsbc(l | (h << 8));
    };
    // 0x63 : LD (nn), HL (Undocumented)
    edInstructions[0x63] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        core.memWrite(address, l);
        core.memWrite((address + 1) & 0xffff, h);
    };
    // 0x64 : NEG (Undocumented)
    edInstructions[0x64] = function () {
        doneg();
    };
    // 0x65 : RETN
    edInstructions[0x65] = function () {
        pc = (popWord() - 1) & 0xffff;
        iff1 = iff2;
    };
    // 0x66 : IM 0
    edInstructions[0x66] = function () {
        imode = 0;
    };
    // 0x67 : RRD
    edInstructions[0x67] = function () {
        let HLValue = core.memRead(l | (h << 8));
        const temp1 = HLValue & 0x0f, temp2 = a & 0x0f;
        HLValue = ((HLValue & 0xf0) >>> 4) | (temp2 << 4);
        a = (a & 0xf0) | temp1;
        core.memWrite(l | (h << 8), HLValue);

        flags.S = (a & 0x80) ? 1 : 0;
        flags.Z = a ? 0 : 1;
        flags.H = 0;
        flags.P = getParity(a) ? 1 : 0;
        flags.N = 0;
        updateXYFlags(a);
    };
    // 0x68 : IN L, (C)
    edInstructions[0x68] = function () {
        l = doin((b << 8) | c);
    };
    // 0x69 : OUT (C), L
    edInstructions[0x69] = function () {
        core.ioWrite((b << 8) | c, l);
    };
    // 0x6a : ADC HL, HL
    edInstructions[0x6a] = function () {
        doHLadc(l | (h << 8));
    };
    // 0x6b : LD HL, (nn) (Undocumented)
    edInstructions[0x6b] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        l = core.memRead(address);
        h = core.memRead((address + 1) & 0xffff);
    };
    // 0x6c : NEG (Undocumented)
    edInstructions[0x6c] = function () {
        doneg();
    };
    // 0x6d : RETN
    edInstructions[0x6d] = function () {
        pc = (popWord() - 1) & 0xffff;
        iff1 = iff2;
    };
    // 0x6e : IM 0 (Undocumented)
    edInstructions[0x6e] = function () {
        imode = 0;
    };
    // 0x6f : RLD
    edInstructions[0x6f] = function () {
        let HLValue = core.memRead(l | (h << 8));
        const temp1 = HLValue & 0xf0, temp2 = a & 0x0f;
        HLValue = ((HLValue & 0x0f) << 4) | temp2;
        a = (a & 0xf0) | (temp1 >>> 4);
        core.memWrite(l | (h << 8), HLValue);

        flags.S = (a & 0x80) ? 1 : 0;
        flags.Z = a ? 0 : 1;
        flags.H = 0;
        flags.P = getParity(a) ? 1 : 0;
        flags.N = 0;
        updateXYFlags(a);
    };
    // 0x70 : IN (C) (Undocumented)
    edInstructions[0x70] = function () {
        doin((b << 8) | c);
    };
    // 0x71 : OUT (C), 0 (Undocumented)
    edInstructions[0x71] = function () {
        core.ioWrite((b << 8) | c, 0);
    };
    // 0x72 : SBC HL, SP
    edInstructions[0x72] = function () {
        doHLsbc(sp);
    };
    // 0x73 : LD (nn), SP
    edInstructions[0x73] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        core.memWrite(address, sp & 0xff);
        core.memWrite((address + 1) & 0xffff, (sp >>> 8) & 0xff);
    };
    // 0x74 : NEG (Undocumented)
    edInstructions[0x74] = function () {
        doneg();
    };
    // 0x75 : RETN
    edInstructions[0x75] = function () {
        pc = (popWord() - 1) & 0xffff;
        iff1 = iff2;
    };
    // 0x76 : IM 1
    edInstructions[0x76] = function () {
        imode = 1;
    };
    // 0x78 : IN A, (C)
    edInstructions[0x78] = function () {
        a = doin((b << 8) | c);
    };
    // 0x79 : OUT (C), A
    edInstructions[0x79] = function () {
        core.ioWrite((b << 8) | c, a);
    };
    // 0x7a : ADC HL, SP
    edInstructions[0x7a] = function () {
        doHLadc(sp);
    };
    // 0x7b : LD SP, (nn)
    edInstructions[0x7b] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        sp = core.memRead(address);
        sp |= core.memRead((address + 1) & 0xffff) << 8;
    };
    // 0x7c : NEG (Undocumented)
    edInstructions[0x7c] = function () {
        doneg();
    };
    // 0x7d : RETN
    edInstructions[0x7d] = function () {
        pc = (popWord() - 1) & 0xffff;
        iff1 = iff2;
    };
    // 0x7e : IM 2
    edInstructions[0x7e] = function () {
        imode = 2;
    };
    // 0xa0 : LDI
    edInstructions[0xa0] = function () {
        doldi();
    };
    // 0xa1 : CPI
    edInstructions[0xa1] = function () {
        docpi();
    };
    // 0xa2 : INI
    edInstructions[0xa2] = function () {
        doini();
    };
    // 0xa3 : OUTI
    edInstructions[0xa3] = function () {
        doouti();
    };
    // 0xa8 : LDD
    edInstructions[0xa8] = function () {
        doldd();
    };
    // 0xa9 : CPD
    edInstructions[0xa9] = function () {
        docpd();
    };
    // 0xaa : IND
    edInstructions[0xaa] = function () {
        doind();
    };
    // 0xab : OUTD
    edInstructions[0xab] = function () {
        dooutd();
    };
    // 0xb0 : LDIR
    edInstructions[0xb0] = function () {
        doldi();
        if (b || c) {
            cycleCounter += 5;
            pc = (pc - 2) & 0xffff;
        }
    };
    // 0xb1 : CPIR
    edInstructions[0xb1] = function () {
        docpi();
        if (!flags.Z && (b || c)) {
            cycleCounter += 5;
            pc = (pc - 2) & 0xffff;
        }
    };
    // 0xb2 : INIR
    edInstructions[0xb2] = function () {
        doini();
        if (b) {
            cycleCounter += 5;
            pc = (pc - 2) & 0xffff;
        }
    };
    // 0xb3 : OTIR
    edInstructions[0xb3] = function () {
        doouti();
        if (b) {
            cycleCounter += 5;
            pc = (pc - 2) & 0xffff;
        }
    };
    // 0xb8 : LDDR
    edInstructions[0xb8] = function () {
        doldd();
        if (b || c) {
            cycleCounter += 5;
            pc = (pc - 2) & 0xffff;
        }
    };
    // 0xb9 : CPDR
    edInstructions[0xb9] = function () {
        docpd();
        if (!flags.Z && (b || c)) {
            cycleCounter += 5;
            pc = (pc - 2) & 0xffff;
        }
    };
    // 0xba : INDR
    edInstructions[0xba] = function () {
        doind();
        if (b) {
            cycleCounter += 5;
            pc = (pc - 2) & 0xffff;
        }
    };
    // 0xbb : OTDR
    edInstructions[0xbb] = function () {
        dooutd();
        if (b) {
            cycleCounter += 5;
            pc = (pc - 2) & 0xffff;
        }
    };




    ///////////////////////////////////////////////////////////////////////////////
    /// This table contains the implementations for the instructions that weren't
    ///  implemented directly in the decoder function (everything but the 8-bit
    ///  register loads and the accumulator ALU instructions, in other words).
    /// Similar tables for the ED and DD/FD prefixes follow this one.
    ///////////////////////////////////////////////////////////////////////////////
    const instructions: any[] = [];

    // 0x00 : NOP
    instructions[0x00] = function () { return };
    // 0x01 : LD BC, nn
    instructions[0x01] = function () {
        pc = (pc + 1) & 0xffff;
        c = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        b = core.memRead(pc);
    };
    // 0x02 : LD (BC), A
    instructions[0x02] = function () {
        core.memWrite(c | (b << 8), a);
    };
    // 0x03 : INC BC
    instructions[0x03] = function () {
        let result = (c | (b << 8));
        result += 1;
        c = result & 0xff;
        b = (result & 0xff00) >>> 8;
    };
    // 0x04 : INC B
    instructions[0x04] = function () {
        b = doinc(b);
    };
    // 0x05 : DEC B
    instructions[0x05] = function () {
        b = dodec(b);
    };
    // 0x06 : LD B, n
    instructions[0x06] = function () {
        pc = (pc + 1) & 0xffff;
        b = core.memRead(pc);
    };
    // 0x07 : RLCA
    instructions[0x07] = function () {
        // This instruction is implemented as a special case of the
        //  more general Z80-specific RLC instruction.
        // Specifially, RLCA is a version of RLC A that affects fewer flags.
        // The same applies to RRCA, RLA, and RRA.
        const tempS = flags.S, tempZ = flags.Z, tempP = flags.P;
        a = dorlc(a);
        flags.S = tempS;
        flags.Z = tempZ;
        flags.P = tempP;
    };
    // 0x08 : EX AF, AF'
    instructions[0x08] = function () {
        let temp = a;
        a = aPrime;
        aPrime = temp;

        temp = getFlagsRegister();
        setFlagsRegister(getFlagsPrime());
        setFlagsPrime(temp);
    };
    // 0x09 : ADD HL, BC
    instructions[0x09] = function () {
        doHLadd(c | (b << 8));
    };
    // 0x0a : LD A, (BC)
    instructions[0x0a] = function () {
        a = core.memRead(c | (b << 8));
    };
    // 0x0b : DEC BC
    instructions[0x0b] = function () {
        let result = (c | (b << 8));
        result -= 1;
        c = result & 0xff;
        b = (result & 0xff00) >>> 8;
    };
    // 0x0c : INC C
    instructions[0x0c] = function () {
        c = doinc(c);
    };
    // 0x0d : DEC C
    instructions[0x0d] = function () {
        c = dodec(c);
    };
    // 0x0e : LD C, n
    instructions[0x0e] = function () {
        pc = (pc + 1) & 0xffff;
        c = core.memRead(pc);
    };
    // 0x0f : RRCA
    instructions[0x0f] = function () {
        const tempS = flags.S, tempZ = flags.Z, tempP = flags.P;
        a = dorrc(a);
        flags.S = tempS;
        flags.Z = tempZ;
        flags.P = tempP;
    };
    // 0x10 : DJNZ nn
    instructions[0x10] = function () {
        b = (b - 1) & 0xff;
        doConditionalRelativeJump(b !== 0);
    };
    // 0x11 : LD DE, nn
    instructions[0x11] = function () {
        pc = (pc + 1) & 0xffff;
        e = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        d = core.memRead(pc);
    };
    // 0x12 : LD (DE), A
    instructions[0x12] = function () {
        core.memWrite(e | (d << 8), a);
    };
    // 0x13 : INC DE
    instructions[0x13] = function () {
        let result = (e | (d << 8));
        result += 1;
        e = result & 0xff;
        d = (result & 0xff00) >>> 8;
    };
    // 0x14 : INC D
    instructions[0x14] = function () {
        d = doinc(d);
    };
    // 0x15 : DEC D
    instructions[0x15] = function () {
        d = dodec(d);
    };
    // 0x16 : LD D, n
    instructions[0x16] = function () {
        pc = (pc + 1) & 0xffff;
        d = core.memRead(pc);
    };
    // 0x17 : RLA
    instructions[0x17] = function () {
        const tempS = flags.S, tempZ = flags.Z, tempP = flags.P;
        a = dorl(a);
        flags.S = tempS;
        flags.Z = tempZ;
        flags.P = tempP;
    };
    // 0x18 : JR n
    instructions[0x18] = function () {
        const offset = getSignedOffsetByte(core.memRead((pc + 1) & 0xffff));
        pc = (pc + offset + 1) & 0xffff;
    };
    // 0x19 : ADD HL, DE
    instructions[0x19] = function () {
        doHLadd(e | (d << 8));
    };
    // 0x1a : LD A, (DE)
    instructions[0x1a] = function () {
        a = core.memRead(e | (d << 8));
    };
    // 0x1b : DEC DE
    instructions[0x1b] = function () {
        let result = (e | (d << 8));
        result -= 1;
        e = result & 0xff;
        d = (result & 0xff00) >>> 8;
    };
    // 0x1c : INC E
    instructions[0x1c] = function () {
        e = doinc(e);
    };
    // 0x1d : DEC E
    instructions[0x1d] = function () {
        e = dodec(e);
    };
    // 0x1e : LD E, n
    instructions[0x1e] = function () {
        pc = (pc + 1) & 0xffff;
        e = core.memRead(pc);
    };
    // 0x1f : RRA
    instructions[0x1f] = function () {
        const tempS = flags.S, tempZ = flags.Z, tempP = flags.P;
        a = dorr(a);
        flags.S = tempS;
        flags.Z = tempZ;
        flags.P = tempP;
    };
    // 0x20 : JR NZ, n
    instructions[0x20] = function () {
        doConditionalRelativeJump(!flags.Z);
    };
    // 0x21 : LD HL, nn
    instructions[0x21] = function () {
        pc = (pc + 1) & 0xffff;
        l = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        h = core.memRead(pc);
    };
    // 0x22 : LD (nn), HL
    instructions[0x22] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        core.memWrite(address, l);
        core.memWrite((address + 1) & 0xffff, h);
    };
    // 0x23 : INC HL
    instructions[0x23] = function () {
        let result = (l | (h << 8));
        result += 1;
        l = result & 0xff;
        h = (result & 0xff00) >>> 8;
    };
    // 0x24 : INC H
    instructions[0x24] = function () {
        h = doinc(h);
    };
    // 0x25 : DEC H
    instructions[0x25] = function () {
        h = dodec(h);
    };
    // 0x26 : LD H, n
    instructions[0x26] = function () {
        pc = (pc + 1) & 0xffff;
        h = core.memRead(pc);
    };
    // 0x27 : DAA
    instructions[0x27] = function () {
        let temp = a;
        if (!flags.N) {
            if (flags.H || ((a & 0x0f) > 9))
                temp += 0x06;
            if (flags.C || (a > 0x99))
                temp += 0x60;
        }
        else {
            if (flags.H || ((a & 0x0f) > 9))
                temp -= 0x06;
            if (flags.C || (a > 0x99))
                temp -= 0x60;
        }

        flags.S = (temp & 0x80) ? 1 : 0;
        flags.Z = !(temp & 0xff) ? 1 : 0;
        flags.H = ((a & 0x10) ^ (temp & 0x10)) ? 1 : 0;
        flags.P = getParity(temp & 0xff);
        // DAA never clears the carry flag if it was already set,
        //  but it is able to set the carry flag if it was clear.
        // Don't ask me, I don't know.
        // Note also that we check for a BCD carry, instead of the usual.
        flags.C = (flags.C || (a > 0x99)) ? 1 : 0;

        a = temp & 0xff;

        updateXYFlags(a);
    };
    // 0x28 : JR Z, n
    instructions[0x28] = function () {
        doConditionalRelativeJump(!!flags.Z);
    };
    // 0x29 : ADD HL, HL
    instructions[0x29] = function () {
        doHLadd(l | (h << 8));
    };
    // 0x2a : LD HL, (nn)
    instructions[0x2a] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        l = core.memRead(address);
        h = core.memRead((address + 1) & 0xffff);
    };
    // 0x2b : DEC HL
    instructions[0x2b] = function () {
        let result = (l | (h << 8));
        result -= 1;
        l = result & 0xff;
        h = (result & 0xff00) >>> 8;
    };
    // 0x2c : INC L
    instructions[0x2c] = function () {
        l = doinc(l);
    };
    // 0x2d : DEC L
    instructions[0x2d] = function () {
        l = dodec(l);
    };
    // 0x2e : LD L, n
    instructions[0x2e] = function () {
        pc = (pc + 1) & 0xffff;
        l = core.memRead(pc);
    };
    // 0x2f : CPL
    instructions[0x2f] = function () {
        a = (~a) & 0xff;
        flags.N = 1;
        flags.H = 1;
        updateXYFlags(a);
    };
    // 0x30 : JR NC, n
    instructions[0x30] = function () {
        doConditionalRelativeJump(!flags.C);
    };
    // 0x31 : LD SP, nn
    instructions[0x31] = function () {
        sp = core.memRead((pc + 1) & 0xffff) |
            (core.memRead((pc + 2) & 0xffff) << 8);
        pc = (pc + 2) & 0xffff;
    };
    // 0x32 : LD (nn), A
    instructions[0x32] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        core.memWrite(address, a);
    };
    // 0x33 : INC SP
    instructions[0x33] = function () {
        sp = (sp + 1) & 0xffff;
    };
    // 0x34 : INC (HL)
    instructions[0x34] = function () {
        const address = l | (h << 8);
        core.memWrite(address, doinc(core.memRead(address)));
    };
    // 0x35 : DEC (HL)
    instructions[0x35] = function () {
        const address = l | (h << 8);
        core.memWrite(address, dodec(core.memRead(address)));
    };
    // 0x36 : LD (HL), n
    instructions[0x36] = function () {
        pc = (pc + 1) & 0xffff;
        core.memWrite(l | (h << 8), core.memRead(pc));
    };
    // 0x37 : SCF
    instructions[0x37] = function () {
        flags.N = 0;
        flags.H = 0;
        flags.C = 1;
        updateXYFlags(a);
    };
    // 0x38 : JR C, n
    instructions[0x38] = function () {
        doConditionalRelativeJump(!!flags.C);
    };
    // 0x39 : ADD HL, SP
    instructions[0x39] = function () {
        doHLadd(sp);
    };
    // 0x3a : LD A, (nn)
    instructions[0x3a] = function () {
        pc = (pc + 1) & 0xffff;
        let address = core.memRead(pc);
        pc = (pc + 1) & 0xffff;
        address |= core.memRead(pc) << 8;

        a = core.memRead(address);
    };
    // 0x3b : DEC SP
    instructions[0x3b] = function () {
        sp = (sp - 1) & 0xffff;
    };
    // 0x3c : INC A
    instructions[0x3c] = function () {
        a = doinc(a);
    };
    // 0x3d : DEC A
    instructions[0x3d] = function () {
        a = dodec(a);
    };
    // 0x3e : LD A, n
    instructions[0x3e] = function () {
        a = core.memRead((pc + 1) & 0xffff);
        pc = (pc + 1) & 0xffff;
    };
    // 0x3f : CCF
    instructions[0x3f] = function () {
        flags.N = 0;
        flags.H = flags.C;
        flags.C = flags.C ? 0 : 1;
        updateXYFlags(a);
    };
    // 0xc0 : RET NZ
    instructions[0xc0] = function () {
        doconditionalReturn(!flags.Z);
    };
    // 0xc1 : POP BC
    instructions[0xc1] = function () {
        const result = popWord();
        c = result & 0xff;
        b = (result & 0xff00) >>> 8;
    };
    // 0xc2 : JP NZ, nn
    instructions[0xc2] = function () {
        doConditionalAbsoluteJump(!flags.Z);
    };
    // 0xc3 : JP nn
    instructions[0xc3] = function () {
        pc = core.memRead((pc + 1) & 0xffff) |
            (core.memRead((pc + 2) & 0xffff) << 8);
        pc = (pc - 1) & 0xffff;
    };
    // 0xc4 : CALL NZ, nn
    instructions[0xc4] = function () {
        doconditionalCall(!flags.Z);
    };
    // 0xc5 : PUSH BC
    instructions[0xc5] = function () {
        pushWord(c | (b << 8));
    };
    // 0xc6 : ADD A, n
    instructions[0xc6] = function () {
        pc = (pc + 1) & 0xffff;
        doadd(core.memRead(pc));
    };
    // 0xc7 : RST 00h
    instructions[0xc7] = function () {
        doreset(0x00);
    };
    // 0xc8 : RET Z
    instructions[0xc8] = function () {
        doconditionalReturn(!!flags.Z);
    };
    // 0xc9 : RET
    instructions[0xc9] = function () {
        pc = (popWord() - 1) & 0xffff;
    };
    // 0xca : JP Z, nn
    instructions[0xca] = function () {
        doConditionalAbsoluteJump(!!flags.Z);
    };
    // 0xcb : CB Prefix
    instructions[0xcb] = function () {
        // R is incremented at the start of the second instruction cycle,
        //  before the instruction actually runs.
        // The high bit of R is not affected by this increment,
        //  it can only be changed using the LD R, A instruction.
        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);

        // We don't have a table for this prefix,
        //  the instructions are all so uniform that we can directly decode them.
        pc = (pc + 1) & 0xffff;
        const opcode = core.memRead(pc),
            bitNumber = (opcode & 0x38) >>> 3,
            regCode = opcode & 0x07;

        if (opcode < 0x40) {
            // Shift/rotate instructions
            const opArray = [dorlc, dorrc, dorl, dorr,
                dosla, dosra, dosll, dosrl];

            if (regCode === 0)
                b = opArray[bitNumber](b);
            else if (regCode === 1)
                c = opArray[bitNumber](c);
            else if (regCode === 2)
                d = opArray[bitNumber](d);
            else if (regCode === 3)
                e = opArray[bitNumber](e);
            else if (regCode === 4)
                h = opArray[bitNumber](h);
            else if (regCode === 5)
                l = opArray[bitNumber](l);
            else if (regCode === 6)
                core.memWrite(l | (h << 8),
                    opArray[bitNumber](core.memRead(l | (h << 8))));
            else if (regCode === 7)
                a = opArray[bitNumber](a);
        }
        else if (opcode < 0x80) {
            // BIT instructions
            if (regCode === 0)
                flags.Z = !(b & (1 << bitNumber)) ? 1 : 0;
            else if (regCode === 1)
                flags.Z = !(c & (1 << bitNumber)) ? 1 : 0;
            else if (regCode === 2)
                flags.Z = !(d & (1 << bitNumber)) ? 1 : 0;
            else if (regCode === 3)
                flags.Z = !(e & (1 << bitNumber)) ? 1 : 0;
            else if (regCode === 4)
                flags.Z = !(h & (1 << bitNumber)) ? 1 : 0;
            else if (regCode === 5)
                flags.Z = !(l & (1 << bitNumber)) ? 1 : 0;
            else if (regCode === 6)
                flags.Z = !((core.memRead(l | (h << 8))) & (1 << bitNumber)) ? 1 : 0;
            else if (regCode === 7)
                flags.Z = !(a & (1 << bitNumber)) ? 1 : 0;

            flags.N = 0;
            flags.H = 1;
            flags.P = flags.Z;
            flags.S = ((bitNumber === 7) && !flags.Z) ? 1 : 0;
            // For the BIT n, (HL) instruction, the X and Y flags are obtained
            //  from what is apparently an internal temporary register used for
            //  some of the 16-bit arithmetic instructions.
            // I haven't implemented that register here,
            //  so for now we'll set X and Y the same way for every BIT opcode,
            //  which means that they will usually be wrong for BIT n, (HL).
            flags.Y = ((bitNumber === 5) && !flags.Z) ? 1 : 0;
            flags.X = ((bitNumber === 3) && !flags.Z) ? 1 : 0;
        }
        else if (opcode < 0xc0) {
            // RES instructions
            if (regCode === 0)
                b &= (0xff & ~(1 << bitNumber));
            else if (regCode === 1)
                c &= (0xff & ~(1 << bitNumber));
            else if (regCode === 2)
                d &= (0xff & ~(1 << bitNumber));
            else if (regCode === 3)
                e &= (0xff & ~(1 << bitNumber));
            else if (regCode === 4)
                h &= (0xff & ~(1 << bitNumber));
            else if (regCode === 5)
                l &= (0xff & ~(1 << bitNumber));
            else if (regCode === 6)
                core.memWrite(l | (h << 8),
                    core.memRead(l | (h << 8)) & ~(1 << bitNumber));
            else if (regCode === 7)
                a &= (0xff & ~(1 << bitNumber));
        }
        else {
            // SET instructions
            if (regCode === 0)
                b |= (1 << bitNumber);
            else if (regCode === 1)
                c |= (1 << bitNumber);
            else if (regCode === 2)
                d |= (1 << bitNumber);
            else if (regCode === 3)
                e |= (1 << bitNumber);
            else if (regCode === 4)
                h |= (1 << bitNumber);
            else if (regCode === 5)
                l |= (1 << bitNumber);
            else if (regCode === 6)
                core.memWrite(l | (h << 8),
                    core.memRead(l | (h << 8)) | (1 << bitNumber));
            else if (regCode === 7)
                a |= (1 << bitNumber);
        }

        cycleCounter += cycleCountsCB[opcode];
    };
    // 0xcc : CALL Z, nn
    instructions[0xcc] = function () {
        doconditionalCall(!!flags.Z);
    };
    // 0xcd : CALL nn
    instructions[0xcd] = function () {
        pushWord((pc + 3) & 0xffff);
        pc = core.memRead((pc + 1) & 0xffff) |
            (core.memRead((pc + 2) & 0xffff) << 8);
        pc = (pc - 1) & 0xffff;
    };
    // 0xce : ADC A, n
    instructions[0xce] = function () {
        pc = (pc + 1) & 0xffff;
        doadc(core.memRead(pc));
    };
    // 0xcf : RST 08h
    instructions[0xcf] = function () {
        doreset(0x08);
    };
    // 0xd0 : RET NC
    instructions[0xd0] = function () {
        doconditionalReturn(!flags.C);
    };
    // 0xd1 : POP DE
    instructions[0xd1] = function () {
        const result = popWord();
        e = result & 0xff;
        d = (result & 0xff00) >>> 8;
    };
    // 0xd2 : JP NC, nn
    instructions[0xd2] = function () {
        doConditionalAbsoluteJump(!flags.C);
    };
    // 0xd3 : OUT (n), A
    instructions[0xd3] = function () {
        pc = (pc + 1) & 0xffff;
        core.ioWrite((a << 8) | core.memRead(pc), a);
    };
    // 0xd4 : CALL NC, nn
    instructions[0xd4] = function () {
        doconditionalCall(!flags.C);
    };
    // 0xd5 : PUSH DE
    instructions[0xd5] = function () {
        pushWord(e | (d << 8));
    };
    // 0xd6 : SUB n
    instructions[0xd6] = function () {
        pc = (pc + 1) & 0xffff;
        dosub(core.memRead(pc));
    };
    // 0xd7 : RST 10h
    instructions[0xd7] = function () {
        doreset(0x10);
    };
    // 0xd8 : RET C
    instructions[0xd8] = function () {
        doconditionalReturn(!!flags.C);
    };
    // 0xd9 : EXX
    instructions[0xd9] = function () {
        let temp = b;
        b = bPrime;
        bPrime = temp;
        temp = c;
        c = cPrime;
        cPrime = temp;
        temp = d;
        d = dPrime;
        dPrime = temp;
        temp = e;
        e = ePrime;
        ePrime = temp;
        temp = h;
        h = hPrime;
        hPrime = temp;
        temp = l;
        l = lPrime;
        lPrime = temp;
    };
    // 0xda : JP C, nn
    instructions[0xda] = function () {
        doConditionalAbsoluteJump(!!flags.C);
    };
    // 0xdb : IN A, (n)
    instructions[0xdb] = function () {
        pc = (pc + 1) & 0xffff;
        a = core.ioRead((a << 8) | core.memRead(pc));
    };
    // 0xdc : CALL C, nn
    instructions[0xdc] = function () {
        doconditionalCall(!!flags.C);
    };
    // 0xdd : DD Prefix (IX instructions)
    instructions[0xdd] = function () {
        // R is incremented at the start of the second instruction cycle,
        //  before the instruction actually runs.
        // The high bit of R is not affected by this increment,
        //  it can only be changed using the LD R, A instruction.
        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);

        pc = (pc + 1) & 0xffff;
        const opcode = core.memRead(pc),
            func = ddInstructions[opcode];

        if (func) {
            //func = func.bind(this);
            func();
            cycleCounter += cycleCountsDD[opcode];
        }
        else {
            // Apparently if a DD opcode doesn't exist,
            //  it gets treated as an unprefixed opcode.
            // What we'll do to handle that is just back up the
            //  program counter, so that this byte gets decoded
            //  as a normal instruction.
            pc = (pc - 1) & 0xffff;
            // And we'll add in the cycle count for a NOP.
            cycleCounter += cycleCounts[0];
        }
    };
    // 0xde : SBC n
    instructions[0xde] = function () {
        pc = (pc + 1) & 0xffff;
        dosbc(core.memRead(pc));
    };
    // 0xdf : RST 18h
    instructions[0xdf] = function () {
        doreset(0x18);
    };
    // 0xe0 : RET PO
    instructions[0xe0] = function () {
        doconditionalReturn(!flags.P);
    };
    // 0xe1 : POP HL
    instructions[0xe1] = function () {
        const result = popWord();
        l = result & 0xff;
        h = (result & 0xff00) >>> 8;
    };
    // 0xe2 : JP PO, (nn)
    instructions[0xe2] = function () {
        doConditionalAbsoluteJump(!flags.P);
    };
    // 0xe3 : EX (SP), HL
    instructions[0xe3] = function () {
        let temp = core.memRead(sp);
        core.memWrite(sp, l);
        l = temp;
        temp = core.memRead((sp + 1) & 0xffff);
        core.memWrite((sp + 1) & 0xffff, h);
        h = temp;
    };
    // 0xe4 : CALL PO, nn
    instructions[0xe4] = function () {
        doconditionalCall(!flags.P);
    };
    // 0xe5 : PUSH HL
    instructions[0xe5] = function () {
        pushWord(l | (h << 8));
    };
    // 0xe6 : AND n
    instructions[0xe6] = function () {
        pc = (pc + 1) & 0xffff;
        doand(core.memRead(pc));
    };
    // 0xe7 : RST 20h
    instructions[0xe7] = function () {
        doreset(0x20);
    };
    // 0xe8 : RET PE
    instructions[0xe8] = function () {
        doconditionalReturn(!!flags.P);
    };
    // 0xe9 : JP (HL)
    instructions[0xe9] = function () {
        pc = l | (h << 8);
        pc = (pc - 1) & 0xffff;
    };
    // 0xea : JP PE, nn
    instructions[0xea] = function () {
        doConditionalAbsoluteJump(!!flags.P);
    };
    // 0xeb : EX DE, HL
    instructions[0xeb] = function () {
        let temp = d;
        d = h;
        h = temp;
        temp = e;
        e = l;
        l = temp;
    };
    // 0xec : CALL PE, nn
    instructions[0xec] = function () {
        doconditionalCall(!!flags.P);
    };
    // 0xed : ED Prefix
    instructions[0xed] = function () {
        // R is incremented at the start of the second instruction cycle,
        //  before the instruction actually runs.
        // The high bit of R is not affected by this increment,
        //  it can only be changed using the LD R, A instruction.
        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);

        pc = (pc + 1) & 0xffff;
        const opcode = core.memRead(pc),
            func = edInstructions[opcode];

        if (func) {
            //func = func.bind(this);
            func();
            cycleCounter += cycleCountsED[opcode];
        }
        else {
            // If the opcode didn't exist, the whole thing is a two-byte NOP.
            cycleCounter += cycleCounts[0];
        }
    };
    // 0xee : XOR n
    instructions[0xee] = function () {
        pc = (pc + 1) & 0xffff;
        doxor(core.memRead(pc));
    };
    // 0xef : RST 28h
    instructions[0xef] = function () {
        doreset(0x28);
    };
    // 0xf0 : RET P
    instructions[0xf0] = function () {
        doconditionalReturn(!flags.S);
    };
    // 0xf1 : POP AF
    instructions[0xf1] = function () {
        const result = popWord();
        setFlagsRegister(result & 0xff);
        a = (result & 0xff00) >>> 8;
    };
    // 0xf2 : JP P, nn
    instructions[0xf2] = function () {
        doConditionalAbsoluteJump(!flags.S);
    };
    // 0xf3 : DI
    instructions[0xf3] = function () {
        // DI doesn't actually take effect until after the next instruction.
        doDelayedDI = true;
    };
    // 0xf4 : CALL P, nn
    instructions[0xf4] = function () {
        doconditionalCall(!flags.S);
    };
    // 0xf5 : PUSH AF
    instructions[0xf5] = function () {
        pushWord(getFlagsRegister() | (a << 8));
    };
    // 0xf6 : OR n
    instructions[0xf6] = function () {
        pc = (pc + 1) & 0xffff;
        door(core.memRead(pc));
    };
    // 0xf7 : RST 30h
    instructions[0xf7] = function () {
        doreset(0x30);
    };
    // 0xf8 : RET M
    instructions[0xf8] = function () {
        doconditionalReturn(!!flags.S);
    };
    // 0xf9 : LD SP, HL
    instructions[0xf9] = function () {
        sp = l | (h << 8);
    };
    // 0xfa : JP M, nn
    instructions[0xfa] = function () {
        doConditionalAbsoluteJump(!!flags.S);
    };
    // 0xfb : EI
    instructions[0xfb] = function () {
        // EI doesn't actually take effect until after the next instruction.
        doDelayedEI = true;
    };
    // 0xfc : CALL M, nn
    instructions[0xfc] = function () {
        doconditionalCall(!!flags.S);
    };
    // 0xfd : FD Prefix (IY instructions)
    instructions[0xfd] = function () {
        // R is incremented at the start of the second instruction cycle,
        //  before the instruction actually runs.
        // The high bit of R is not affected by this increment,
        //  it can only be changed using the LD R, A instruction.
        r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);

        pc = (pc + 1) & 0xffff;
        const opcode = core.memRead(pc),
            func = ddInstructions[opcode];

        if (func) {
            // Rather than copy and paste all the IX instructions into IY instructions,
            //  what we'll do is sneakily copy IY into IX, run the IX instruction,
            //  and then copy the result into IY and restore the old IX.
            const temp = ix;
            ix = iy;
            //func = func.bind(this);
            func();
            iy = ix;
            ix = temp;

            cycleCounter += cycleCountsDD[opcode];
        }
        else {
            // Apparently if an FD opcode doesn't exist,
            //  it gets treated as an unprefixed opcode.
            // What we'll do to handle that is just back up the
            //  program counter, so that this byte gets decoded
            //  as a normal instruction.
            pc = (pc - 1) & 0xffff;
            // And we'll add in the cycle count for a NOP.
            cycleCounter += cycleCounts[0];
        }
    };
    // 0xfe : CP n
    instructions[0xfe] = function () {
        pc = (pc + 1) & 0xffff;
        docp(core.memRead(pc));
    };
    // 0xff : RST 38h
    instructions[0xff] = function () {
        doreset(0x38);
    };


        const decodeInstruction = function (opcode: number) {
        // The register-to-register loads and ALU instructions
        //  are all so uniform that we can decode them directly
        //  instead of going into the instruction array for them.
        // This function gets the operand for all of these instructions.
        const getOperand = function (opcode: number) {
            return ((opcode & 0x07) === 0) ? b :
                ((opcode & 0x07) === 1) ? c :
                    ((opcode & 0x07) === 2) ? d :
                        ((opcode & 0x07) === 3) ? e :
                            ((opcode & 0x07) === 4) ? h :
                                ((opcode & 0x07) === 5) ? l :
                                    ((opcode & 0x07) === 6) ? core.memRead(l | (h << 8)) : a;
        };

        // Handle HALT right up front, because it fouls up our LD decoding
        //  by falling where LD (HL), (HL) ought to be.
        if (opcode === 0x76) {
            halted = true;
        }
        else if ((opcode >= 0x40) && (opcode < 0x80)) {
            // This entire range is all 8-bit register loads.
            // Get the operand and assign it to the correct destination.
            const operand = getOperand(opcode);

            if (((opcode & 0x38) >>> 3) === 0)
                b = operand;
            else if (((opcode & 0x38) >>> 3) === 1)
                c = operand;
            else if (((opcode & 0x38) >>> 3) === 2)
                d = operand;
            else if (((opcode & 0x38) >>> 3) === 3)
                e = operand;
            else if (((opcode & 0x38) >>> 3) === 4)
                h = operand;
            else if (((opcode & 0x38) >>> 3) === 5)
                l = operand;
            else if (((opcode & 0x38) >>> 3) === 6)
                core.memWrite(l | (h << 8), operand);
            else if (((opcode & 0x38) >>> 3) === 7)
                a = operand;
        }
        else if ((opcode >= 0x80) && (opcode < 0xc0)) {
            // These are the 8-bit register ALU instructions.
            // We'll get the operand and then use this "jump table"
            //  to call the correct utility function for the instruction.
            const operand = getOperand(opcode);
            const opArray = [doadd, doadc, dosub, dosbc,
                    doand, doxor, door, docp];

            opArray[(opcode & 0x38) >>> 3](operand);
        }
        else {
            // This is one of the less formulaic instructions;
            //  we'll get the specific function for it from our array.
            const func = instructions[opcode];
            func();
        }

        // Update the cycle counter with however many cycles
        //  the base instruction took.
        // If this was a prefixed instruction, then
        //  the prefix handler has added its extra cycles already.
        cycleCounter += cycleCounts[opcode];
    };



    function getState(): Z80State {
        return {
            b: b,
            a: a,
            c: c,
            d: d,
            e: e,
            h: h,
            l: l,
            aPrime: aPrime,
            bPrime: bPrime,
            cPrime: cPrime,
            dPrime: dPrime,
            ePrime: ePrime,
            hPrime: hPrime,
            lPrime: lPrime,
            ix: ix,
            iy: iy,
            i: i,
            r: r,
            sp: sp,
            pc: pc,
            flags: {
                S: flags.S,
                Z: flags.Z,
                Y: flags.Y,
                H: flags.H,
                X: flags.X,
                P: flags.P,
                N: flags.N,
                C: flags.C
            },
            flagsPrime: {
                S: flagsPrime.S,
                Z: flagsPrime.Z,
                Y: flagsPrime.Y,
                H: flagsPrime.H,
                X: flagsPrime.X,
                P: flagsPrime.P,
                N: flagsPrime.N,
                C: flagsPrime.C
            },
            imode: imode,
            iff1: iff1,
            iff2: iff2,
            halted: halted,
            doDelayedDI: doDelayedDI,
            doDelayedEI: doDelayedEI,
            cycleCounter: cycleCounter
        };
    }

    function getPC() {
        return pc;
    }

    function setState(state: Z80State) {
        b = state.b;
        a = state.a;
        c = state.c;
        d = state.d;
        e = state.e;
        h = state.h;
        l = state.l;
        aPrime = state.aPrime;
        bPrime = state.bPrime;
        cPrime = state.cPrime;
        dPrime = state.dPrime;
        ePrime = state.ePrime;
        hPrime = state.hPrime;
        lPrime = state.lPrime;
        ix = state.ix;
        iy = state.iy;
        i = state.i;
        r = state.r;
        sp = state.sp;
        pc = state.pc;
        flags.S = state.flags.S;
        flags.Z = state.flags.Z;
        flags.Y = state.flags.Y;
        flags.H = state.flags.H;
        flags.X = state.flags.X;
        flags.P = state.flags.P;
        flags.N = state.flags.N;
        flags.C = state.flags.C;
        flagsPrime.S = state.flagsPrime.S;
        flagsPrime.Z = state.flagsPrime.Z;
        flagsPrime.Y = state.flagsPrime.Y;
        flagsPrime.H = state.flagsPrime.H;
        flagsPrime.X = state.flagsPrime.X;
        flagsPrime.P = state.flagsPrime.P;
        flagsPrime.N = state.flagsPrime.N;
        flagsPrime.C = state.flagsPrime.C;
        imode = state.imode;
        iff1 = state.iff1;
        iff2 = state.iff2;
        halted = state.halted;
        doDelayedDI = state.doDelayedDI;
        doDelayedEI = state.doDelayedEI;
        cycleCounter = state.cycleCounter;
    }

    ///////////////////////////////////////////////////////////////////////////////
    /// @public reset
    ///
    /// @brief Re-initialize the processor as if a reset or power on had occured
    ///////////////////////////////////////////////////////////////////////////////
    const reset = function () {
        // These registers are the ones that have predictable states
        //  immediately following a power-on or a reset.
        // The others are left alone, because their states are unpredictable.
        sp = 0xdff0;
        pc = 0x0000;
        a = 0x00;
        r = 0x00;
        setFlagsRegister(0);
        // Start up with interrupts disabled.
        imode = 0;
        iff1 = 0;
        iff2 = 0;
        // Don't start halted or in a delayed DI or EI.
        halted = false;
        doDelayedDI = false;
        doDelayedEI = false;
        // Obviously we've not used any cycles yet.
        cycleCounter = 0;
    };

    const reset1 = function () {
        sp = 0xdff0;
        pc = 0x0000;
        halted = false;
    }

    ///////////////////////////////////////////////////////////////////////////////
    /// @public run_instruction
    ///
    /// @brief Runs a single instruction
    ///
    /// @return The number of T cycles the instruction took to run,
    ///          plus any time that went into handling interrupts that fired
    ///          while this instruction was executing
    ///////////////////////////////////////////////////////////////////////////////
    const runInstruction = function () {
        if (!halted) {
            // If the previous instruction was a DI or an EI,
            //  we'll need to disable or enable interrupts
            //  after whatever instruction we're about to run is finished.
            let doingDelayedDI = false, doingDelayedEI = false;
            if (doDelayedDI) {
                doDelayedDI = false;
                doingDelayedDI = true;
            }
            else if (doDelayedEI) {
                doDelayedEI = false;
                doingDelayedEI = true;
            }

            // R is incremented at the start of every instruction cycle,
            //  before the instruction actually runs.
            // The high bit of R is not affected by this increment,
            //  it can only be changed using the LD R, A instruction.
            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);

            // Read the byte at the PC and run the instruction it encodes.
            const opcode = core.memRead(pc);
            decodeInstruction(opcode);
            pc = (pc + 1) & 0xffff;

            // Actually do the delayed interrupt disable/enable if we have one.
            if (doingDelayedDI) {
                iff1 = 0;
                iff2 = 0;
            }
            else if (doingDelayedEI) {
                iff1 = 1;
                iff2 = 1;
            }

            // And finally clear out the cycle counter for the next instruction
            //  before returning it to the emulator core.
            const retval = cycleCounter;
            cycleCounter = 0;
            return retval;
        }
        else {
            // While we're halted, claim that we spent a cycle doing nothing,
            //  so that the rest of the emulator can still proceed.
            return 1;
        }
    };

    ///////////////////////////////////////////////////////////////////////////////
    /// @public interrupt
    ///
    /// @brief Simulates pulsing the processor's INT (or NMI) pin
    ///
    /// @param non_maskable - true if this is a non-maskable interrupt
    /// @param data - the value to be placed on the data bus, if needed
    ///////////////////////////////////////////////////////////////////////////////
    const interrupt = function (nonMaskable: boolean, data: number) {
        if (nonMaskable) {
            // The high bit of R is not affected by this increment,
            //  it can only be changed using the LD R, A instruction.
            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);
            // Non-maskable interrupts are always handled the same way;
            //  clear IFF1 and then do a CALL 0x0066.
            // Also, all interrupts reset the HALT state.
            halted = false;
            iff2 = iff1;
            iff1 = 0;
            pushWord(pc);
            pc = 0x66;
            cycleCounter += 11;
        }
        else if (iff1) {
            // The high bit of R is not affected by this increment,
            //  it can only be changed using the LD R, A instruction.
            r = (r & 0x80) | (((r & 0x7f) + 1) & 0x7f);

            halted = false;
            iff1 = 0;
            iff2 = 0;

            if (imode === 0) {
                // In the 8080-compatible interrupt mode,
                //  decode the content of the data bus as an instruction and run it.
                decodeInstruction(data);
                cycleCounter += 2;
            }
            else if (imode === 1) {
                // Mode 1 is always just RST 0x38.
                pushWord(pc);
                pc = 0x38;
                cycleCounter += 13;
            }
            else if (imode === 2) {
                // Mode 2 uses the value on the data bus as in index
                //  into the vector table pointer to by the I register.
                pushWord(pc);
                // The Z80 manual says that this address must be 2-byte aligned,
                //  but it doesn't appear that this is actually the case on the hardware,
                //  so we don't attempt to enforce that here.
                const vectorAddress = ((i << 8) | data);
                pc = core.memRead(vectorAddress) |
                    (core.memRead((vectorAddress + 1) & 0xffff) << 8);

                cycleCounter += 19;
            }
        }
    };

    ///////////////////////////////////////////////////////////////////////////////
    /// The public API functions end here.
    ///
    /// What begins here are just general utility functions, used constiously.
    ///////////////////////////////////////////////////////////////////////////////

    // There's tons of stuff in this object,
    //  but only these three functions are the public API.
    return {
        getState,
        getPC,
        setState,
        reset,
        reset1,
        runInstruction: runInstruction,
        interrupt,
    };
}